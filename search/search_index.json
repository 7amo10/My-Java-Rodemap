{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"My Java Roadmap","text":"<p>Welcome to my Java Learning Journey documentation based on the comprehensive Java Roadmap 2025.</p>"},{"location":"#overview","title":"Overview","text":"<ul> <li> <p> Learning Notes</p> <p>Phase 1 (Java Fundamentals) and Phase 2 (Advanced Java &amp; Concurrency) notes.</p> <p> Start Learning</p> </li> <li> <p> Book Summaries</p> <p>Key takeaways from essential books like Effective Java and Clean Code.</p> <p> Browse Books</p> </li> <li> <p> Resources</p> <p>Curated tutorials, courses, documentation, and development tools.</p> <p> Explore Resources</p> </li> <li> <p> Projects</p> <p>Applied project references demonstrating practical implementation.</p> <p> View Projects</p> </li> </ul>"},{"location":"#learning-path","title":"Learning Path","text":"<pre><code>flowchart TD\n    subgraph phase1[\"**PHASE 1: Java Fundamentals**\"]\n        direction LR\n        A[\"Java Basics&lt;br/&gt;Variables, Types, Control Flow\"]\n        B[\"OOP&lt;br/&gt;Classes, Inheritance, Polymorphism\"]\n        C[\"Core APIs&lt;br/&gt;Collections, Generics, I/O\"]\n        D[\"Java 8+&lt;br/&gt;Lambdas, Streams, Optional\"]\n        A --&gt; B --&gt; C --&gt; D\n    end\n\n    subgraph phase2[\"**PHASE 2: Advanced Java**\"]\n        direction LR\n        E[\"Multithreading&lt;br/&gt;Threads, Locks, ExecutorService\"]\n        F[\"JVM Internals&lt;br/&gt;Memory, Class Loading\"]\n        G[\"GC &amp; Performance&lt;br/&gt;Algorithms, Profiling\"]\n        H[\"Advanced Features&lt;br/&gt;Records, Virtual Threads\"]\n        E --&gt; F --&gt; G --&gt; H\n    end\n\n    phase1 --&gt; phase2</code></pre>"},{"location":"#roadmap-overview","title":"Roadmap Overview","text":"Phase Duration Focus Phase 1 2-3 months Java Fundamentals, OOP, Collections, Java 8+ Phase 2 2-3 months Concurrency, JVM, Performance Phase 3 3-4 months Spring Ecosystem Phase 4 2-3 months Microservices Phase 5-8 Ongoing Design Patterns, Testing, DevOps, Advanced"},{"location":"#getting-started","title":"Getting Started","text":"<ol> <li>Learning Notes - Start with Phase 1 fundamentals</li> <li>Book Summaries - Read Effective Java alongside</li> <li>Resources - Explore curated learning materials</li> <li>Projects - Apply your knowledge with hands-on projects</li> </ol> <p>Quick Navigation</p> <p>Use the search bar (Cmd+K or Ctrl+K) to quickly find any topic.</p>"},{"location":"tags/","title":"Tags","text":"<p>Browse all content by tags.</p>"},{"location":"books/","title":"Book Summaries","text":"<p>Essential books from the Java Roadmap 2025, organized by priority.</p>"},{"location":"books/#must-read-books-priority-order","title":"Must-Read Books (Priority Order)","text":"Book Author Focus Area Status Effective Java Joshua Bloch Best Practices Java Concurrency in Practice Brian Goetz Multithreading Clean Code Robert C. Martin Code Quality Head First Design Patterns Eric Freeman Design Patterns Modern Java in Action Urma, Fusco, Mycroft Java 8+ Features Java Performance Scott Oaks JVM &amp; Performance"},{"location":"books/#phase-1-java-fundamentals-books","title":"Phase 1: Java Fundamentals Books","text":"Book Author Description Head First Java Kathy Sierra &amp; Bert Bates Best for beginners - engaging visual approach Core Java Volume I Cay S. Horstmann In-depth explanations with real-world examples Java: The Complete Reference Herbert Schildt Comprehensive reference - covers everything"},{"location":"books/#phase-2-advanced-java-books","title":"Phase 2: Advanced Java Books","text":"Book Author Description Java Concurrency in Practice Brian Goetz THE definitive concurrency book Java Performance Scott Oaks Essential for JVM internals Optimizing Java Evans, Gough, Newland Advanced optimization techniques"},{"location":"books/#reading-queue","title":"Reading Queue","text":"<p>Planned for Later Phases</p> <ul> <li>Spring in Action - Craig Walls</li> <li>Building Microservices - Sam Newman</li> <li>High-Performance Java Persistence - Vlad Mihalcea</li> <li>Domain-Driven Design - Eric Evans</li> </ul>"},{"location":"books/clean-code/","title":"Clean Code","text":"<p>Author: Robert C. Martin Priority: #3 Must-Read</p>"},{"location":"books/clean-code/#overview","title":"Overview","text":"<p>A handbook of agile software craftsmanship. The bible of writing clean, maintainable code.</p>"},{"location":"books/clean-code/#key-topics","title":"Key Topics","text":"<ul> <li>Meaningful Names</li> <li>Functions</li> <li>Comments</li> <li>Formatting</li> <li>Objects and Data Structures</li> <li>Error Handling</li> <li>Boundaries</li> <li>Unit Tests</li> <li>Classes</li> <li>Systems</li> <li>Emergence</li> <li>Concurrency</li> <li>Smells and Heuristics</li> </ul>"},{"location":"books/clean-code/#notes","title":"Notes","text":""},{"location":"books/core-java-vol1/","title":"Core Java Volume I - Fundamentals","text":"<p>Author: Cay S. Horstmann</p>"},{"location":"books/core-java-vol1/#overview","title":"Overview","text":"<p>In-depth explanations with real-world examples. Excellent for understanding Java deeply.</p>"},{"location":"books/core-java-vol1/#key-topics","title":"Key Topics","text":"<ul> <li>An Introduction to Java</li> <li>The Java Programming Environment</li> <li>Fundamental Programming Structures</li> <li>Objects and Classes</li> <li>Inheritance</li> <li>Interfaces, Lambda Expressions, and Inner Classes</li> <li>Exceptions, Assertions, and Logging</li> <li>Generic Programming</li> <li>Collections</li> <li>Graphical User Interface Programming</li> <li>User Interface Components with Swing</li> <li>Concurrency</li> </ul>"},{"location":"books/core-java-vol1/#notes","title":"Notes","text":""},{"location":"books/effective-java/","title":"Effective Java","text":"<p>Author: Joshua Bloch Edition: 3<sup>rd</sup> Edition (2018) Priority: #1 Must-Read</p>"},{"location":"books/effective-java/#overview","title":"Overview","text":"<p>The definitive guide to Java programming best practices, written by one of the language's key designers. This book should be read multiple times throughout your Java journey, with different items becoming relevant at different stages.</p>"},{"location":"books/effective-java/#book-structure","title":"Book Structure","text":"Chapter Items Related Notes Creating and Destroying Objects 1-9 OOP &amp; Class Design Methods Common to All Objects 10-14 OOP &amp; Class Design Classes and Interfaces 15-25 OOP &amp; Class Design Generics 26-33 Abstraction, Interfaces &amp; Generics Enums and Annotations 34-41 Arrays, Lists &amp; Autoboxing Lambdas and Streams 42-48 Lambdas &amp; Streams Methods 49-56 Syntax &amp; Control Flow General Programming 57-68 Syntax &amp; Control Flow Exceptions 69-77 Phase 1 Advanced Concurrency 78-84 Phase 2 - Advanced Java Serialization 85-90 Phase 2 - Advanced Java"},{"location":"books/effective-java/#phase-1-items-to-focus-on","title":"Phase 1 Items to Focus On","text":""},{"location":"books/effective-java/#creating-and-destroying-objects-items-1-9","title":"Creating and Destroying Objects (Items 1-9)","text":"<ul> <li>Item 1: Consider static factory methods</li> <li>Item 2: Consider a builder for many parameters</li> <li>Item 3: Enforce singleton with private constructor or enum</li> <li>Item 7: Eliminate obsolete object references</li> </ul>"},{"location":"books/effective-java/#classes-and-interfaces-items-15-25","title":"Classes and Interfaces (Items 15-25)","text":"<ul> <li>Item 15: Minimize accessibility</li> <li>Item 17: Minimize mutability</li> <li>Item 18: Favor composition over inheritance</li> <li>Item 20: Prefer interfaces to abstract classes</li> </ul>"},{"location":"books/effective-java/#generics-items-26-33","title":"Generics (Items 26-33)","text":"<ul> <li>Item 26: Don't use raw types</li> <li>Item 28: Prefer lists to arrays</li> <li>Item 31: Use bounded wildcards (PECS)</li> </ul>"},{"location":"books/effective-java/#enums-and-annotations-items-34-39","title":"Enums and Annotations (Items 34-39)","text":"<ul> <li>Item 34: Use enums instead of int constants</li> <li>Item 35: Use instance fields instead of ordinals</li> <li>Item 36: Use EnumSet instead of bit fields</li> <li>Item 37: Use EnumMap instead of ordinal indexing</li> </ul>"},{"location":"books/effective-java/#lambdas-and-streams-items-42-48","title":"Lambdas and Streams (Items 42-48)","text":"<ul> <li>Item 42: Prefer lambdas to anonymous classes</li> <li>Item 43: Prefer method references to lambdas</li> <li>Item 45: Use streams judiciously</li> <li>Item 46: Prefer side-effect-free functions</li> </ul>"},{"location":"books/effective-java/#general-programming-items-57-68","title":"General Programming (Items 57-68)","text":"<ul> <li>Item 57: Minimize scope of local variables</li> <li>Item 58: Prefer for-each loops</li> <li>Item 61: Prefer primitives to boxed primitives</li> </ul>"},{"location":"books/effective-java/#reading-strategy","title":"Reading Strategy","text":"<ol> <li>First Pass (During Phase 1): Read items related to fundamentals</li> <li>Second Pass (During Phase 2): Read concurrency and advanced items</li> <li>Third Pass (During Projects): Reference specific items as needed</li> <li>Ongoing: Keep the book handy as a reference</li> </ol>"},{"location":"books/effective-java/#notes","title":"Notes","text":""},{"location":"books/head-first-design-patterns/","title":"Head First Design Patterns","text":"<p>Authors: Eric Freeman &amp; Elisabeth Robson Priority: #4 Must-Read</p>"},{"location":"books/head-first-design-patterns/#overview","title":"Overview","text":"<p>Best for learning design patterns with an engaging, visual format. Makes complex patterns easy to understand.</p>"},{"location":"books/head-first-design-patterns/#key-topics","title":"Key Topics","text":""},{"location":"books/head-first-design-patterns/#creational-patterns","title":"Creational Patterns","text":"<ul> <li>Singleton, Factory Method, Abstract Factory</li> <li>Builder, Prototype</li> </ul>"},{"location":"books/head-first-design-patterns/#structural-patterns","title":"Structural Patterns","text":"<ul> <li>Adapter, Bridge, Composite</li> <li>Decorator, Facade, Flyweight, Proxy</li> </ul>"},{"location":"books/head-first-design-patterns/#behavioral-patterns","title":"Behavioral Patterns","text":"<ul> <li>Chain of Responsibility, Command, Iterator</li> <li>Mediator, Memento, Observer</li> <li>State, Strategy, Template Method, Visitor</li> </ul>"},{"location":"books/head-first-design-patterns/#notes","title":"Notes","text":""},{"location":"books/head-first-java/","title":"Head First Java","text":"<p>Authors: Kathy Sierra &amp; Bert Bates</p>"},{"location":"books/head-first-java/#overview","title":"Overview","text":"<p>Best for beginners with an engaging visual approach. Makes learning Java fun and memorable.</p>"},{"location":"books/head-first-java/#key-topics","title":"Key Topics","text":"<ul> <li>Breaking the Surface</li> <li>Classes and Objects</li> <li>Primitives and References</li> <li>Methods Use Instance Variables</li> <li>Writing a Program</li> <li>Get to Know the Java API</li> <li>Inheritance and Polymorphism</li> <li>Interfaces and Abstract Classes</li> <li>Constructors and Garbage Collection</li> <li>Numbers and Statics</li> <li>Exception Handling</li> <li>Getting GUI</li> <li>Saving Objects</li> <li>Networking and Threads</li> <li>Collections and Generics</li> </ul>"},{"location":"books/head-first-java/#notes","title":"Notes","text":""},{"location":"books/java-complete-reference/","title":"Java: The Complete Reference","text":"<p>Author: Herbert Schildt</p>"},{"location":"books/java-complete-reference/#overview","title":"Overview","text":"<p>Comprehensive reference that covers everything. Great for looking up specific topics.</p>"},{"location":"books/java-complete-reference/#key-topics","title":"Key Topics","text":"<ul> <li>The History and Evolution of Java</li> <li>Data Types, Variables, and Arrays</li> <li>Operators</li> <li>Control Statements</li> <li>Classes</li> <li>Methods and Classes</li> <li>Inheritance</li> <li>Packages and Interfaces</li> <li>Exception Handling</li> <li>Multithreaded Programming</li> <li>Enumerations, Autoboxing, and Annotations</li> <li>I/O, Try-with-Resources</li> <li>Generics</li> <li>Lambda Expressions</li> <li>String Handling</li> <li>The Collections Framework</li> <li>java.util and more</li> </ul>"},{"location":"books/java-complete-reference/#notes","title":"Notes","text":""},{"location":"books/java-concurrency/","title":"Java Concurrency in Practice","text":"<p>Author: Brian Goetz Priority: #2 Must-Read</p>"},{"location":"books/java-concurrency/#overview","title":"Overview","text":"<p>THE definitive book for Java concurrent programming. Essential for understanding multithreading.</p>"},{"location":"books/java-concurrency/#key-topics","title":"Key Topics","text":"<ul> <li>Thread Safety</li> <li>Sharing Objects</li> <li>Composing Objects</li> <li>Building Blocks</li> <li>Task Execution</li> <li>Cancellation and Shutdown</li> <li>Applying Thread Pools</li> <li>Avoiding Liveness Hazards</li> <li>Performance and Scalability</li> <li>Testing Concurrent Programs</li> <li>Explicit Locks</li> <li>Building Custom Synchronizers</li> <li>Atomic Variables and Nonblocking Synchronization</li> <li>The Java Memory Model</li> </ul>"},{"location":"books/java-concurrency/#notes","title":"Notes","text":""},{"location":"books/java-performance/","title":"Java Performance","text":"<p>Author: Scott Oaks Priority: #6 Must-Read</p>"},{"location":"books/java-performance/#overview","title":"Overview","text":"<p>Essential for understanding JVM internals and performance optimization.</p>"},{"location":"books/java-performance/#key-topics","title":"Key Topics","text":"<ul> <li>JVM Overview</li> <li>Performance Testing</li> <li>Java SE API Tips</li> <li>Heap Memory</li> <li>Garbage Collection</li> <li>Native Memory</li> <li>Threading and Synchronization</li> <li>Database Performance</li> <li>Java Servers</li> </ul>"},{"location":"books/java-performance/#notes","title":"Notes","text":""},{"location":"books/modern-java-in-action/","title":"Modern Java in Action","text":"<p>Authors: Raoul-Gabriel Urma, Mario Fusco, Alan Mycroft Priority: #5 Must-Read</p>"},{"location":"books/modern-java-in-action/#overview","title":"Overview","text":"<p>Comprehensive coverage of Java 8+ features including lambdas, streams, and functional programming.</p>"},{"location":"books/modern-java-in-action/#key-topics","title":"Key Topics","text":"<ul> <li>Lambda Expressions</li> <li>Functional Interfaces</li> <li>Stream API</li> <li>Collecting Data with Streams</li> <li>Parallel Data Processing</li> <li>Optional Class</li> <li>CompletableFuture</li> <li>Date and Time API</li> <li>Default Methods</li> <li>Modules</li> </ul>"},{"location":"books/modern-java-in-action/#notes","title":"Notes","text":""},{"location":"books/optimizing-java/","title":"Optimizing Java","text":"<p>Authors: Benjamin J. Evans, James Gough, Chris Newland</p>"},{"location":"books/optimizing-java/#overview","title":"Overview","text":"<p>Advanced optimization techniques for Java applications.</p>"},{"location":"books/optimizing-java/#key-topics","title":"Key Topics","text":"<ul> <li>Optimization and Performance Defined</li> <li>Overview of the JVM</li> <li>Hardware and Operating Systems</li> <li>Performance Testing Patterns</li> <li>Microbenchmarking and Statistics</li> <li>Understanding Garbage Collection</li> <li>GC Logging, Monitoring, Tuning, and Tools</li> <li>Code Execution on the JVM</li> <li>Understanding Just-in-Time Compilation</li> <li>Understanding Java Language Performance</li> <li>Profiling</li> <li>Concurrent Performance Techniques</li> <li>JDK Futures</li> </ul>"},{"location":"books/optimizing-java/#notes","title":"Notes","text":""},{"location":"notes/","title":"Learning Notes","text":"<p>Structured notes following the Java Roadmap 2025 - covering Phase 1 (Java Fundamentals) and Phase 2 (Advanced Java &amp; Concurrency).</p>","tags":[]},{"location":"notes/#phase-1-java-fundamentals","title":"Phase 1: Java Fundamentals","text":"<p>Duration: 1-2 Months</p> <p>Build a rock-solid foundation in Java programming, focusing on core concepts and object-oriented principles.</p> <p> Go to Phase 1</p> Topic Description Status Topic 1: Java Basic Interactive Applications Variables, data types, operators, control flow, loops, methods, user input Topic 2: OOP &amp; Class Design Classes, inheritance, polymorphism, abstraction, composition Topic 3: Arrays, Lists &amp; Autoboxing Arrays, ArrayList, LinkedList, Iterators, Autoboxing, Enums Topic 4: Abstraction, Interfaces, Generics &amp; Nested Classes Abstract classes, interfaces, generics, wildcards, nested classes Topic 5: Lambdas &amp; Streams Lambda expressions, Stream API, Optional, Method References Topic 6: Collections Framework List, Set, Map, Queue implementations, internals","tags":[]},{"location":"notes/#phase-2-advanced-java-concurrency","title":"Phase 2: Advanced Java &amp; Concurrency","text":"<p>Duration: 2-3 Months</p> <p>Master advanced Java concepts including multithreading, concurrency primitives, and JVM internals.</p> <p> Go to Phase 2</p> Topic Description Status Multithreading &amp; Concurrency Threads, synchronization, locks, ExecutorService JVM Internals &amp; Memory JVM architecture, class loading, memory management Garbage Collection GC algorithms, tuning, profiling Performance Optimization Profiling, bottlenecks, optimization techniques Advanced Java Features Modules, Records, Sealed Classes, Virtual Threads <p>Study Approach</p> <ul> <li>Follow the phases in order. Each topic builds upon previous concepts. Phase 1 establishes the foundation, Phase 2 dives into internals and advanced concepts.</li> </ul>","tags":[]},{"location":"notes/phase-1/","title":"Phase 1: Java Fundamentals","text":"<p>Build a rock-solid foundation in Java programming, focusing on core concepts and object-oriented principles.</p> <p>Duration: 2-3 Months</p>"},{"location":"notes/phase-1/#learning-resources","title":"Learning Resources","text":"Resource Type Name Course Tim Buchalka's Java Masterclass (Udemy) Book Effective Java by Joshua Bloch Book Core Java Volume I by Cay S. Horstmann"},{"location":"notes/phase-1/#topics","title":"Topics","text":"<ul> <li> <p> Topic 1: Java Basic Interactive Applications</p> <p>Variables, data types, operators, control flow, methods, loops, switch, user input.</p> <p> Explore Topic</p> </li> <li> <p> Topic 2: OOP &amp; Class Design Internals</p> <p>Classes, objects, encapsulation, inheritance, polymorphism, abstraction, composition.</p> <p> Explore Topic</p> </li> <li> <p> Topic 3: Arrays, Lists &amp; Autoboxing</p> <p>Arrays, ArrayList, LinkedList, Iterators, Autoboxing/Unboxing, Enums.</p> <p> Explore Topic</p> </li> <li> <p> Topic 4: Abstraction, Interfaces, Generics &amp; Nested Classes</p> <p>Abstract classes, interfaces, generics, bounded types, wildcards, comparators, nested &amp; anonymous classes.</p> <p> Explore Topic</p> </li> <li> <p> Topic 5: Lambdas &amp; Streams</p> <p>Lambda expressions, Functional Interfaces, Stream API, Optional, Method References.</p> <p> Explore Topic</p> </li> <li> <p> Topic 6: Collections Framework</p> <p>List, Set, Map, Queue implementations, internal workings, performance characteristics.</p> <p> Explore Topic</p> </li> </ul>"},{"location":"notes/phase-1/#topic-structure","title":"Topic Structure","text":"<p>Each topic folder contains three key documents:</p> Document Purpose <code>topic-note.md</code> Course notes from Tim Buchalka's Udemy course - brainstorming and observed ideas <code>book-reading.md</code> Notes from Effective Java - building theoretical mindset <code>summary.md</code> Final combined understanding - comprehensive topic mastery"},{"location":"notes/phase-1/#project-ideas","title":"Project Ideas","text":"<ol> <li>Command-line Calculator - Practice methods, exception handling</li> <li>Student Management System - Use OOP, collections, file I/O</li> <li>Library Management System - Comprehensive use of all fundamentals</li> </ol>"},{"location":"notes/phase-1/#phase-progress","title":"Phase Progress","text":"<ul> <li> Topic 1: Java Basic Interactive Applications</li> <li> Topic 2: OOP &amp; Class Design Internals</li> <li> Topic 3: Arrays, Lists &amp; Autoboxing</li> <li> Topic 4: Abstraction, Interfaces, Generics &amp; Nested Classes</li> <li> Topic 5: Lambdas &amp; Streams</li> <li> Topic 6: Collections Framework</li> <li> Phase 1 Project</li> </ul> <p>Phase Start Date:  | Target Completion: </p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/","title":"Topic 1: Java Basic Interactive Applications","text":"<p>Building the foundation of Java programming with rock-solid understanding of language basics, control flow, loops, and interactive applications.</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/#topic-structure","title":"Topic Structure","text":"Document Purpose Status  Topic Note (Part 1) Expressions, Statements, Methods, Overloading  Complete  Topic Note (Part 2) Switch, Loops, Scope, Scanner  Complete  Book Reading Effective Java Items 57, 58, 61  Complete  Summary Combined final understanding  Complete"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/#what-youll-master","title":"What You'll Master","text":""},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/#part-1-foundations","title":"Part 1: Foundations","text":"<ul> <li>Variables &amp; Data Types - Primitives, references, type conversion</li> <li>Operators &amp; Expressions - All operator types and precedence</li> <li>Statements &amp; Code Blocks - Building blocks of Java programs</li> <li>Methods - Declaration, parameters, return types, overloading</li> </ul>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/#part-2-control-flow-interactivity","title":"Part 2: Control Flow &amp; Interactivity","text":"<ul> <li>Switch Statement - Traditional vs Enhanced (Java 14+), switch expressions</li> <li>Loops - for, while, do-while statements</li> <li>Loop Control - break and continue keywords</li> <li>Variable Scope - Local variables and code block accessibility</li> <li>User Input - Scanner class and exception handling</li> </ul>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/#resources","title":"Resources","text":""},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/#primary-course-sections","title":"Primary Course Sections","text":"<ul> <li>Section 05: Mastering Java Expressions, Statements, Code Blocks, And Method Overloading</li> <li>Section 06: Mastering Conditional Logic, Loops, And Interactive Java Applications</li> </ul>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/#book-reference","title":"Book Reference","text":"<ul> <li>Effective Java by Joshua Bloch - Items 57, 58, 61</li> </ul>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/#key-internals-to-understand","title":"Key Internals to Understand","text":"<ul> <li>How Java is platform-independent (bytecode &amp; JVM)</li> <li>Difference between stack and heap memory allocation</li> <li>Pass-by-value mechanism in Java</li> </ul>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/#progress-tracker","title":"Progress Tracker","text":"<ul> <li> Complete Tim's course Section 05 (Expressions, Methods)</li> <li> Complete Tim's course Section 06 (Loops, Switch, Scanner)</li> <li> Read Effective Java Items 57, 58, 61</li> <li> Write topic notes (Part 1 &amp; Part 2)</li> <li> Complete book reading notes</li> <li> Synthesize final summary</li> <li> Build practice examples</li> </ul> <p>Start Date: 2026-01-22 | Completed: 2026-01-24</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/","title":"Book Reading: Syntax, Variables &amp; Control Flow","text":"<p>Book: Effective Java (3<sup>rd</sup> Edition) by Joshua Bloch Relevant Items: 57, 58, 61 (Chapter 9: General Programming) Status:  Completed</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#reading-goals","title":"Reading Goals","text":"<ul> <li> Understand Joshua Bloch's perspective on fundamental Java practices</li> <li> Build theoretical mindset around language constructs</li> <li> Extract best practices for variables and method design</li> <li> Learn when to break the rules and why</li> </ul>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#chapter-notes","title":"Chapter Notes","text":""},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#item-57-minimize-the-scope-of-local-variables","title":"Item 57: Minimize the Scope of Local Variables","text":""},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#the-core-principle","title":"The Core Principle","text":"<p>\"The most powerful technique for minimizing the scope of a local variable is to declare it where it is first used.\"</p> <p>Most programming languages, including older versions of C, required variables to be declared at the beginning of a block. This led to declaring all variables at the top of methods, creating a gap between declaration and usage that makes code harder to understand and easier to break.</p> <p>Java allows declaration anywhere in a block - use this power wisely!</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#why-scope-minimization-matters","title":"Why Scope Minimization Matters","text":"<pre><code>flowchart LR\n    A[Large Scope] --&gt; B[Hard to Track Value]\n    A --&gt; C[Accidental Reuse]\n    A --&gt; D[Cluttered Context]\n\n    E[Minimal Scope] --&gt; F[Clear Purpose]\n    E --&gt; G[Self-Documenting]\n    E --&gt; H[GC Friendly]\n\n    style E fill:#2e7d32,color:#fff\n    style A fill:#c62828,color:#fff</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#the-techniques","title":"The Techniques","text":""},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#1-declare-variables-where-first-used","title":"1. Declare Variables Where First Used","text":"<pre><code>// \u274c Bad: C-style declaration at top\npublic void processItems(List&lt;Item&gt; items) {\n    int count;          // What is this for?\n    String name;        // Which name?\n    Item current;       // Current what?\n\n    // ... 50 lines later ...\n\n    for (current = items.get(0); /* ... */) {\n        name = current.getName();\n        count++;\n    }\n}\n\n// \u2705 Good: Declaration at point of use\npublic void processItems(List&lt;Item&gt; items) {\n    // Variables declared exactly where needed\n    for (Item current : items) {          // Scope: loop only\n        String name = current.getName();   // Scope: iteration only\n        processName(name);\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#2-initialize-variables-with-declaration","title":"2. Initialize Variables with Declaration","text":"<p>\"Nearly every local variable declaration should contain an initializer.\"</p> <pre><code>// \u274c Bad: Declaration without initialization\nList&lt;String&gt; names;\n// ... code that might or might not initialize names ...\nif (condition) {\n    names = getNames();  // Might not execute!\n}\nnames.size();  // Potential NullPointerException or uninitialized variable\n\n// \u2705 Good: Always initialize\nList&lt;String&gt; names = getNames();  // Clear intent, no ambiguity\n</code></pre> <p>Exception: <code>try-catch</code> blocks sometimes require declaration outside:</p> <pre><code>// Acceptable pattern when initialization can throw\nConnection connection = null;\ntry {\n    connection = dataSource.getConnection();\n    // use connection\n} catch (SQLException e) {\n    // handle\n} finally {\n    if (connection != null) {\n        connection.close();\n    }\n}\n\n// Even better with try-with-resources (Item 9)\ntry (Connection connection = dataSource.getConnection()) {\n    // use connection\n}  // Automatically closed\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#3-prefer-for-loops-to-while-loops-for-scope","title":"3. Prefer For Loops to While Loops (for scope)","text":"<p>The <code>for</code> loop has a tighter scope for the loop variable:</p> <pre><code>// \u274c While loop: iterator leaks into enclosing scope\nIterator&lt;Element&gt; i = c.iterator();\nwhile (i.hasNext()) {\n    doSomething(i.next());\n}\n\n// Bug waiting to happen:\nIterator&lt;Element&gt; i2 = c2.iterator();\nwhile (i.hasNext()) {  // Oops! Used wrong iterator, compiles fine!\n    doSomething(i2.next());\n}\n\n// \u2705 For loop: iterator scoped to loop\nfor (Iterator&lt;Element&gt; i = c.iterator(); i.hasNext(); ) {\n    doSomething(i.next());\n}\n\n// This bug would be caught at compile time:\nfor (Iterator&lt;Element&gt; i2 = c2.iterator(); i.hasNext(); ) {\n    // COMPILE ERROR: i cannot be resolved\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#4-keep-methods-small-and-focused","title":"4. Keep Methods Small and Focused","text":"<pre><code>// \u274c Long method = large variable scopes\npublic void processOrder() {\n    Customer customer = getCustomer();\n    // ... 100 lines where customer is in scope but not used ...\n    Address address = getAddress();\n    // ... 50 lines where both are in scope ...\n    sendConfirmation(customer, address);\n}\n\n// \u2705 Small methods = minimal scopes\npublic void processOrder() {\n    validateOrder();\n    calculateTotal();\n    sendConfirmation();\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#quotes-to-remember","title":"Quotes to Remember","text":"<p>\"If a variable is declared before it is used, it's just clutter\u2014one more thing to distract the reader who is trying to figure out what the program does.\"</p> <p>\"Declaring a local variable prematurely can cause its scope not only to begin too early but also to end too late.\"</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#item-58-prefer-for-each-loops-to-traditional-for-loops","title":"Item 58: Prefer For-Each Loops to Traditional For Loops","text":""},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#the-evolution-of-iteration","title":"The Evolution of Iteration","text":"<pre><code>timeline\n    title Java Iteration Evolution\n    Java 1.0 : Traditional for loop with index\n    Java 1.2 : Iterator pattern for Collections\n    Java 5 : Enhanced for-each loop (for-in)\n    Java 8 : Stream.forEach() (functional style)</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#why-for-each-is-superior","title":"Why For-Each is Superior","text":"<p>The traditional <code>for</code> loop has three things that can go wrong:</p> <pre><code>// Traditional for loop - prone to error\nfor (int i = 0; i &lt; array.length; i++) {\n    doSomething(array[i]);\n}\n</code></pre> Error Source Risk Initialization (<code>int i = 0</code>) Off-by-one if wrong start Condition (<code>i &lt; array.length</code>) Off-by-one, infinite loop Increment (<code>i++</code>) Wrong direction, skip elements Index usage (<code>array[i]</code>) Copy-paste with wrong array <p>For-each eliminates ALL of these:</p> <pre><code>// For-each - clean and safe\nfor (Element e : elements) {\n    doSomething(e);\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#the-nested-loop-bug","title":"The Nested Loop Bug","text":"<p>This is a famous pitfall that for-each prevents:</p> <pre><code>enum Suit { CLUB, DIAMOND, HEART, SPADE }\nenum Rank { ACE, TWO, THREE, /* ... */ KING }\n\n// \u274c BROKEN - throws NoSuchElementException\nList&lt;Card&gt; deck = new ArrayList&lt;&gt;();\nfor (Iterator&lt;Suit&gt; i = suits.iterator(); i.hasNext(); ) {\n    for (Iterator&lt;Rank&gt; j = ranks.iterator(); j.hasNext(); ) {\n        deck.add(new Card(i.next(), j.next()));\n        //                 \u2191 Bug! Called once per rank, not once per suit\n    }\n}\n\n// \u2705 For-each: impossible to make this mistake\nfor (Suit suit : suits) {\n    for (Rank rank : ranks) {\n        deck.add(new Card(suit, rank));\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#when-traditional-for-is-required","title":"When Traditional For is REQUIRED","text":"<p>Joshua Bloch identifies three situations where you cannot use for-each:</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#1-destructive-filtering-removing-elements","title":"1. Destructive Filtering (Removing Elements)","text":"<pre><code>// \u274c ConcurrentModificationException!\nfor (Element e : collection) {\n    if (shouldRemove(e)) {\n        collection.remove(e);\n    }\n}\n\n// \u2705 Traditional iterator with explicit remove\nfor (Iterator&lt;Element&gt; i = collection.iterator(); i.hasNext(); ) {\n    Element e = i.next();\n    if (shouldRemove(e)) {\n        i.remove();  // Safe removal\n    }\n}\n\n// \u2705 Java 8+: Even cleaner\ncollection.removeIf(e -&gt; shouldRemove(e));\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#2-transforming-replacing-elements","title":"2. Transforming (Replacing Elements)","text":"<pre><code>// \u274c For-each loop variable is a copy\nfor (String s : list) {\n    s = s.toUpperCase();  // Only modifies local copy!\n}\n\n// \u2705 Traditional for with index\nfor (int i = 0; i &lt; list.size(); i++) {\n    list.set(i, list.get(i).toUpperCase());\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#3-parallel-iteration","title":"3. Parallel Iteration","text":"<pre><code>// \u274c Cannot control two iterators independently\nfor (String name : names) {\n    // How do we get corresponding age?\n}\n\n// \u2705 Traditional for with shared index\nfor (int i = 0; i &lt; names.size(); i++) {\n    System.out.println(names.get(i) + \": \" + ages.get(i));\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#decision-diagram","title":"Decision Diagram","text":"<pre><code>flowchart TD\n    A[Need to iterate?] --&gt; B{Modifying collection?}\n    B --&gt;|Yes, removing| C[Use Iterator.remove&lt;br/&gt;or removeIf]\n    B --&gt;|Yes, replacing| D[Use traditional for&lt;br/&gt;with index]\n    B --&gt;|No| E{Parallel iteration?}\n    E --&gt;|Yes| F[Use traditional for&lt;br/&gt;with shared index]\n    E --&gt;|No| G[Use for-each loop]\n\n    style G fill:#2e7d32,color:#fff\n    style C fill:#f57c00,color:#fff\n    style D fill:#f57c00,color:#fff\n    style F fill:#f57c00,color:#fff</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#quotes-to-remember_1","title":"Quotes to Remember","text":"<p>\"The for-each loop provides compelling advantages over the traditional for loop in clarity, flexibility, and bug prevention, with no performance penalty.\"</p> <p>\"Not only does the for-each loop let you iterate over collections and arrays, it lets you iterate over any object that implements the Iterable interface.\"</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#item-61-prefer-primitive-types-to-boxed-primitives","title":"Item 61: Prefer Primitive Types to Boxed Primitives","text":""},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#the-two-type-systems","title":"The Two Type Systems","text":"<p>Java has a fundamental duality:</p> Primitive Boxed (Reference) <code>int</code> <code>Integer</code> <code>long</code> <code>Long</code> <code>double</code> <code>Double</code> <code>boolean</code> <code>Boolean</code> <code>char</code> <code>Character</code> <code>byte</code> <code>Byte</code> <code>short</code> <code>Short</code> <code>float</code> <code>Float</code>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#the-three-critical-differences","title":"The Three Critical Differences","text":"<pre><code>mindmap\n  root((Primitives vs&lt;br/&gt;Boxed))\n    **Identity**\n      Primitives: only value\n      Boxed: value + identity\n      Two boxed can be .equals but !=\n    **Nullability**\n      Primitives: always valid\n      Boxed: can be null\n      Source of NullPointerException\n    **Performance**\n      Primitives: fast, stack-based\n      Boxed: slow, heap-based\n      Autoboxing creates objects</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#difference-1-identity-vs-value","title":"Difference 1: Identity vs Value","text":"<pre><code>// \u274c Broken comparator - can you spot the bug?\nComparator&lt;Integer&gt; naturalOrder = (i, j) -&gt; (i &lt; j) ? -1 : (i == j ? 0 : 1);\n\n// Test it:\nnaturalOrder.compare(new Integer(42), new Integer(42));  // Returns 1, not 0!\n\n// Why? When i == j is evaluated:\n// - i &lt; j uses unboxing: 42 &lt; 42 is false \u2713\n// - i == j compares IDENTITY (references), not values!\n// - These are different Integer objects, so i == j is false!\n\n// \u2705 Fixed: use equals() or unbox first\nComparator&lt;Integer&gt; naturalOrder = (iBoxed, jBoxed) -&gt; {\n    int i = iBoxed;  // Auto-unboxing\n    int j = jBoxed;  // Auto-unboxing\n    return (i &lt; j) ? -1 : ((i == j) ? 0 : 1);\n};\n\n// \u2705 Or simply use the built-in\nComparator&lt;Integer&gt; naturalOrder = Integer::compare;\n</code></pre> <p>Identity Trap</p> <p>Never use <code>==</code> on boxed primitives unless you're checking for <code>null</code>! Use <code>.equals()</code> or unbox to primitives first.</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#difference-2-nullability-the-silent-killer","title":"Difference 2: Nullability (The Silent Killer)","text":"<pre><code>public class Unbelievable {\n    static Integer i;  // Defaults to null (not 0!)\n\n    public static void main(String[] args) {\n        if (i == 42) {  // NullPointerException!\n            System.out.println(\"Unbelievable\");\n        }\n    }\n}\n</code></pre> <p>What happens? 1. <code>i</code> is <code>Integer</code> reference, defaults to <code>null</code> 2. <code>i == 42</code> triggers auto-unboxing 3. Unboxing <code>null</code> throws <code>NullPointerException</code></p> <pre><code>// \u2705 Fix: use primitive\nstatic int i;  // Defaults to 0\n\n// Or: null check if boxed is necessary\nif (i != null &amp;&amp; i == 42) { ... }\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#difference-3-performance-death-by-a-thousand-cuts","title":"Difference 3: Performance (Death by a Thousand Cuts)","text":"<pre><code>// \u274c Hideously slow - can you spot why?\npublic static void main(String[] args) {\n    Long sum = 0L;  // Boxed type!\n    for (long i = 0; i &lt;= Integer.MAX_VALUE; i++) {\n        sum += i;  // Creates 2^31 Long objects!\n    }\n    System.out.println(sum);\n}\n// Takes about 6.3 seconds\n\n// \u2705 Fast version\npublic static void main(String[] args) {\n    long sum = 0L;  // Primitive type\n    for (long i = 0; i &lt;= Integer.MAX_VALUE; i++) {\n        sum += i;  // Simple addition\n    }\n    System.out.println(sum);\n}\n// Takes about 0.6 seconds - 10x faster!\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#memory-comparison","title":"Memory Comparison","text":"Type Size (bits) Heap Overhead <code>int</code> 32 None (stack) <code>Integer</code> 128+ Object header + padding <code>long</code> 64 None (stack) <code>Long</code> 192+ Object header + padding <p>A single <code>Integer</code> uses 4x the memory of an <code>int</code>!</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#when-to-use-boxed-primitives","title":"When to Use Boxed Primitives","text":"<p>Despite the drawbacks, boxed primitives are required for:</p> Use Case Reason Collections (<code>List&lt;Integer&gt;</code>) Generics don't support primitives Generic type parameters <code>Map&lt;String, Integer&gt;</code> Reflective method invocations Object-based API Nullable values When <code>null</code> is meaningful"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#decision-checklist","title":"Decision Checklist","text":"<pre><code>// Ask yourself these questions:\n\n// 1. Does it need to go in a collection?\nList&lt;Integer&gt; numbers;  // Boxed required\n\n// 2. Does it need to be nullable?\nInteger employeeId;  // null = \"not assigned\"\nint employeeId = -1;  // Magic number (avoid!)\n\n// 3. Is it a generic type parameter?\nOptional&lt;Integer&gt; maybeValue;  // Boxed required\n\n// If NO to all three: use primitives!\nint count = 0;  // \u2705 Primitive\nlong total = 0L;  // \u2705 Primitive\nboolean isValid = true;  // \u2705 Primitive\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#quotes-to-remember_2","title":"Quotes to Remember","text":"<p>\"Autoboxing reduces the verbosity, but not the danger, of using boxed primitives.\"</p> <p>\"There's no way to create a boxed primitive value that says 'I'm the same as that other one.' Two boxed primitives can have the same value but be different objects.\"</p> <p>\"In nearly every case where a primitive type is appropriate, you should use it.\"</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#theoretical-framework","title":"Theoretical Framework","text":""},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#mental-model-for-variables","title":"Mental Model for Variables","text":"<p>Think of variables like labeled boxes in a warehouse:</p> <pre><code>flowchart LR\n    subgraph \"Good: Minimal Scope\"\n        A[\ud83d\udce6 temp] -.-&gt; |\"Exists only&lt;br/&gt;when needed\"| B[\ud83d\uddd1\ufe0f Discarded]\n    end\n\n    subgraph \"Bad: Large Scope\"\n        C[\ud83d\udce6 temp] --&gt; D[\ud83d\udce6 temp] --&gt; E[\ud83d\udce6 temp] --&gt; F[\ud83d\udce6 temp]\n        F -.-&gt; |\"Finally&lt;br/&gt;discarded\"| G[\ud83d\uddd1\ufe0f]\n    end</code></pre> <p>Key principles:</p> <ol> <li>Declare late - Create the box when you need it</li> <li>Initialize immediately - Put something in it right away</li> <li>Scope narrowly - Keep it in a small room, not the whole warehouse</li> <li>Prefer primitive boxes - They're smaller and faster</li> </ol>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#control-flow-design-principles","title":"Control Flow Design Principles","text":"<p>From Bloch's wisdom, derive these principles for loops:</p> <ol> <li>Default to for-each - It's safer and cleaner</li> <li>Read the exceptions - Know when traditional is required</li> <li>Consider <code>removeIf()</code> and Streams - Modern alternatives exist</li> <li>Make intent clear - The loop style signals your purpose</li> </ol>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#reflections-connections","title":"Reflections &amp; Connections","text":""},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#connections-to-course-material","title":"Connections to Course Material","text":"Effective Java Item Note Section Connection Item 57 (Scope) Code Blocks Both emphasize variables living in the smallest possible block Item 58 (For-each) Control Flow For-each is the modern expression of iteration Item 61 (Primitives) Variables &amp; Data Types Understanding when types matter beyond just syntax <p>Key insight: The course teaches you how to use these constructs. Effective Java teaches you when and why to prefer one over another. Together, they create mastery.</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#new-perspectives-gained","title":"New Perspectives Gained","text":"<ol> <li>Scope is a safety feature, not just organization</li> <li>Loop choice communicates intent - for-each says \"I'm reading,\" traditional says \"I'm modifying or need control\"</li> <li>Autoboxing is convenient but dangerous - like a power tool, respect it</li> <li>Compile-time safety is worth pursuing - Item 57's for-loop example shows how scope catches bugs</li> <li>Performance intuition - Now I'll notice <code>Long sum = 0L</code> as a red flag</li> </ol>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#summary-points","title":"Summary Points","text":"<ol> <li>Declare variables at point of first use - minimizes scope, maximizes clarity</li> <li>Always initialize variables - avoid ambiguity and potential bugs</li> <li>Prefer for loops to while loops when loop variable is needed - catches copy-paste bugs at compile time</li> <li>Use for-each by default - it's safer, cleaner, and just as fast</li> <li>Know the three for-each exceptions: filtering, transforming, parallel iteration</li> <li>Boxed primitives have identity - never use <code>==</code> except for null checks</li> <li>Boxed primitives can be null - autoboxing null throws NPE</li> <li>Prefer primitives for performance - avoid \"Long sum = 0L\" patterns</li> <li>Reserve boxed types for generics and nullability - when required by API</li> </ol>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#bookmarks-page-references","title":"Bookmarks &amp; Page References","text":"Topic Item Key Quote Variable declaration timing 57 \"Declare it where it is first used\" for vs while scope 57 \"Compile-time error is better than runtime bug\" For-each advantages 58 \"No performance penalty, prevents bugs\" Nested iteration bug 58 Classic iterator.next() in inner loop Three for-each exceptions 58 Filtering, transforming, parallel iteration <code>==</code> on boxed types 61 Identity comparison, not value Null unboxing 61 Auto-unboxing null \u2192 NPE Performance impact 61 \"Long sum\" example - 10x slower"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/book-reading/#practical-checklist","title":"Practical Checklist","text":"<p>Before writing a variable declaration, ask:</p> <ul> <li> Is this the first place I use this variable?</li> <li> Am I initializing it immediately?</li> <li> Could I use a for-loop instead of while to restrict scope?</li> </ul> <p>Before writing a loop, ask:</p> <ul> <li> Can I use for-each? (Default choice)</li> <li> Am I removing elements? \u2192 Use iterator.remove() or removeIf()</li> <li> Am I replacing elements? \u2192 Use traditional for with index</li> <li> Am I iterating in parallel? \u2192 Use traditional for with shared index</li> </ul> <p>Before using a boxed primitive, ask:</p> <ul> <li> Is this required for a collection or generic?</li> <li> Do I need nullability?</li> <li> If no to both \u2192 Use primitive instead!</li> <li> If yes \u2192 Remember: no <code>==</code>, check for null</li> </ul> <p>Last Updated: 2026-01-22</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/","title":"Summary: Syntax, Variables &amp; Control Flow","text":"<p>Combined Knowledge from: Tim Buchalka's Course + Effective Java Mastery Level: </p>","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#topic-overview","title":"Topic Overview","text":"<p>A comprehensive understanding of Java's foundational syntax, variable management, and control flow constructs that form the backbone of all Java programs. This topic also covers crucial JVM internals that every Java developer must understand.</p>","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#core-concepts","title":"Core Concepts","text":"","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#1-variables-data-types","title":"1. Variables &amp; Data Types","text":"","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#primitive-types","title":"Primitive Types","text":"Type Size Default Range <code>byte</code> 8-bit 0 -128 to 127 <code>short</code> 16-bit 0 -32,768 to 32,767 <code>int</code> 32-bit 0 -2\u00b3\u00b9 to 2\u00b3\u00b9-1 <code>long</code> 64-bit 0L -2\u2076\u00b3 to 2\u2076\u00b3-1 <code>float</code> 32-bit 0.0f IEEE 754 <code>double</code> 64-bit 0.0d IEEE 754 <code>boolean</code> 1-bit false true/false <code>char</code> 16-bit '\\u0000' Unicode characters","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#key-insights","title":"Key Insights","text":"<ul> <li>Primitives live on the Stack - fast access, automatic cleanup</li> <li>Default values matter - uninitialized instance fields get defaults, local variables don't!</li> <li>Boxed types (Integer, Long, etc.) - slower, can be null, needed for collections</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#2-operators-expressions","title":"2. Operators &amp; Expressions","text":"","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#operator-precedence-high-to-low","title":"Operator Precedence (High to Low)","text":"<ol> <li>Postfix: <code>expr++</code>, <code>expr--</code></li> <li>Unary: <code>++expr</code>, <code>--expr</code>, <code>+</code>, <code>-</code>, <code>!</code></li> <li>Multiplicative: <code>*</code>, <code>/</code>, <code>%</code></li> <li>Additive: <code>+</code>, <code>-</code></li> <li>Relational: <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code></li> <li>Equality: <code>==</code>, <code>!=</code></li> <li>Logical AND: <code>&amp;&amp;</code></li> <li>Logical OR: <code>||</code></li> <li>Assignment: <code>=</code>, <code>+=</code>, <code>-=</code>, etc.</li> </ol>","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#best-practices","title":"Best Practices","text":"<ul> <li>Use parentheses liberally - don't rely on precedence memory</li> <li>Avoid side effects in expressions - <code>a[i] = i++</code> is confusing</li> <li>Short-circuit evaluation - <code>&amp;&amp;</code> and <code>||</code> don't evaluate right side if left determines result</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#3-control-flow-mastery","title":"3. Control Flow Mastery","text":"","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#decision-making","title":"Decision Making","text":"<pre><code>// Modern switch expression (Java 14+)\nString result = switch (day) {\n    case MONDAY, FRIDAY, SUNDAY -&gt; \"Relaxed day\";\n    case TUESDAY, WEDNESDAY -&gt; \"Busy day\";\n    case THURSDAY, SATURDAY -&gt; \"Moderate day\";\n};\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#iteration-patterns-from-effective-java","title":"Iteration Patterns (from Effective Java)","text":"Pattern Use Case Example for-each Default choice - simple iteration <code>for (Item i : items)</code> Traditional for Need index, parallel iteration <code>for (int i = 0; ...)</code> Iterator Need to remove during iteration <code>iter.remove()</code> Stream.forEach Functional style <code>items.forEach(...)</code>","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#key-internals-to-understand","title":"Key Internals to Understand","text":"","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#1-platform-independence-jvm-bytecode","title":"1. Platform Independence: JVM &amp; Bytecode","text":"<p>\"Write Once, Run Anywhere\" (WORA) is Java's foundational promise.</p> <pre><code>flowchart LR\n    A[Java Source&lt;br/&gt;.java] --&gt;|javac| B[Bytecode&lt;br/&gt;.class]\n    B --&gt;|JVM| C[Windows]\n    B --&gt;|JVM| D[macOS]\n    B --&gt;|JVM| E[Linux]\n\n    style B fill:#4CAF50,color:#fff</code></pre>","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#how-it-works","title":"How It Works","text":"<ol> <li>Compile Once: <code>javac</code> compiles <code>.java</code> files to <code>.class</code> bytecode files</li> <li>Bytecode is platform-neutral: Same <code>.class</code> runs everywhere</li> <li>JVM interprets/compiles: Each platform has its own JVM that translates bytecode to native code</li> <li>JIT Compilation: Hot code paths are compiled to native for performance</li> </ol>","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#key-components","title":"Key Components","text":"Component Purpose javac Compiles Java source to bytecode Bytecode Intermediate, platform-independent instruction set JVM Virtual machine that executes bytecode JIT Just-In-Time compiler for performance optimization Class Loader Loads .class files into memory","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#why-this-matters","title":"Why This Matters","text":"<pre><code>// This SAME bytecode runs on any platform with a JVM!\npublic class Hello {\n    public static void main(String[] args) {\n        System.out.println(\"Hello World!\");\n    }\n}\n// Compile on Windows, run on Linux - no changes needed\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#2-stack-vs-heap-memory","title":"2. Stack vs Heap Memory","text":"<p>Understanding where Java stores data is crucial for writing efficient programs.</p> <p></p>","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#stack-memory","title":"Stack Memory","text":"Characteristic Description What's stored Primitives, method call frames, references to heap objects Scope Thread-local (each thread has its own) Lifecycle Created/destroyed with method calls (LIFO) Size Small (typically 512KB - 1MB per thread) Access Very fast (memory addresses are predictable) Error <code>StackOverflowError</code> when full (deep recursion)","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#heap-memory","title":"Heap Memory","text":"Characteristic Description What's stored All objects, arrays, class instances Scope Shared by all threads Lifecycle Objects live until garbage collected Size Large (can be GBs, controlled by <code>-Xmx</code>) Access Slower (dynamic allocation, GC overhead) Error <code>OutOfMemoryError</code> when full","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#visual-example","title":"Visual Example","text":"<pre><code>public class Memory {\n    public static void main(String[] args) {    // Frame created on Stack\n        int count = 10;                         // Primitive \u2192 Stack\n        String name = \"Ahmed\";                  // Reference \u2192 Stack, Object \u2192 Heap\n        Person p = new Person(\"Ali\", 25);       // Reference \u2192 Stack, Object \u2192 Heap\n\n        calculate(count);                       // New frame pushed to Stack\n    }                                           // Frame popped, objects eligible for GC\n\n    static int calculate(int x) {               // New frame on Stack\n        int result = x * 2;                     // Primitive \u2192 Stack (this frame)\n        return result;                          // Frame will be popped\n    }\n}\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#comparison-table","title":"Comparison Table","text":"Aspect Stack Heap Speed  Fast  Slower Size  Small  Large Thread Safety  Thread-private  Needs synchronization Memory Management  Automatic (LIFO)  Garbage Collector Data Primitives + References Objects + Arrays","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#3-pass-by-value-mechanism","title":"3. Pass-by-Value Mechanism","text":"<p>Java is ALWAYS pass-by-value. This is the most misunderstood concept!</p>","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#the-coffee-cup-analogy","title":"The Coffee Cup Analogy","text":"<p>Think of variables as labeled cups and values as what's inside the cups:</p> <pre><code>flowchart LR\n    subgraph \"Primitives\"\n        A[\"Cup 'x'&lt;br/&gt;contains: 5\"] --&gt;|\"Pass to method\"| B[\"New cup 'param'&lt;br/&gt;contains: 5 (copy)\"]\n    end\n\n    subgraph \"Objects\"\n        C[\"Cup 'person'&lt;br/&gt;contains: @123&lt;br/&gt;(address)\"] --&gt;|\"Pass to method\"| D[\"New cup 'param'&lt;br/&gt;contains: @123&lt;br/&gt;(same address!)\"]\n    end\n\n    E[(\"Person Object&lt;br/&gt;at @123\")]\n    C -.-&gt; E\n    D -.-&gt; E</code></pre>","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#for-primitives-copy-of-the-value","title":"For Primitives: Copy of the VALUE","text":"<pre><code>public static void main(String[] args) {\n    int x = 10;\n    modifyPrimitive(x);\n    System.out.println(x);  // Still 10! Original unchanged\n}\n\nstatic void modifyPrimitive(int num) {\n    num = 50;  // Only modifies the local copy\n}\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#for-objects-copy-of-the-reference-not-the-object","title":"For Objects: Copy of the REFERENCE (not the object!)","text":"<pre><code>public static void main(String[] args) {\n    Person p = new Person(\"Ahmed\");\n\n    modifyObject(p);\n    System.out.println(p.name);  // \"Modified\" - object was changed!\n\n    reassignReference(p);\n    System.out.println(p.name);  // Still \"Modified\" - reference wasn't changed!\n}\n\nstatic void modifyObject(Person person) {\n    person.name = \"Modified\";  // \u2705 Modifies the actual object\n}\n\nstatic void reassignReference(Person person) {\n    person = new Person(\"New\");  // \u274c Only reassigns local copy of reference\n}\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#the-golden-rules","title":"The Golden Rules","text":"Rule Explanation Primitive parameters Changes inside method have NO effect outside Object parameters Can modify the object's state Reference reassignment Reassigning the reference has NO effect outside","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#common-misconception","title":"Common Misconception","text":"<pre><code>// \"Java passes objects by reference\" - WRONG!\n// If true, this would work:\n\nstatic void swap(Integer a, Integer b) {\n    Integer temp = a;\n    a = b;       // Only swaps local copies\n    b = temp;    // Original references unchanged!\n}\n\nInteger x = 1, y = 2;\nswap(x, y);\n// x is still 1, y is still 2 - swap failed!\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#common-pitfalls","title":"Common Pitfalls","text":"","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#1-primitive-vs-wrapper-confusion","title":"1. Primitive vs Wrapper Confusion","text":"<pre><code>Integer a = 127;\nInteger b = 127;\nSystem.out.println(a == b);  // true (cached)\n\nInteger c = 128;\nInteger d = 128;\nSystem.out.println(c == d);  // FALSE! (not cached, different objects)\nSystem.out.println(c.equals(d));  // true (correct way)\n</code></pre> <p>Rule: Never use <code>==</code> with boxed primitives (except for null check).</p>","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#2-integer-overflow","title":"2. Integer Overflow","text":"<pre><code>int billion = 1_000_000_000;\nint result = billion * 3;  // OVERFLOW! Result is negative\nlong correct = (long) billion * 3;  // Cast BEFORE multiply\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#3-floating-point-precision","title":"3. Floating-Point Precision","text":"<pre><code>double result = 0.1 + 0.2;\nSystem.out.println(result);  // 0.30000000000000004 !\n\n// For money, use BigDecimal\nBigDecimal precise = new BigDecimal(\"0.1\").add(new BigDecimal(\"0.2\"));\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#best-practices-checklist","title":"Best Practices Checklist","text":"<p>From Effective Java Items 57, 58, 61:</p> <ul> <li> Minimize scope of local variables (declare at first use)</li> <li> Prefer for-each loops when possible</li> <li> Use primitives over boxed types for performance</li> <li> Initialize variables at declaration</li> <li> Keep methods short and focused</li> <li> Never use <code>==</code> on boxed primitives</li> <li> Understand pass-by-value for debugging</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#learning-resources","title":"Learning Resources","text":"","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#platform-independence-jvm","title":"Platform Independence &amp; JVM","text":"<ul> <li>Oracle JVM Specification</li> <li>Jenkov - Java Virtual Machine</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#stack-vs-heap-memory","title":"Stack vs Heap Memory","text":"<ul> <li>DigitalOcean - Heap vs Stack</li> <li>Baeldung - Stack and Heap</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#pass-by-value","title":"Pass-by-Value","text":"<ul> <li>JavaRanch - Cup Size Story \u2b50 Best explanation!</li> <li>Baeldung - Pass by Value</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#related-topics","title":"Related Topics","text":"<ul> <li>OOP &amp; Class Design</li> <li>Arrays, Lists &amp; Generics</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/summary/#references","title":"References","text":"<ul> <li>Course: Tim Buchalka - Java Programming Masterclass</li> <li>Book: Effective Java - Joshua Bloch (Items 57, 58, 61)</li> <li>Spec: JVM Specification</li> <li>Tutorial: Oracle Java Tutorials</li> </ul> <p>Completed: 2026-01-22 | Confidence: 9/10</p>","tags":[]},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/","title":"Topic Note Part 2: Control Flow, Loops &amp; User Input","text":"<p>Course: Java Programming Masterclass - Tim Buchalka (Udemy) Section: 06. Mastering Conditional Logic, Loops, And Interactive Java Applications Status:  Completed</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#learning-objectives","title":"Learning Objectives","text":"<ul> <li> Master the switch statement (traditional + enhanced)</li> <li> Understand the for loop and its three components</li> <li> Implement while and do-while loops for conditional iteration</li> <li> Apply break and continue for loop control</li> <li> Grasp local variables and scope in code blocks</li> <li> Handle exceptions with try-catch</li> <li> Read user input with Scanner class</li> </ul>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#key-concepts-from-the-course","title":"Key Concepts from the Course","text":""},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#the-switch-statement","title":"The Switch Statement","text":"<p>The switch statement provides an alternative to long if-else-if chains when testing a single variable against multiple values.</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#traditional-switch-pre-java-14","title":"Traditional Switch (Pre-Java 14)","text":"<pre><code>int switchValue = 3;\nswitch (switchValue) {\n    case 1:\n        System.out.println(\"Value was 1\");\n        break;\n    case 2:\n        System.out.println(\"Value was 2\");\n        break;\n    case 3:\n    case 4:\n    case 5:\n        System.out.println(\"Was a 3, 4, or 5\");\n        System.out.println(\"Actually it was: \" + switchValue);\n        break;\n    default:\n        System.out.println(\"Was not 1 to 5\");\n        break;\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#key-components","title":"Key Components","text":"Component Purpose <code>switch (value)</code> The variable/expression to test <code>case X:</code> Value to compare against (ends with colon) <code>break;</code> Exit the switch block (prevents fall-through) <code>default:</code> Executes if no case matches (like <code>else</code>)"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#valid-data-types-for-switch","title":"Valid Data Types for Switch","text":"Allowed Not Allowed <code>byte</code>, <code>short</code>, <code>int</code>, <code>char</code> <code>boolean</code> <code>Byte</code>, <code>Short</code>, <code>Integer</code>, <code>Character</code> <code>long</code>, <code>float</code>, <code>double</code> <code>String</code>, <code>enum</code> Their wrapper classes <p>Fall-Through Behavior</p> <p>Without <code>break</code>, execution \"falls through\" to the next case, executing ALL code below until a <code>break</code> or end of switch is reached.</p> <pre><code>// Fall-through example - prints BOTH lines!\ncase 3:\n    System.out.println(\"Was 3\");\n    // No break - falls through!\ncase 4:\n    System.out.println(\"Was 4\");  // This ALSO executes if value is 3!\n    break;\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#enhanced-switch-java-14","title":"Enhanced Switch (Java 14+)","text":"<p>The enhanced switch eliminates common pitfalls and is more concise.</p> <pre><code>// Enhanced switch statement\nswitch (switchValue) {\n    case 1 -&gt; System.out.println(\"Value was 1\");\n    case 2 -&gt; System.out.println(\"Value was 2\");\n    case 3, 4, 5 -&gt; {\n        System.out.println(\"Was a 3, 4, or 5\");\n        System.out.println(\"Actually it was: \" + switchValue);\n    }\n    default -&gt; System.out.println(\"Was not 1 to 5\");\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#key-differences-from-traditional","title":"Key Differences from Traditional","text":"Traditional Enhanced Uses <code>:</code> (colon) Uses <code>-&gt;</code> (arrow) Requires <code>break</code> No <code>break</code> needed Multiple case labels Comma-separated values Fall-through possible Fall-through impossible"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#switch-expressions-returning-values","title":"Switch Expressions (Returning Values)","text":"<p>The enhanced switch can return a value directly!</p> <pre><code>// Switch as an expression - returns a value\npublic static String getQuarter(String month) {\n    return switch (month) {\n        case \"January\", \"February\", \"March\" -&gt; \"1st\";\n        case \"April\", \"May\", \"June\" -&gt; \"2nd\";\n        case \"July\", \"August\", \"September\" -&gt; \"3rd\";\n        case \"October\", \"November\", \"December\" -&gt; \"4th\";\n        default -&gt; month + \" is invalid\";\n    };\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#the-yield-keyword","title":"The <code>yield</code> Keyword","text":"<p>When you need a code block in a switch expression, use <code>yield</code> instead of <code>return</code>:</p> <pre><code>return switch (month) {\n    case \"January\", \"February\", \"March\" -&gt; \"1st\";\n    default -&gt; {\n        String badResponse = month + \" is bad\";\n        yield badResponse;  // NOT return!\n    }\n};\n</code></pre> <p>When to use yield</p> <ul> <li>Switch is used as an expression (returns a value)</li> <li>Case uses a code block <code>{}</code></li> <li>You need to return a value from that block</li> </ul>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#looping-statements","title":"Looping Statements","text":"<p>Java provides three main loop constructs, each suited for different scenarios.</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#the-for-loop","title":"The for Loop","text":"<p>Best when you know the number of iterations in advance.</p> <pre><code>for (initialization; condition; increment) {\n    // code to repeat\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#anatomy-of-a-for-loop","title":"Anatomy of a for Loop","text":"<pre><code>for (int i = 1; i &lt;= 5; i++) {\n    System.out.println(i);\n}\n//   \u2191           \u2191        \u2191\n//   \u2502           \u2502        \u2514\u2500\u2500 Increment (after each iteration)\n//   \u2502           \u2514\u2500\u2500 Condition (checked before each iteration)\n//   \u2514\u2500\u2500 Initialization (runs once at start)\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#practical-example-interest-calculator","title":"Practical Example: Interest Calculator","text":"<pre><code>for (double rate = 2.0; rate &lt;= 5.0; rate++) {\n    double interest = calculateInterest(10000, rate);\n    System.out.println(\"$10,000 at \" + rate + \"% = $\" + interest);\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#loop-variable-naming-convention","title":"Loop Variable Naming Convention","text":"Variable Usage <code>i</code> Standard iteration variable (short for \"iterator\") <code>j</code>, <code>k</code> Nested loops Descriptive names When clarity matters (e.g., <code>rate</code>, <code>counter</code>)"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#the-while-loop","title":"The while Loop","text":"<p>Best when the number of iterations is unknown and depends on a condition.</p> <pre><code>while (condition) {\n    // code to repeat\n    // must update condition to avoid infinite loop!\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#comparison-for-vs-while","title":"Comparison: for vs while","text":"<pre><code>// For loop - initialization inside declaration\nfor (int i = 1; i &lt;= 5; i++) {\n    System.out.println(i);\n}\n\n// While loop - initialization OUTSIDE\nint j = 1;\nwhile (j &lt;= 5) {\n    System.out.println(j);\n    j++;  // Must increment manually!\n}\n</code></pre> <p>Infinite Loop Warning</p> <p>If you forget to update the condition variable in a while loop, you create an infinite loop that never terminates!</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#common-pattern-whiletrue-with-break","title":"Common Pattern: while(true) with break","text":"<pre><code>int j = 1;\nwhile (true) {  // Infinite loop\n    if (j &gt; 5) {\n        break;  // Exit condition tested inside\n    }\n    System.out.println(j);\n    j++;\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#the-do-while-loop","title":"The do-while Loop","text":"<p>Always executes at least once, then checks the condition.</p> <pre><code>do {\n    // code to execute at least once\n} while (condition);  // Note the semicolon!\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#key-difference-from-while","title":"Key Difference from while","text":"<pre><code>boolean isReady = false;\n\n// while loop - never executes\nwhile (isReady) {\n    System.out.println(\"This never runs\");\n}\n\n// do-while loop - executes ONCE\ndo {\n    System.out.println(\"This runs once!\");\n} while (isReady);\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#when-to-use-do-while","title":"When to Use do-while","text":"<ul> <li>User input validation - Ask once, then keep asking if invalid</li> <li>Menu systems - Show menu at least once</li> <li>Retry logic - Attempt operation, retry if failed</li> </ul> <pre><code>// Perfect for input validation\nint yearOfBirth;\ndo {\n    System.out.print(\"Enter year of birth (1900-2024): \");\n    yearOfBirth = scanner.nextInt();\n} while (yearOfBirth &lt; 1900 || yearOfBirth &gt; 2024);\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#loop-control-break-and-continue","title":"Loop Control: break and continue","text":""},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#break-exit-the-loop-entirely","title":"break - Exit the Loop Entirely","text":"<pre><code>for (double i = 7.5; i &lt;= 10; i += 0.25) {\n    double interest = calculateInterest(100, i);\n    if (interest &gt; 8.5) {\n        break;  // Exit loop when interest exceeds $8.50\n    }\n    System.out.println(\"$100 at \" + i + \"% = $\" + interest);\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#continue-skip-to-next-iteration","title":"continue - Skip to Next Iteration","text":"<pre><code>int number = 0;\nwhile (number &lt; 50) {\n    number += 5;\n    if (number % 25 == 0) {\n        continue;  // Skip numbers divisible by 25\n    }\n    System.out.print(number + \" \");\n}\n// Output: 5 10 15 20 30 35 40 45\n// (25 and 50 are skipped!)\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#visual-comparison","title":"Visual Comparison","text":"<pre><code>flowchart TD\n    subgraph \"break\"\n        A[Loop iteration] --&gt; B{Condition?}\n        B --&gt;|break| C[Exit loop completely]\n        B --&gt;|No| D[Continue loop]\n    end</code></pre> <pre><code>flowchart TD\n    subgraph \"continue\"\n        E[Loop iteration] --&gt; F{Condition?}\n        F --&gt;|continue| G[Skip to next iteration]\n        F --&gt;|No| H[Execute remaining code]\n        G --&gt; E\n        H --&gt; E\n    end</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#local-variables-and-scope","title":"Local Variables and Scope","text":""},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#what-is-scope","title":"What is Scope?","text":"<p>Scope defines where a variable can be accessed in your code.</p> <ul> <li>In scope: Variable can be used</li> <li>Out of scope: Variable is not accessible</li> </ul>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#scope-rules","title":"Scope Rules","text":"<ol> <li>Variables are in scope in the block where they're declared</li> <li>Variables are also in scope in any nested (inner) blocks</li> <li>Variables are out of scope in containing (outer) blocks</li> </ol> <pre><code>public void example() {\n    int x = 10;           // x is in scope for entire method\n\n    if (x &gt; 5) {\n        int y = 20;       // y is in scope ONLY inside this if block\n        System.out.println(x);  // \u2705 OK - x is accessible\n        System.out.println(y);  // \u2705 OK - y is accessible\n    }\n\n    System.out.println(x);  // \u2705 OK - x still in scope\n    System.out.println(y);  // \u274c ERROR - y is out of scope!\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#for-loop-variable-scope","title":"For Loop Variable Scope","text":"<p>Variables declared in the for loop initialization are scoped to the loop:</p> <pre><code>for (int i = 0; i &lt; 5; i++) {\n    System.out.println(i);  // \u2705 OK\n}\nSystem.out.println(i);  // \u274c ERROR - i is out of scope\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#switch-statement-scope-special-case","title":"Switch Statement Scope (Special Case!)","text":"<p>Unlike if-else, variables in switch cases are accessible in subsequent cases:</p> <pre><code>switch (value) {\n    case 1:\n        int i = 10;  // Declared here\n        break;\n    case 2:\n        i = 20;      // \u2705 Accessible here (but not recommended!)\n        break;\n    default:\n        i = 30;      // \u2705 Also accessible\n        break;\n}\n// i is OUT of scope here\n</code></pre> <p>Best Practice</p> <p>Declare variables in the narrowest scope possible. If a variable is only needed inside a loop, declare it there.</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#exception-handling-basics","title":"Exception Handling Basics","text":""},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#what-is-an-exception","title":"What is an Exception?","text":"<p>An exception is an error that occurs during program execution. Java has many named exceptions:</p> Exception Cause <code>NullPointerException</code> Calling method on null reference <code>ArrayIndexOutOfBoundsException</code> Accessing invalid array index <code>NumberFormatException</code> Parsing non-numeric string as number <code>ArithmeticException</code> Division by zero"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#the-try-catch-statement","title":"The try-catch Statement","text":"<pre><code>try {\n    // Code that might throw an exception\n    String name = System.console().readLine();\n} catch (NullPointerException e) {\n    // Code to handle the exception\n    System.out.println(\"Console not available!\");\n    // Alternative approach here\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#structure","title":"Structure","text":"<pre><code>try {\n    // risky code\n} catch (ExceptionType variableName) {\n    // handling code\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#reading-user-input","title":"Reading User Input","text":""},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#the-scanner-class","title":"The Scanner Class","text":"<p>Scanner is Java's tool for reading console input. It's part of <code>java.util</code>.</p> <pre><code>import java.util.Scanner;\n\npublic class InputExample {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        System.out.print(\"Enter your name: \");\n        String name = scanner.nextLine();\n\n        System.out.print(\"Enter your year of birth: \");\n        int yearOfBirth = Integer.parseInt(scanner.nextLine());\n\n        int age = 2024 - yearOfBirth;\n        System.out.println(\"Hi \" + name + \", you are \" + age + \" years old!\");\n\n        scanner.close();  // Good practice to close scanner\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#key-scanner-methods","title":"Key Scanner Methods","text":"Method Returns Description <code>nextLine()</code> String Reads entire line <code>next()</code> String Reads next word (until space) <code>nextInt()</code> int Reads an integer <code>nextDouble()</code> double Reads a double <code>hasNextInt()</code> boolean Checks if next input is int"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#creating-a-scanner","title":"Creating a Scanner","text":"<pre><code>// For console input\nScanner scanner = new Scanner(System.in);\n\n// System.in = standard input (keyboard)\n// System.out = standard output (console)\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#input-validation-with-do-while","title":"Input Validation with do-while","text":"<pre><code>Scanner scanner = new Scanner(System.in);\nint yearOfBirth;\n\ndo {\n    System.out.print(\"Enter year of birth (1900-2024): \");\n    yearOfBirth = Integer.parseInt(scanner.nextLine());\n\n    if (yearOfBirth &lt; 1900 || yearOfBirth &gt; 2024) {\n        System.out.println(\"Invalid year! Please try again.\");\n    }\n} while (yearOfBirth &lt; 1900 || yearOfBirth &gt; 2024);\n\nSystem.out.println(\"Valid year entered: \" + yearOfBirth);\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#key-insights-best-practices","title":"Key Insights &amp; Best Practices","text":""},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#switch-statement-insights","title":"Switch Statement Insights","text":"<ol> <li>Use enhanced switch for cleaner, safer code (Java 14+)</li> <li>Include default in switch expressions (required!)</li> <li>Prefer switch over long if-else chains when testing one variable</li> </ol>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#loop-selection-guide","title":"Loop Selection Guide","text":"Scenario Best Loop Known iteration count <code>for</code> Unknown count, condition first <code>while</code> Execute at least once <code>do-while</code> Iterate over collection <code>for-each</code> (later topic)"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#variable-scope-best-practices","title":"Variable Scope Best Practices","text":"<ol> <li>Declare at point of first use - not at method start</li> <li>Use narrowest scope possible - declare in the block where needed</li> <li>Initialize when declaring - avoid uninitialized variables</li> <li>Prefer for-loop init section - keeps loop var scoped to loop</li> </ol>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#quick-reference","title":"Quick Reference","text":""},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#loop-comparison-table","title":"Loop Comparison Table","text":"Feature for while do-while Executes at least once? No No Yes Condition location Declaration Before block After block Initialization In declaration Before loop Before loop Increment In declaration In block In block Semicolon after? No No Yes"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#control-flow-keywords","title":"Control Flow Keywords","text":"Keyword Effect <code>break</code> Exit loop/switch entirely <code>continue</code> Skip to next iteration <code>return</code> Exit method <code>yield</code> Return value from switch expression block"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note-2/#questions-explored","title":"Questions Explored","text":"<ul> <li> What's the difference between traditional and enhanced switch?</li> <li> When does fall-through occur and how to prevent it?</li> <li> How do for, while, and do-while differ?</li> <li> What is variable scope and why does it matter?</li> <li> How to read user input with Scanner?</li> <li> How do labeled break/continue work with nested loops?</li> </ul> <p>Last Updated: 2026-01-24</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/","title":"Topic Note: Syntax, Variables &amp; Control Flow","text":"<p>Course: Java Programming Masterclass - Tim Buchalka (Udemy) Section: 05. Mastering Java Expressions, Statements, Code Blocks, And Method Overloading Status:  Completed</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#learning-objectives","title":"Learning Objectives","text":"<ul> <li> Understand Java keywords and their role in the language</li> <li> Master the difference between expressions and statements</li> <li> Apply whitespace and indentation for readable code</li> <li> Harness code blocks with if-then-else control flow</li> <li> Design reusable methods with parameters and return values</li> <li> Implement method overloading for flexible APIs</li> </ul>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#key-concepts-from-the-course","title":"Key Concepts from the Course","text":""},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#java-keywords","title":"Java Keywords","text":"<p>Java has 51 reserved keywords that form the vocabulary of the language. These cannot be used as identifiers (variable names, class names, method names).</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#key-points","title":"Key Points","text":"<ul> <li>Keywords appear in blue in IntelliJ - this visual cue confirms they're reserved</li> <li>As of Java 9, the underscore (<code>_</code>) by itself is a keyword</li> <li>JDK 17 introduced 16 contextual keywords (only keywords in specific contexts)</li> <li><code>true</code>, <code>false</code>, and <code>null</code> are not technically keywords but literal values - still cannot be used as identifiers</li> </ul> <pre><code>// \u274c Invalid - \"int\" is a reserved keyword\nint int = 5;  // Error: identifier expected\n\n// \u2705 Valid - partial keyword is fine\nint int2 = 5;  // Works because \"int2\" is not a reserved word\n</code></pre> <p>Pro Tip</p> <p>When you get weird \"identifier expected\" errors, check if you're accidentally using a reserved keyword as a name.</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#the-building-blocks-of-java-code","title":"The Building Blocks of Java Code","text":"<p>Java code follows a hierarchical structure from smallest to largest unit:</p> <pre><code>Expression \u2192 Statement \u2192 Code Block \u2192 Method \u2192 Class\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#1-expressions","title":"1. Expressions","text":"<p>An expression is a construct that computes to a single value. It's built using values, variables, and operators.</p> <pre><code>double kilometers = 100 * 1.609344;\n//                  \u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\n//                  This is the expression\n</code></pre> <p>What's NOT part of an expression: - The data type declaration (<code>double</code>) - The semicolon (<code>;</code>)</p> <p>Multiple expressions in one statement:</p> <pre><code>int highScore = 50;\nif (highScore &gt; 25) {           // Expression: highScore &gt; 25\n    highScore = 1000 + highScore;  // Two expressions:\n                                    // 1. 1000 + highScore\n                                    // 2. highScore = 1000 + highScore\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#2-statements","title":"2. Statements","text":"<p>A statement is a complete unit of execution, typically ending with a semicolon.</p> <pre><code>int myVariable = 50;      // Declaration statement\nmyVariable++;              // Expression statement\nSystem.out.println(\"Hi\"); // Method call statement\n</code></pre> <p>Key Insight: The semicolon transforms an expression into a statement.</p> <p>Statements can span multiple lines:</p> <pre><code>System.out.println(\"This is a test \" +\n                   \"and another part \" +\n                   \"still more\");  // All one statement!\n</code></pre> <p>Multiple statements on one line (avoid this):</p> <pre><code>int x = 5; x++; System.out.println(x);  // Technically valid but hard to read\n</code></pre> <p>Best Practice</p> <p>Put one statement per line. Break long statements across lines. This makes code readable and maintainable.</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#3-code-blocks","title":"3. Code Blocks","text":"<p>A code block is a set of statements enclosed in curly braces <code>{}</code>, grouped to achieve a single goal.</p> <pre><code>if (condition) {\n    // This is a code block\n    statement1;\n    statement2;\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#whitespace-indentation","title":"Whitespace &amp; Indentation","text":"<p>Whitespace is any extra horizontal or vertical spacing in your code. Java completely ignores whitespace - it's purely for human readability.</p> <pre><code>// These are identical to Java:\nint x=50;\nint x = 50;\nint    x    =    50;\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#google-java-style-guide-recommendations","title":"Google Java Style Guide Recommendations","text":"Rule Example Spaces around operators <code>x = 5</code> not <code>x=5</code> One statement per line Always Blank lines for logical grouping Between variable groups Consistent indentation Use IDE auto-format <p>IntelliJ Shortcut: <code>Ctrl+Alt+L</code> (Windows/Linux) or <code>Cmd+Option+L</code> (Mac) to auto-format code.</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#control-flow-if-then-else","title":"Control Flow: if-then-else","text":"<p>The <code>if</code> statement is the fundamental decision-making construct in Java.</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#basic-syntax","title":"Basic Syntax","text":"<pre><code>if (condition) {\n    // Code executes when condition is true\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#if-else-either-or","title":"if-else (Either-Or)","text":"<pre><code>if (score &lt; 5000) {\n    System.out.println(\"Score is less than 5000\");\n} else {\n    System.out.println(\"Score is 5000 or more\");\n}\n</code></pre> <p>Guarantee: One of these blocks ALWAYS executes.</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#if-else-if-else-multiple-conditions","title":"if-else-if-else (Multiple Conditions)","text":"<pre><code>if (score &lt; 5000 &amp;&amp; score &gt; 1000) {\n    System.out.println(\"Between 1000 and 5000\");\n} else if (score &lt; 1000) {\n    System.out.println(\"Less than 1000\");\n} else {\n    System.out.println(\"5000 or more\");\n}\n</code></pre> <p>Execution Flow: 1. Check first <code>if</code> condition 2. If false, check <code>else if</code> condition(s) in order 3. If all false, execute <code>else</code> block 4. Once ANY condition is true, skip all remaining checks</p> <p>Best Practice</p> <p>Always use code blocks <code>{}</code> even for single-line conditionals. This prevents bugs when adding more lines later.</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#methods-reusable-code","title":"Methods: Reusable Code","text":"<p>A method declares executable code that can be invoked, passing a fixed number of values as arguments.</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#why-methods","title":"Why Methods?","text":"Problem Solution Code duplication Write once, call many times Maintenance nightmare Change in one place Unreadable main method Logical organization Inflexible code Parameters allow variation"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#method-declaration-anatomy","title":"Method Declaration Anatomy","text":"<pre><code>public static void calculateScore() {\n//\u2502      \u2502      \u2502    \u2514\u2500 Method name (lowerCamelCase)\n//\u2502      \u2502      \u2514\u2500 Return type (void = returns nothing)\n//\u2502      \u2514\u2500 Can be called without creating an object\n//\u2514\u2500 Accessible from anywhere\n\n    // Method body (code block)\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#calling-a-method","title":"Calling a Method","text":"<pre><code>calculateScore();  // Executes the method's code\n</code></pre> <p>What happens: 1. Execution jumps to the method 2. All statements in the method body execute 3. Execution returns to where it left off</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#method-parameters-arguments","title":"Method Parameters &amp; Arguments","text":"<p>Parameters make methods flexible and reusable by accepting input data.</p> <pre><code>public static void calculateScore(boolean gameOver, int score, int levelCompleted, int bonus) {\n//                               \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Parameters (definition) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n    // Can use gameOver, score, levelCompleted, bonus as local variables\n}\n</code></pre> <p>Calling with arguments:</p> <pre><code>calculateScore(true, 800, 5, 100);\n//             \u2514\u2500\u2500 Arguments (actual values passed) \u2500\u2500\u2518\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#parameters-vs-arguments","title":"Parameters vs Arguments","text":"Term Where What Parameter Method declaration Definition (type + name) Argument Method call Actual value passed"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#rules-for-arguments","title":"Rules for Arguments","text":"<ol> <li>Must match number of parameters</li> <li>Must match types of parameters  </li> <li>Must match order of parameters</li> </ol> <pre><code>// Method signature\nvoid process(String name, int age, boolean active)\n\n// \u2705 Valid calls\nprocess(\"Tim\", 30, true);\n\n// \u274c Invalid calls\nprocess(\"Tim\", 30);           // Wrong number\nprocess(30, \"Tim\", true);     // Wrong order/types\nprocess(\"Tim\", \"30\", true);   // Wrong type for age\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#return-values","title":"Return Values","text":"<p>Methods can send data back to the calling code using the <code>return</code> keyword.</p> <pre><code>public static int calculateScore(int score, int bonus) {\n//             \u2514\u2500 Return type (int)\n    int finalScore = score + bonus;\n    return finalScore;  // Sends value back to caller\n//  \u2514\u2500 Required when return type is not void\n}\n</code></pre> <p>Using the returned value:</p> <pre><code>// Option 1: Store in variable\nint result = calculateScore(500, 100);\n\n// Option 2: Use directly in expression\nSystem.out.println(\"Score: \" + calculateScore(500, 100));\n\n// Option 3: Ignore the return (valid but usually pointless)\ncalculateScore(500, 100);  // Value is discarded\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#void-vs-return-type","title":"void vs Return Type","text":"Declaration Return Statement <code>void</code> Optional (implicit return at end) Any data type Required"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#method-overloading","title":"Method Overloading","text":"<p>Method overloading allows multiple methods with the same name but different parameters.</p> <pre><code>public static int calculateScore(String playerName, int score) {\n    System.out.println(\"Player \" + playerName + \" scored \" + score);\n    return score * 1000;\n}\n\npublic static int calculateScore(int score) {  // Overloaded!\n    return calculateScore(\"Anonymous\", score);  // Calls the other version\n}\n\npublic static int calculateScore() {  // Another overload!\n    return 0;\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#method-signature","title":"Method Signature","text":"<p>The signature determines uniqueness:</p> Part of Signature Example Method name <code>calculateScore</code> Parameter types <code>(String, int)</code> Parameter order <code>(int, String)</code> \u2260 <code>(String, int)</code> Number of parameters <code>()</code> \u2260 <code>(int)</code> \u2260 <code>(int, int)</code> <p>NOT part of signature: - Return type - Parameter names</p> <pre><code>// \u2705 Valid overloads\nvoid doSomething(int a)\nvoid doSomething(float a)           // Different type\nvoid doSomething(int a, float b)    // Different count\nvoid doSomething(float b, int a)    // Different order\n\n// \u274c Invalid - same signature\nvoid doSomething(int x)             // Same as first (name doesn't matter)\nint doSomething(int a)              // Same as first (return type doesn't matter)\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#simulating-default-parameters","title":"Simulating Default Parameters","text":"<p>Java doesn't support default parameter values, but overloading provides the same functionality:</p> <pre><code>// Full signature\npublic static int calculateScore(String playerName, int score) {\n    return score * 1000;\n}\n\n// Simplified - uses default for playerName\npublic static int calculateScore(int score) {\n    return calculateScore(\"Anonymous\", score);  // Delegates to full version\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#observed-ideas-insights","title":"Observed Ideas &amp; Insights","text":""},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#the-power-of-abstraction","title":"The Power of Abstraction","text":"<p>Methods fundamentally change how we think about code: - Without methods: Think line by line - With methods: Think in terms of operations and actions</p> <p>This is the first step toward object-oriented thinking.</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#code-duplication-is-evil","title":"Code Duplication is Evil","text":"<p>Duplicated code leads to:</p> <ol> <li>Bugs - Fix in one place, forget another</li> <li>Maintenance Hell - Changes multiply</li> <li>Inconsistency - Different behaviors accidentally</li> </ol> <p>Rule of Thumb: If you copy-paste code more than once, create a method.</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#the-boolean-trap-in-control-flow","title":"The Boolean Trap in Control Flow","text":"<p>Notice how easily bugs creep in with complex conditions:</p> <pre><code>if (score &lt; 5000 &amp;&amp; score &gt; 1000)  // What about score == 5000 or score == 1000?\n</code></pre> <p>Always trace through edge cases mentally.</p>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#code-snippets-examples","title":"Code Snippets &amp; Examples","text":""},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#complete-method-pattern","title":"Complete Method Pattern","text":"<pre><code>public class Main {\n    public static void main(String[] args) {\n        // Variables\n        boolean gameOver = true;\n        int score = 800;\n        int levelCompleted = 5;\n        int bonus = 100;\n\n        // Method call with variables\n        int finalScore = calculateScore(gameOver, score, levelCompleted, bonus);\n        System.out.println(\"Final Score: \" + finalScore);\n\n        // Method call with literals\n        int secondScore = calculateScore(true, 10000, 8, 200);\n        System.out.println(\"Second Score: \" + secondScore);\n    }\n\n    public static int calculateScore(boolean gameOver, int score, \n                                      int levelCompleted, int bonus) {\n        if (gameOver) {\n            int finalScore = score + (levelCompleted * bonus);\n            finalScore += 1000;  // Bonus for completing\n            return finalScore;\n        }\n        return -1;  // Game not over\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#method-overloading-pattern","title":"Method Overloading Pattern","text":"<pre><code>public class Calculator {\n    // Version 1: Full parameters\n    public static int add(int a, int b) {\n        return a + b;\n    }\n\n    // Version 2: Three parameters\n    public static int add(int a, int b, int c) {\n        return a + b + c;\n    }\n\n    // Version 3: Different types\n    public static double add(double a, double b) {\n        return a + b;\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#questions-to-explore","title":"Questions to Explore","text":"<ul> <li> What makes a statement different from an expression?</li> <li> Why can't we use reserved keywords as variable names?</li> <li> How does Java determine which overloaded method to call?</li> <li> What happens if two overloaded methods could both match the arguments?</li> <li> How do varargs interact with method overloading?</li> </ul>"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#quick-reference","title":"Quick Reference","text":"Concept Definition Expression Code that computes to a single value Statement Complete unit of execution (usually ends with <code>;</code>) Code Block Group of statements in <code>{}</code> Method Named, reusable block of code Parameter Variable declared in method signature Argument Value passed to method when called Return Type Data type of value method sends back Method Signature Name + parameter types (determines uniqueness) Overloading Multiple methods, same name, different signatures"},{"location":"notes/phase-1/topic-1-java-basic-Interactive-applications/topic-note/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Expressions compute values; statements execute actions</li> <li>Whitespace is for humans; semicolons are for Java</li> <li>Always use code blocks even for single statements</li> <li>Methods eliminate duplication and improve maintainability</li> <li>Parameters make methods flexible; arguments are the actual data</li> <li>Return values enable two-way communication between caller and method</li> <li>Overloading creates flexible APIs based on signature uniqueness</li> <li>Overloading can simulate default parameters through delegation</li> </ol> <p>Last Updated: 2026-01-22</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/","title":"Topic 2: OOP &amp; Class Design Internals","text":"<p>Mastering object-oriented programming principles and understanding how Java implements them internally.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/#topic-structure","title":"Topic Structure","text":"Document Purpose Status  Topic Note Part 1 Classes, Objects &amp; Encapsulation  Complete  Topic Note Part 2 Inheritance &amp; Method Overriding  Complete  Topic Note Part 3 Strings &amp; StringBuilder  Complete  Topic Note Part 4 Composition  Complete  Topic Note Part 5 Encapsulation (Advanced)  Complete  Topic Note Part 6 Polymorphism  Complete  OOP Challenges Inheritance &amp; OOP Master Challenges  Complete  Book Reading Effective Java insights  Complete  Summary Combined final understanding  Complete"},{"location":"notes/phase-1/topic-2-oop-class-design/#topic-notes-overview","title":"Topic Notes Overview","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/#part-1-classes-objects-encapsulation","title":"Part 1: Classes, Objects &amp; Encapsulation","text":"<p>Covers foundational OOP concepts including class anatomy, access modifiers, getters/setters, constructors (default, parameterized, chaining), references vs objects, static vs instance members, POJOs, and Java Records.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/#part-2-inheritance-method-overriding","title":"Part 2: Inheritance &amp; Method Overriding","text":"<p>Covers the <code>extends</code> keyword, superclass/subclass relationships, the <code>super</code> keyword, constructor chaining across classes, method overriding with <code>@Override</code>, <code>java.lang.Object</code> as the root class, and the differences between overloading vs overriding.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/#part-3-strings-stringbuilder","title":"Part 3: Strings &amp; StringBuilder","text":"<p>Covers Text Blocks (JDK 15+), escape sequences, printf formatting with specifiers, String inspection methods (length, charAt, indexOf), comparison methods (equals, contains), manipulation methods (substring, replace, join), and StringBuilder for mutable string operations.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/#part-4-composition","title":"Part 4: Composition","text":"<p>Covers IS-A vs HAS-A relationships, building composite objects from simpler parts, delegation patterns, real-world composition examples (PersonalComputer, SmartKitchen), and when to prefer composition over inheritance.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/#part-5-encapsulation-advanced","title":"Part 5: Encapsulation (Advanced)","text":"<p>Covers deep dive into encapsulation principles, the three problems of poor encapsulation, data validation in constructors and setters, proper access modifier usage, and the Printer challenge.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/#part-6-polymorphism","title":"Part 6: Polymorphism","text":"<p>Covers compile-time vs runtime types, factory methods, type casting, <code>instanceof</code> operator, pattern matching (JDK 16+), Local Variable Type Inference (<code>var</code>), and the Car challenge demonstrating polymorphic behavior.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/#oop-challenges","title":"OOP Challenges","text":"<p>Two comprehensive challenges: (1) Inheritance Challenge - Worker/Employee hierarchy with SalariedEmployee and HourlyEmployee; (2) OOP Master Challenge - Burger Restaurant application using all OOP principles (composition, inheritance, encapsulation, polymorphism).</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/#what-youll-master","title":"What You'll Master","text":"<ul> <li>Classes &amp; Objects - Instance creation, memory allocation</li> <li>Encapsulation - Access modifiers, information hiding, data validation</li> <li>Inheritance - Class hierarchy, constructor chaining</li> <li>Polymorphism - Runtime dispatch, factory methods, type casting</li> <li>Abstraction - Abstract classes vs interfaces</li> <li>Composition - HAS-A relationships, delegation over inheritance</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/#resources","title":"Resources","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/#primary-course","title":"Primary Course","text":"<ul> <li>Tim Buchalka's Java Masterclass (Udemy)</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/#book-reference","title":"Book Reference","text":"<ul> <li>Effective Java by Joshua Bloch - Chapters 2-4 (Creating &amp; Destroying Objects, Common Methods, Classes &amp; Interfaces)</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/#key-internals-to-understand","title":"Key Internals to Understand","text":"<ul> <li>Method dispatch mechanism (vtable)</li> <li>How polymorphism works at runtime</li> <li>Object creation process (memory allocation, initialization blocks, constructor execution)</li> <li>Interface vs Abstract class performance considerations</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/#progress-tracker","title":"Progress Tracker","text":"<ul> <li> Complete Tim's course sections on OOP (Section 07-08)</li> <li> Read Effective Java Chapters 2-4</li> <li> Write topic notes (Part 1-6)</li> <li> Complete challenges documentation</li> <li> Complete book reading notes</li> <li> Synthesize final summary</li> <li> Implement OOP-focused mini-project</li> </ul> <p>Start Date: 2026-01-25 | Completed: 2026-01-26</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/","title":"Book Reading: OOP &amp; Class Design Internals","text":"<p>Book: Effective Java by Joshua Bloch (3<sup>rd</sup> Edition) Relevant Chapters: 2-4 (Creating &amp; Destroying Objects, Common Methods, Classes &amp; Interfaces) Status:  Complete</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#reading-goals","title":"Reading Goals","text":"<ul> <li> Understand best practices for object creation</li> <li> Learn common method contracts (equals, hashCode, toString)</li> <li> Master class and interface design principles</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#chapter-2-creating-and-destroying-objects","title":"Chapter 2: Creating and Destroying Objects","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#item-1-consider-static-factory-methods-instead-of-constructors","title":"Item 1: Consider Static Factory Methods Instead of Constructors","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#key-takeaways","title":"Key Takeaways","text":"<p>A static factory method is a static method that returns an instance of the class. Unlike constructors, these methods have names, can return cached instances, and can return subtypes.</p> <pre><code>// Constructor approach (limited)\nBigInteger prime = new BigInteger(100, 10, new Random());\n\n// Static factory approach (clearer intent)\nBigInteger prime = BigInteger.probablePrime(100, new Random());\n</code></pre> <p>Named Creation Methods</p> <p>Static factory methods like <code>probablePrime()</code> immediately tell you what kind of object you're getting, unlike a constructor that only shows parameter types.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#advantages-over-constructors","title":"Advantages Over Constructors","text":"<pre><code>flowchart LR\n    subgraph advantages[\" STATIC FACTORY ADVANTAGES \"]\n        A1[1. Have descriptive names]\n        A2[2. Not required to create new object]\n        A3[3. Can return any subtype]\n        A4[4. Returned class can vary by input]\n        A5[5. Class need not exist when writing method]\n    end</code></pre> <p>1. They have names</p> <pre><code>// Which constructor creates a probable prime? Not obvious!\nBigInteger(int, int, Random)\n\n// Static factory - crystal clear intent\nBigInteger.probablePrime(int, Random)\n</code></pre> <p>2. Not required to create a new object each time</p> <pre><code>// Boolean.valueOf() returns cached TRUE or FALSE instances\n// Never creates new Boolean objects!\npublic static Boolean valueOf(boolean b) {\n    return b ? Boolean.TRUE : Boolean.FALSE;\n}\n</code></pre> <p>This enables instance-controlled classes: - Singletons (only one instance exists) - Noninstantiable classes (no instances exist) - Flyweight pattern (reuse immutable instances)</p> <p>3. Can return any subtype of the return type</p> <pre><code>// Returns different implementations based on size!\npublic static &lt;E extends Enum&lt;E&gt;&gt; EnumSet&lt;E&gt; noneOf(Class&lt;E&gt; elementType) {\n    if (elementType.getEnumConstants().length &lt;= 64)\n        return new RegularEnumSet&lt;&gt;(elementType);  // Small set\n    else\n        return new JumboEnumSet&lt;&gt;(elementType);    // Large set\n}\n</code></pre> <p>The caller only knows about <code>EnumSet</code> - the implementation is hidden!</p> <p>4. Returned class can vary based on input parameters</p> <pre><code>// Same factory, different return types based on input\nEnumSet&lt;Color&gt; colors = EnumSet.of(Color.RED, Color.BLUE);\n// Returns RegularEnumSet or JumboEnumSet - client doesn't care!\n</code></pre> <p>5. Class of returned object need not exist when writing the method</p> <p>This enables service provider frameworks like JDBC: <pre><code>// The PostgreSQL driver doesn't exist when writing this API\nConnection conn = DriverManager.getConnection(url);\n// Driver loaded at runtime!\n</code></pre></p>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#disadvantages","title":"Disadvantages","text":"Disadvantage Mitigation Classes without public constructors cannot be subclassed Use composition over inheritance (Item 18) Hard to find in API documentation Follow naming conventions"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#common-naming-conventions","title":"Common Naming Conventions","text":"Name Purpose Example <code>from</code> Type conversion <code>Date.from(instant)</code> <code>of</code> Aggregation <code>EnumSet.of(RED, BLUE)</code> <code>valueOf</code> Same value, maybe cached <code>Integer.valueOf(42)</code> <code>getInstance</code> Return instance (maybe cached) <code>StackWalker.getInstance()</code> <code>newInstance</code> Always new instance <code>Array.newInstance(...)</code> <code>getType</code> Factory in different class <code>Files.getFileStore(path)</code> <code>newType</code> New instance from different class <code>Files.newBufferedReader(...)</code>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#item-2-consider-a-builder-when-faced-with-many-constructor-parameters","title":"Item 2: Consider a Builder When Faced with Many Constructor Parameters","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#key-takeaways_1","title":"Key Takeaways","text":"<p>When a class has many constructor parameters (especially optional ones), the Builder pattern provides readable, flexible object creation.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#the-problem-telescoping-constructors","title":"The Problem: Telescoping Constructors","text":"<pre><code>// \u274c BAD: Hard to read, easy to swap parameters!\npublic class NutritionFacts {\n    public NutritionFacts(int servingSize, int servings) { ... }\n    public NutritionFacts(int servingSize, int servings, int calories) { ... }\n    public NutritionFacts(int servingSize, int servings, int calories, int fat) { ... }\n    public NutritionFacts(int servingSize, int servings, int calories, int fat, \n                          int sodium, int carbohydrate) { ... }\n}\n\n// Easy mistake: Did I pass calories or fat first?\nNutritionFacts facts = new NutritionFacts(240, 8, 100, 0, 35, 27);\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#the-problem-javabeans-pattern","title":"The Problem: JavaBeans Pattern","text":"<pre><code>// \u274c BAD: Object in inconsistent state during construction!\nNutritionFacts facts = new NutritionFacts();\nfacts.setServingSize(240);  // Object is incomplete here!\nfacts.setServings(8);\nfacts.setCalories(100);     // Still being built...\nfacts.setSodium(35);\n// Object is now mutable forever\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#the-solution-builder-pattern","title":"The Solution: Builder Pattern","text":"<pre><code>// \u2705 GOOD: Readable, immutable, and safe!\npublic class NutritionFacts {\n    private final int servingSize;\n    private final int servings;\n    private final int calories;\n    private final int fat;\n    private final int sodium;\n    private final int carbohydrate;\n\n    public static class Builder {\n        // Required parameters\n        private final int servingSize;\n        private final int servings;\n\n        // Optional parameters - initialized to default values\n        private int calories      = 0;\n        private int fat           = 0;\n        private int sodium        = 0;\n        private int carbohydrate  = 0;\n\n        public Builder(int servingSize, int servings) {\n            this.servingSize = servingSize;\n            this.servings    = servings;\n        }\n\n        public Builder calories(int val) {\n            calories = val;\n            return this;  // Return this for method chaining\n        }\n\n        public Builder fat(int val) {\n            fat = val;\n            return this;\n        }\n\n        public Builder sodium(int val) {\n            sodium = val;\n            return this;\n        }\n\n        public Builder carbohydrate(int val) {\n            carbohydrate = val;\n            return this;\n        }\n\n        public NutritionFacts build() {\n            return new NutritionFacts(this);\n        }\n    }\n\n    private NutritionFacts(Builder builder) {\n        servingSize  = builder.servingSize;\n        servings     = builder.servings;\n        calories     = builder.calories;\n        fat          = builder.fat;\n        sodium       = builder.sodium;\n        carbohydrate = builder.carbohydrate;\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#using-the-builder","title":"Using the Builder","text":"<pre><code>// Fluent, readable, self-documenting!\nNutritionFacts cocaCola = new NutritionFacts.Builder(240, 8)\n        .calories(100)\n        .sodium(35)\n        .carbohydrate(27)\n        .build();\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#when-to-use","title":"When to Use","text":"<pre><code>flowchart TD\n    A[How many constructor parameters?] --&gt; B{4 or more?}\n    B --&gt;|Yes| C[Use Builder Pattern]\n    B --&gt;|No| D{Will grow in future?}\n    D --&gt;|Yes| C\n    D --&gt;|No| E[Constructor is fine]\n    C --&gt; F[Benefits: Readable, Immutable, Safe]</code></pre> <p>Cost of Builder</p> <p>Creating a Builder object has a small performance cost. For performance-critical code with few parameters, constructors may be better.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#item-3-enforce-the-singleton-property-with-a-private-constructor-or-an-enum-type","title":"Item 3: Enforce the Singleton Property with a Private Constructor or an Enum Type","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#key-takeaways_2","title":"Key Takeaways","text":"<p>A singleton is a class instantiated exactly once. There are three approaches, with enum being preferred.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#approach-1-public-static-final-field","title":"Approach 1: Public Static Final Field","text":"<pre><code>public class Elvis {\n    public static final Elvis INSTANCE = new Elvis();\n\n    private Elvis() { }  // Private constructor\n\n    public void leaveTheBuilding() { ... }\n}\n\n// Usage\nElvis.INSTANCE.leaveTheBuilding();\n</code></pre> <p>Problem: Reflection attacks can break this! <pre><code>Constructor&lt;Elvis&gt; c = Elvis.class.getDeclaredConstructor();\nc.setAccessible(true);\nElvis imposter = c.newInstance();  // Second instance created!\n</code></pre></p>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#approach-2-static-factory-method","title":"Approach 2: Static Factory Method","text":"<pre><code>public class Elvis {\n    private static final Elvis INSTANCE = new Elvis();\n\n    private Elvis() { }\n\n    public static Elvis getInstance() { return INSTANCE; }\n\n    public void leaveTheBuilding() { ... }\n}\n</code></pre> <p>Advantage: Flexibility to change singleton behavior later without API changes.</p> <p>Problem: Still vulnerable to reflection and serialization issues.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#approach-3-enum-type-recommended","title":"Approach 3: Enum Type (RECOMMENDED)","text":"<pre><code>public enum Elvis {\n    INSTANCE;\n\n    public void leaveTheBuilding() { ... }\n}\n\n// Usage\nElvis.INSTANCE.leaveTheBuilding();\n</code></pre> <pre><code>flowchart LR\n    subgraph enum[\" ENUM SINGLETON \"]\n        E1[Serialization-safe]\n        E2[Reflection-proof]\n        E3[Thread-safe]\n        E4[Most concise]\n    end</code></pre> <p>Why Enum is Best</p> <ul> <li>Serialization: Automatically handled correctly</li> <li>Reflection: Cannot create additional instances</li> <li>Thread safety: Guaranteed by JVM</li> <li>Simplicity: Single line declaration</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#item-7-eliminate-obsolete-object-references","title":"Item 7: Eliminate Obsolete Object References","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#key-takeaways_3","title":"Key Takeaways","text":"<p>Memory leaks in Java happen when you unintentionally hold references to objects you no longer need. The garbage collector cannot reclaim objects that are still reachable.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#the-classic-example-stack-implementation","title":"The Classic Example: Stack Implementation","text":"<pre><code>// \u274c MEMORY LEAK: Stack holds obsolete references\npublic class Stack {\n    private Object[] elements;\n    private int size = 0;\n\n    public Object pop() {\n        if (size == 0)\n            throw new EmptyStackException();\n        return elements[--size];  // BUG: Old reference still exists!\n    }\n}\n</code></pre> <p>Even after popping, <code>elements[size]</code> still points to the old object!</p> <pre><code>flowchart TD\n    subgraph stack[\" Stack Array \"]\n        E0[elements 0 ]\n        E1[elements 1 ]\n        E2[elements 2 \u2190 still referenced!]\n        E3[elements 3 \u2190 still referenced!]\n    end\n    S[size = 2]\n\n    E2 -.obsolete.-&gt; OBJ1[Old Object 1]\n    E3 -.obsolete.-&gt; OBJ2[Old Object 2]\n\n    style OBJ1 fill:#ff9999\n    style OBJ2 fill:#ff9999</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#the-fix-null-out-obsolete-references","title":"The Fix: Null Out Obsolete References","text":"<pre><code>// \u2705 CORRECT: Null out obsolete references\npublic Object pop() {\n    if (size == 0)\n        throw new EmptyStackException();\n    Object result = elements[--size];\n    elements[size] = null;  // Eliminate obsolete reference!\n    return result;\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#common-sources-of-memory-leaks","title":"Common Sources of Memory Leaks","text":"Source Description Solution Self-managed memory Classes with arrays/collections Null out unused entries Caches Objects cached but never removed Use <code>WeakHashMap</code> or bounded cache Listeners/Callbacks Registered but never unregistered Use weak references or explicit deregister <p>Don't Overdo It</p> <p>Nulling out references should be the exception, not the norm. The best way to eliminate obsolete references is to let variables fall out of scope naturally.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#chapter-3-methods-common-to-all-objects","title":"Chapter 3: Methods Common to All Objects","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#item-10-obey-the-general-contract-when-overriding-equals","title":"Item 10: Obey the General Contract When Overriding equals","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#the-contract","title":"The Contract","text":"<p>When you override <code>equals()</code>, you must follow these rules:</p> <pre><code>flowchart TD\n    subgraph contract[\" equals() CONTRACT \"]\n        R[Reflexive: x.equals x = true]\n        S[Symmetric: x.equals y \u2194 y.equals x]\n        T[Transitive: x=y, y=z \u2192 x=z]\n        C[Consistent: Multiple calls, same result]\n        N[Non-null: x.equals null = false]\n    end</code></pre> Property Meaning Example Violation Reflexive <code>x.equals(x)</code> always true Object doesn't equal itself Symmetric If <code>x.equals(y)</code>, then <code>y.equals(x)</code> Case-insensitive string vs String Transitive If <code>x=y</code> and <code>y=z</code>, then <code>x=z</code> Point extended with Color Consistent Multiple calls return same result Depends on mutable external data Non-null <code>x.equals(null)</code> always false NullPointerException"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#classic-symmetry-violation","title":"Classic Symmetry Violation","text":"<pre><code>// \u274c BROKEN: Violates symmetry\npublic final class CaseInsensitiveString {\n    private final String s;\n\n    @Override\n    public boolean equals(Object o) {\n        if (o instanceof CaseInsensitiveString)\n            return s.equalsIgnoreCase(((CaseInsensitiveString) o).s);\n        if (o instanceof String)  // Interoperates with String!\n            return s.equalsIgnoreCase((String) o);\n        return false;\n    }\n}\n\nCaseInsensitiveString cis = new CaseInsensitiveString(\"Polish\");\nString s = \"polish\";\n\ncis.equals(s);  // true\ns.equals(cis);  // false \u2190 SYMMETRY BROKEN!\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#correct-equals-implementation","title":"Correct equals() Implementation","text":"<pre><code>// \u2705 CORRECT: Follows all contract rules\n@Override\npublic boolean equals(Object o) {\n    // 1. Check for identity (reflexive + optimization)\n    if (o == this)\n        return true;\n\n    // 2. Check for correct type (also handles null)\n    if (!(o instanceof PhoneNumber))\n        return false;\n\n    // 3. Cast and compare significant fields\n    PhoneNumber pn = (PhoneNumber) o;\n    return pn.lineNum == lineNum &amp;&amp;\n           pn.prefix  == prefix &amp;&amp;\n           pn.areaCode == areaCode;\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#recipe-for-high-quality-equals","title":"Recipe for High-Quality equals()","text":"<ol> <li>Use <code>==</code> to check if argument is reference to <code>this</code></li> <li>Use <code>instanceof</code> to check for correct type</li> <li>Cast to correct type</li> <li>Compare all significant fields</li> <li>Ask yourself: Is it symmetric? Transitive? Consistent?</li> </ol>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#item-11-always-override-hashcode-when-you-override-equals","title":"Item 11: Always Override hashCode When You Override equals","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#key-takeaways_4","title":"Key Takeaways","text":"<p>If you override <code>equals()</code>, you MUST override <code>hashCode()</code>. Violating this breaks hash-based collections.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#the-hashcode-contract","title":"The hashCode Contract","text":"<pre><code>// If x.equals(y), then x.hashCode() == y.hashCode() MUST be true!\n</code></pre> Rule Description Consistent Same object, same hashCode (unless equals fields change) Equal objects Equal objects MUST have equal hash codes Unequal objects Unequal objects SHOULD have different hash codes (for performance)"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#what-happens-if-you-violate-this","title":"What Happens If You Violate This","text":"<pre><code>// \u274c BROKEN: equals() overridden, hashCode() NOT overridden\nMap&lt;PhoneNumber, String&gt; map = new HashMap&lt;&gt;();\nmap.put(new PhoneNumber(707, 867, 5309), \"Jenny\");\n\n// Different instance, but equals() returns true!\nmap.get(new PhoneNumber(707, 867, 5309));  // Returns null! WHY?\n</code></pre> <pre><code>flowchart LR\n    P1[PhoneNumber 1&lt;br&gt;hashCode: 123] --&gt; B1[Bucket 123]\n    P2[PhoneNumber 2&lt;br&gt;hashCode: 456] --&gt; B2[Bucket 456]\n    B1 -.contains.-&gt; Jenny\n    B2 -.empty.-&gt; X[Not found!]\n\n    style P2 fill:#ff9999\n    style X fill:#ff9999</code></pre> <p>Even though the phone numbers are <code>equals()</code>, they go to different buckets because of different hash codes!</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#correct-hashcode-implementation","title":"Correct hashCode Implementation","text":"<pre><code>// \u2705 CORRECT: Consistent with equals()\n@Override\npublic int hashCode() {\n    int result = Short.hashCode(areaCode);\n    result = 31 * result + Short.hashCode(prefix);\n    result = 31 * result + Short.hashCode(lineNum);\n    return result;\n}\n\n// Or simpler (slightly slower):\n@Override\npublic int hashCode() {\n    return Objects.hash(areaCode, prefix, lineNum);\n}\n</code></pre> <p>Why 31?</p> <p>31 is an odd prime. If it were even and multiplication overflowed, information would be lost. Using a prime results in better hash distribution.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#item-12-always-override-tostring","title":"Item 12: Always Override toString","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#key-takeaways_5","title":"Key Takeaways","text":"<p>Override <code>toString()</code> to provide a useful, human-readable representation of your object.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#default-tostring-is-useless","title":"Default toString is Useless","text":"<pre><code>// Default: ClassName@hexHashCode\nSystem.out.println(new PhoneNumber(707, 867, 5309));\n// Output: PhoneNumber@1a2b3c4d  \u2190 USELESS!\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#good-tostring-is-invaluable","title":"Good toString is Invaluable","text":"<pre><code>@Override\npublic String toString() {\n    return String.format(\"(%03d) %03d-%04d\", areaCode, prefix, lineNum);\n}\n\n// Now:\nSystem.out.println(new PhoneNumber(707, 867, 5309));\n// Output: (707) 867-5309  \u2190 USEFUL!\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#benefits","title":"Benefits","text":"Benefit Description Debugging Meaningful output in logs and debugger Logging Informative diagnostic messages Collections Maps and lists print their contents clearly Error messages \"Failed to connect: (707) 867-5309\""},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#best-practices","title":"Best Practices","text":"<ol> <li>Include all interesting information (key fields that identify the object)</li> <li>Document the format if it's intended for parsing</li> <li>Provide programmatic access to all fields in toString (getters)</li> <li>Use StringBuilder for efficiency when building complex strings</li> </ol>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#chapter-4-classes-and-interfaces","title":"Chapter 4: Classes and Interfaces","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#item-15-minimize-the-accessibility-of-classes-and-members","title":"Item 15: Minimize the Accessibility of Classes and Members","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#key-takeaways_6","title":"Key Takeaways","text":"<p>Information hiding (encapsulation) is fundamental to good software design. Make every class and member as inaccessible as possible.</p> <pre><code>flowchart TD\n    subgraph benefits[\" INFORMATION HIDING BENEFITS \"]\n        D[Decoupling components]\n        M[Easier maintenance]\n        P[Parallel development]\n        O[Independent optimization]\n        U[Improved understanding]\n    end</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#access-levels-for-members","title":"Access Levels for Members","text":"Modifier Same Class Same Package Subclass World <code>private</code> \u2705 \u274c \u274c \u274c (package-private) \u2705 \u2705 \u274c \u274c <code>protected</code> \u2705 \u2705 \u2705 \u274c <code>public</code> \u2705 \u2705 \u2705 \u2705"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#rules-to-follow","title":"Rules to Follow","text":"<ol> <li>Start with private - Only relax if necessary</li> <li>Package-private for testing - OK to expose for testing within package</li> <li>Think twice about protected - Part of your public API!</li> <li>Never public for mutable fields</li> <li>Beware of public static final arrays</li> </ol> <pre><code>// \u274c BROKEN: Array contents can be modified!\npublic static final Thing[] VALUES = { ... };\n\n// \u2705 FIX 1: Unmodifiable list\nprivate static final Thing[] PRIVATE_VALUES = { ... };\npublic static final List&lt;Thing&gt; VALUES = \n    Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));\n\n// \u2705 FIX 2: Clone the array\npublic static final Thing[] values() {\n    return PRIVATE_VALUES.clone();\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#item-17-minimize-mutability","title":"Item 17: Minimize Mutability","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#key-takeaways_7","title":"Key Takeaways","text":"<p>Immutable classes are simpler, safer, and more flexible than mutable classes. Make classes immutable unless there's a good reason not to.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#rules-for-immutable-classes","title":"Rules for Immutable Classes","text":"<pre><code>flowchart TD\n    subgraph rules[\" 5 RULES FOR IMMUTABILITY \"]\n        R1[1. No mutator methods]\n        R2[2. Class cannot be extended]\n        R3[3. All fields are final]\n        R4[4. All fields are private]\n        R5[5. Exclusive access to mutable components]\n    end</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#example-immutable-complex-number","title":"Example: Immutable Complex Number","text":"<pre><code>public final class Complex {\n    private final double re;\n    private final double im;\n\n    public Complex(double re, double im) {\n        this.re = re;\n        this.im = im;\n    }\n\n    public double realPart()      { return re; }\n    public double imaginaryPart() { return im; }\n\n    // Return new instance instead of modifying!\n    public Complex plus(Complex c) {\n        return new Complex(re + c.re, im + c.im);\n    }\n\n    public Complex minus(Complex c) {\n        return new Complex(re - c.re, im - c.im);\n    }\n\n    // ...etc\n}\n</code></pre> <p>Functional Approach</p> <p>Methods like <code>plus()</code> and <code>minus()</code> return new instances rather than modifying <code>this</code>. This is called a functional approach.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#benefits-of-immutability","title":"Benefits of Immutability","text":"Benefit Why? Simple Object has exactly one state ever Thread-safe No synchronization needed Freely shareable Can cache and reuse instances Share internals No defensive copying needed Great map keys Hash code never changes Failure atomicity Never in inconsistent state"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#disadvantage-performance","title":"Disadvantage: Performance","text":"<pre><code>// Creating many intermediate objects can be costly\nBigInteger moby = new BigInteger(\"111...1\");  // 1 million 1s\nmoby = moby.flipBit(0);  // Creates entire new million-bit BigInteger!\n</code></pre> <p>Solution: Provide mutable companion class (e.g., <code>StringBuilder</code> for <code>String</code>).</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#item-18-favor-composition-over-inheritance","title":"Item 18: Favor Composition Over Inheritance","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#key-takeaways_8","title":"Key Takeaways","text":"<p>Implementation inheritance (extending a class) is powerful but dangerous. Prefer composition (having a reference to another class).</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#the-problem-with-inheritance","title":"The Problem with Inheritance","text":"<pre><code>flowchart TD\n    P[Parent Class] --&gt; C[Child Class]\n    P -.changes.-&gt; BREAK[Breaks Child!]\n\n    style BREAK fill:#ff9999</code></pre> <p>The Fragile Base Class Problem: Changes to the parent class can break subclasses, even if the subclass code hasn't changed.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#classic-example-instrumentedhashset","title":"Classic Example: InstrumentedHashSet","text":"<pre><code>// \u274c BROKEN: Inheritance gone wrong\npublic class InstrumentedHashSet&lt;E&gt; extends HashSet&lt;E&gt; {\n    private int addCount = 0;\n\n    @Override\n    public boolean add(E e) {\n        addCount++;\n        return super.add(e);\n    }\n\n    @Override\n    public boolean addAll(Collection&lt;? extends E&gt; c) {\n        addCount += c.size();\n        return super.addAll(c);  // PROBLEM!\n    }\n\n    public int getAddCount() { return addCount; }\n}\n\nInstrumentedHashSet&lt;String&gt; s = new InstrumentedHashSet&lt;&gt;();\ns.addAll(List.of(\"Snap\", \"Crackle\", \"Pop\"));\ns.getAddCount();  // Returns 6, not 3! WHY?\n</code></pre> <p>Why? <code>HashSet.addAll()</code> internally calls <code>add()</code> for each element. So we count each element twice!</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#the-solution-composition-forwarding-wrapper-class","title":"The Solution: Composition + Forwarding (Wrapper Class)","text":"<pre><code>// \u2705 CORRECT: Composition approach\npublic class InstrumentedSet&lt;E&gt; extends ForwardingSet&lt;E&gt; {\n    private int addCount = 0;\n\n    public InstrumentedSet(Set&lt;E&gt; s) {\n        super(s);  // Wrap the set\n    }\n\n    @Override\n    public boolean add(E e) {\n        addCount++;\n        return super.add(e);\n    }\n\n    @Override\n    public boolean addAll(Collection&lt;? extends E&gt; c) {\n        addCount += c.size();\n        return super.addAll(c);\n    }\n\n    public int getAddCount() { return addCount; }\n}\n\n// Forwarding class (reusable)\npublic class ForwardingSet&lt;E&gt; implements Set&lt;E&gt; {\n    private final Set&lt;E&gt; s;\n    public ForwardingSet(Set&lt;E&gt; s) { this.s = s; }\n\n    // Forward all Set methods to wrapped set\n    public boolean add(E e)     { return s.add(e); }\n    public boolean addAll(Collection&lt;? extends E&gt; c) { return s.addAll(c); }\n    // ... all other Set methods\n}\n</code></pre> <pre><code>flowchart LR\n    subgraph wrapper[\" WRAPPER PATTERN \"]\n        IS[InstrumentedSet] --&gt; FS[ForwardingSet]\n        FS --&gt; HS[HashSet]\n    end\n\n    IS -.decorates.-&gt; HS</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#when-to-use-inheritance-vs-composition","title":"When to Use Inheritance vs Composition","text":"Question If Yes \u2192 Is there a true IS-A relationship? Consider inheritance Will subclass use ALL parent functionality? Consider inheritance Is parent designed for inheritance? Consider inheritance Everything else Use Composition"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#item-20-prefer-interfaces-to-abstract-classes","title":"Item 20: Prefer Interfaces to Abstract Classes","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#key-takeaways_9","title":"Key Takeaways","text":"<p>Java's single inheritance of implementation limits abstract classes. Prefer interfaces for defining types, but combine with skeletal implementations for convenience.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#why-interfaces-win","title":"Why Interfaces Win","text":"Feature Interface Abstract Class Multiple inheritance of type \u2705 \u274c No hierarchy constraints \u2705 \u274c Mixins (adding functionality) \u2705 \u274c Default methods (Java 8+) \u2705 \u2705 Can contain state \u274c \u2705"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#the-skeletal-implementation-pattern","title":"The Skeletal Implementation Pattern","text":"<p>Combine benefits of both: interface + abstract skeletal class.</p> <pre><code>// 1. THE INTERFACE - defines the type\npublic interface Vending {\n    void insertCoin();\n    void pressButton();\n    void refund();\n}\n\n// 2. THE SKELETAL IMPLEMENTATION - provides common implementation\npublic abstract class AbstractVending implements Vending {\n    @Override\n    public void refund() {\n        // Common implementation for all vending machines\n        System.out.println(\"Refunding coins...\");\n    }\n\n    // insertCoin and pressButton remain abstract\n}\n\n// 3. CONCRETE CLASSES - extend skeletal for convenience\npublic class DrinkVending extends AbstractVending {\n    @Override\n    public void insertCoin() { /* drink-specific */ }\n\n    @Override  \n    public void pressButton() { /* dispense drink */ }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#naming-convention","title":"Naming Convention","text":"<p>Skeletal implementations are named <code>Abstract&lt;Interface&gt;</code>:</p> <ul> <li><code>AbstractCollection</code> for <code>Collection</code></li> <li><code>AbstractList</code> for <code>List</code></li> <li><code>AbstractSet</code> for <code>Set</code></li> <li><code>AbstractMap</code> for <code>Map</code></li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#theoretical-framework","title":"Theoretical Framework","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#mental-model-for-object-design","title":"Mental Model for Object Design","text":"<pre><code>flowchart TD\n    subgraph creation[\" OBJECT CREATION \"]\n        SF[Static Factories &gt; Constructors]\n        B[Builder for many params]\n        S[Enum for Singletons]\n    end\n\n    subgraph methods[\" COMMON METHODS \"]\n        E[equals: Follow contract]\n        H[hashCode: Always with equals]\n        T[toString: Make it useful]\n    end\n\n    subgraph design[\" CLASS DESIGN \"]\n        A[Minimize accessibility]\n        I[Favor immutability]\n        C[Composition &gt; Inheritance]\n        INT[Interfaces &gt; Abstract classes]\n    end\n\n    creation --&gt; methods --&gt; design</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#solid-principles-connection","title":"SOLID Principles Connection","text":"Principle Effective Java Connection **S**ingle Responsibility Item 15: Minimize accessibility keeps classes focused **O**pen/Closed Item 20: Interfaces allow extension without modification **L**iskov Substitution Item 10: Proper equals() ensures substitutability **I**nterface Segregation Item 20: Prefer focused interfaces **D**ependency Inversion Item 18: Composition allows dependency injection"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#reflections-connections","title":"Reflections &amp; Connections","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#connections-to-course-material","title":"Connections to Course Material","text":"Effective Java Tim's Course Static Factories (Item 1) Factory methods in Polymorphism section Builder Pattern (Item 2) Constructor overloading Singleton (Item 3) Static members discussion equals/hashCode (10-11) Object class methods Composition (Item 18) Section 08: Composition chapter Information Hiding (Item 15) Encapsulation section"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#new-perspectives-gained","title":"New Perspectives Gained","text":"<ol> <li>Static factory methods are underused - many classes should offer them alongside or instead of constructors</li> <li>Builder pattern is essential for any class with 4+ parameters</li> <li>Enum singletons are the only truly safe way to implement singletons</li> <li>Immutability should be the default - only make classes mutable when necessary</li> <li>Composition solves most problems inheritance creates</li> </ol>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#summary-points","title":"Summary Points","text":"<ol> <li>Object Creation: Use static factories for flexibility, builders for many parameters, enums for singletons</li> <li>Common Methods: Always override hashCode with equals, make toString useful</li> <li>Accessibility: Make everything as private as possible</li> <li>Mutability: Prefer immutable classes for simplicity and thread-safety</li> <li>Inheritance: Favor composition over implementation inheritance</li> <li>Interfaces: Prefer interfaces to abstract classes, combine with skeletal implementations</li> </ol>"},{"location":"notes/phase-1/topic-2-oop-class-design/book-reading/#bookmarks-page-references","title":"Bookmarks &amp; Page References","text":"Topic Item Key Insight Static Factories Item 1 Named, cacheable, can return subtypes Builder Pattern Item 2 Fluent API for complex object creation Singleton Item 3 Enum is the most robust approach Obsolete References Item 7 Null out only when managing own memory equals Contract Item 10 Reflexive, Symmetric, Transitive, Consistent, Non-null hashCode with equals Item 11 Equal objects MUST have equal hash codes toString Item 12 Include all interesting information Minimize Accessibility Item 15 Start with private, relax only if necessary Minimize Mutability Item 17 Five rules for immutable classes Composition over Inheritance Item 18 Wrapper class pattern Interfaces over Abstract Classes Item 20 Skeletal implementation pattern <p>Last Updated: 2026-01-26</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/summary/","title":"Summary: OOP &amp; Class Design Internals","text":"<p>Combined Knowledge from: Tim Buchalka's Course + Effective Java Mastery Level: </p>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#topic-overview","title":"Topic Overview","text":"<p>A deep understanding of object-oriented programming principles, their implementation in Java, and best practices for designing robust, maintainable classes. This summary covers both the what (concepts) and the how (JVM internals).</p>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#the-four-pillars-of-oop","title":"The Four Pillars of OOP","text":"","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#1-encapsulation","title":"1. Encapsulation","text":"<p>Definition: Bundling data and methods that operate on that data within a single unit (class), restricting direct access to internal state.</p> <pre><code>flowchart TB\n    subgraph class[\" ENCAPSULATED CLASS \"]\n        subgraph hidden[\" Private \"]\n            F[Fields]\n            PM[Helper Methods]\n        end\n        subgraph public[\" Public \"]\n            C[Constructors]\n            M[Methods]\n            G[Getters/Setters]\n        end\n    end\n\n    Client([External Code]) --&gt;|calls| public\n    public -.accesses.-&gt; hidden</code></pre>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#key-principles","title":"Key Principles","text":"<ul> <li>Data hiding: Keep fields private, expose through controlled methods</li> <li>Validation: Validate data in setters and constructors</li> <li>Flexibility: Internal implementation can change without affecting clients</li> <li>Reduced complexity: Clients only see what they need</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#best-practices-from-effective-java","title":"Best Practices (from Effective Java)","text":"Practice Rationale Make fields private by default Maximum encapsulation Use most restrictive access Don't expose more than needed Provide controlled access via methods Add validation, logging, etc. Make classes immutable when possible Simpler, thread-safe, no defensive copying","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#2-inheritance","title":"2. Inheritance","text":"<p>Definition: Mechanism where a new class inherits properties and behaviors from an existing class, establishing an IS-A relationship.</p> <pre><code>classDiagram\n    direction TB\n    class Animal {\n        -String name\n        +speak() void\n        +move() void\n    }\n    class Dog {\n        +speak() void\n        +fetch() void\n    }\n    class Cat {\n        +speak() void\n        +purr() void\n    }\n\n    Animal &lt;|-- Dog : extends\n    Animal &lt;|-- Cat : extends</code></pre>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#key-principles_1","title":"Key Principles","text":"<ul> <li>IS-A relationship: Dog IS-A Animal</li> <li>Code reuse: Subclasses inherit parent's implementation</li> <li>Constructor chaining: <code>super()</code> must be first statement</li> <li>Method overriding: Subclass can replace parent's behavior</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#when-to-use-inheritance","title":"When to Use Inheritance","text":"<p>\u2705 Good use cases:</p> <ul> <li>Clear IS-A relationship exists</li> <li>Subclass is truly a subtype of superclass</li> <li>Behavior needs to be shared across hierarchy</li> <li>Parent class is designed for inheritance</li> </ul> <p>\u274c When to Avoid:</p> <ul> <li>Just for code reuse \u2192 Use composition instead</li> <li>Violates Liskov Substitution Principle</li> <li>Parent class not designed for inheritance</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#3-polymorphism","title":"3. Polymorphism","text":"<p>Definition: Ability of objects to take many forms, allowing same interface to be used for different underlying types.</p>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#compile-time-static-polymorphism","title":"Compile-Time (Static) Polymorphism","text":"<pre><code>// Method Overloading - resolved at COMPILE time\npublic void print(int x) { }\npublic void print(String s) { }\npublic void print(int x, String s) { }\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#runtime-dynamic-polymorphism","title":"Runtime (Dynamic) Polymorphism","text":"<pre><code>// Method Overriding - resolved at RUNTIME\nAnimal animal = new Dog();  // Compile type: Animal, Runtime type: Dog\nanimal.speak();             // Calls Dog's speak() at runtime!\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#how-the-jvm-resolves-it","title":"How the JVM Resolves It","text":"Type Resolution Time Mechanism Overloading Compile-time Method signature matching Overriding Runtime VTable lookup","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#4-abstraction","title":"4. Abstraction","text":"<p>Definition: Hiding complex implementation details and showing only essential features.</p>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#abstract-class-vs-interface-decision-matrix","title":"Abstract Class vs Interface Decision Matrix","text":"Criteria Abstract Class Interface Shared implementation code \u2705 Best \u26a0\ufe0f Default methods only Instance fields (state) \u2705 Yes \u274c No Constructor needed \u2705 Yes \u274c No Multiple inheritance \u274c No \u2705 Yes API evolution \u26a0\ufe0f Limited \u2705 Default methods Define type only \u26a0\ufe0f Overkill \u2705 Best","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#the-skeletal-implementation-pattern-effective-java-item-20","title":"The Skeletal Implementation Pattern (Effective Java Item 20)","text":"<p>Combine both: interface for type + abstract class for convenience.</p> <pre><code>// 1. Interface defines the type\npublic interface List&lt;E&gt; { ... }\n\n// 2. Skeletal implementation provides common code\npublic abstract class AbstractList&lt;E&gt; implements List&lt;E&gt; { ... }\n\n// 3. Concrete class extends skeletal for convenience\npublic class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; { ... }\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#key-internals-to-understand","title":"Key Internals to Understand","text":"","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#1-method-dispatch-mechanism-vtable","title":"1. Method Dispatch Mechanism (VTable)","text":"<p>The Virtual Method Table (VTable) is how the JVM implements runtime polymorphism. It's an array of method pointers stored per-class.</p> <pre><code>flowchart LR\n    subgraph classes[\" CLASS LOADING \"]\n        direction TB\n        AC[\"Animal.class&lt;br&gt;VTable[0]: speak()_A&lt;br&gt;VTable[1]: move()_A\"]\n        DC[\"Dog.class&lt;br&gt;VTable[0]: speak()_D \u2190overridden&lt;br&gt;VTable[1]: move()_A \u2190inherited\"]\n    end\n\n    subgraph runtime[\" RUNTIME \"]\n        OBJ[\"Dog object&lt;br&gt;classPtr \u2192 Dog.class\"]\n        CALL[\"animal.speak()\"]\n    end\n\n    CALL --&gt; OBJ\n    OBJ --&gt;|\"lookup VTable[0]\"| DC\n    DC --&gt;|\"call speak()_D\"| DOG_SPEAK[Dog's speak executes]\n\n    style DOG_SPEAK fill:#4CAF50,color:#fff</code></pre>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#how-it-works-step-by-step","title":"How It Works Step-by-Step","text":"<ol> <li>Class Loading: When a class is loaded, the JVM creates its VTable</li> <li>Object Creation: Each object has a pointer to its class's VTable</li> <li>Method Call: <code>invokevirtual</code> instruction is executed</li> <li>VTable Lookup: JVM uses fixed offset to find method address</li> <li>Execution: Correct method is called based on runtime type</li> </ol> <pre><code>Animal animal = new Dog();  // Runtime type is Dog\nanimal.speak();             // Steps:\n                            // 1. Get object's class (Dog)\n                            // 2. Access Dog's VTable\n                            // 3. Look up speak() at fixed index\n                            // 4. Execute Dog's speak() method\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#vtable-vs-itable-interface-tables","title":"VTable vs ITable (Interface Tables)","text":"Mechanism Used For Lookup VTable Class methods Fixed offset (fast) ITable Interface methods Search required (slightly slower) <p>JVM Bytecode Instructions</p> <ul> <li> <p><code>invokevirtual</code> - Call class instance method</p> </li> <li> <p><code>invokeinterface</code> - Call interface method</p> </li> <li><code>invokespecial</code> - Call constructor or private method (no override)</li> <li><code>invokestatic</code> - Call static method (no VTable needed)</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#2-how-polymorphism-works-at-runtime","title":"2. How Polymorphism Works at Runtime","text":"","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#the-complete-picture","title":"The Complete Picture","text":"<pre><code>flowchart TD\n    subgraph compile[\" COMPILE TIME \"]\n        SRC[Java Source] --&gt;|javac| BC[Bytecode]\n        BC --&gt; IV[\"invokevirtual Animal.speak()\"]\n    end\n\n    subgraph runtime[\" RUNTIME \"]\n        IV --&gt;|JVM executes| VT[VTable Lookup]\n        VT --&gt;|\"Actual type: Dog\"| DM[Dog.speak]\n        VT --&gt;|\"Actual type: Cat\"| CM[Cat.speak]\n    end\n\n    compile --&gt; runtime</code></pre>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#code-example-with-bytecode","title":"Code Example with Bytecode","text":"<pre><code>public class Demo {\n    public static void main(String[] args) {\n        Animal a = new Dog();\n        a.speak();  // Which speak() is called?\n    }\n}\n</code></pre> <p>Bytecode generated:</p> <pre><code>0: new           #2    // class Dog\n3: dup\n4: invokespecial #3    // Dog.&lt;init&gt;()\n7: astore_1\n8: aload_1\n9: invokevirtual #4    // Animal.speak() - but resolves to Dog at runtime!\n12: return\n</code></pre> <p>The bytecode says <code>Animal.speak()</code>, but at runtime the JVM:</p> <ol> <li>Looks at the object's actual class (Dog)</li> <li>Finds Dog's VTable</li> <li>Calls Dog's implementation of speak()</li> </ol>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#3-object-creation-process","title":"3. Object Creation Process","text":"<p>When you write <code>new MyClass()</code>, the JVM performs multiple steps in a specific order.</p> <pre><code>flowchart TD\n    subgraph phase1[\" 1. CLASS LOADING - once per class \"]\n        L1[Load .class file]\n        L2[Verify bytecode]\n        L3[Initialize static fields]\n        L4[Execute static blocks]\n        L1 --&gt; L2 --&gt; L3 --&gt; L4\n    end\n\n    subgraph phase2[\" 2. MEMORY ALLOCATION \"]\n        M1[\"Allocate heap memory&lt;br/&gt;for object + fields\"]\n        M2[\"Set all fields to&lt;br/&gt;default values\"]\n        M1 --&gt; M2\n    end\n\n    subgraph phase3[\" 3. INITIALIZATION \"]\n        I1[\"Initialize instance variables&lt;br/&gt;to declared values\"]\n        I2[\"Execute instance&lt;br/&gt;initialization blocks\"]\n        I3[Execute constructor body]\n        I4[Return reference]\n        I1 --&gt; I2 --&gt; I3 --&gt; I4\n    end\n\n    phase1 --&gt; phase2 --&gt; phase3</code></pre>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#detailed-execution-order","title":"Detailed Execution Order","text":"<pre><code>public class Parent {\n    static { System.out.println(\"1. Parent static block\"); }\n    { System.out.println(\"4. Parent instance block\"); }\n\n    public Parent() {\n        System.out.println(\"5. Parent constructor\");\n    }\n}\n\npublic class Child extends Parent {\n    static { System.out.println(\"2. Child static block\"); }\n    { System.out.println(\"6. Child instance block\"); }\n\n    public Child() {\n        super();  // Implicit if not specified\n        System.out.println(\"7. Child constructor\");\n    }\n}\n\n// new Child() prints:\n// 1. Parent static block     \u2190 Static phase (once)\n// 2. Child static block      \u2190 Static phase (once)\n// 3. (Memory allocated, defaults set)\n// 4. Parent instance block   \u2190 Instance phase\n// 5. Parent constructor      \u2190 Constructors (bottom-up)\n// 6. Child instance block    \u2190 Instance phase\n// 7. Child constructor       \u2190 Constructors (bottom-up)\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#memory-layout","title":"Memory Layout","text":"<pre><code>flowchart LR\n    subgraph stack[\" STACK \"]\n        REF[\"Reference&lt;br/&gt;myObject\"]\n    end\n\n    subgraph heap[\" HEAP \"]\n        OBJ[\"Object Header&lt;br/&gt;classPtr, hashCode, GC info\"]\n        FIELDS[\"Instance Fields&lt;br/&gt;name, age\"]\n    end\n\n    REF --&gt; OBJ\n    OBJ --&gt; FIELDS</code></pre>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#best-practices-from-effective-java_1","title":"Best Practices (from Effective Java)","text":"Pattern When to Use Static Factory Need descriptive names, caching, subtypes Builder Many parameters (4+), optional parameters Constructor Simple, few required parameters","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#4-interface-vs-abstract-class-performance","title":"4. Interface vs Abstract Class Performance","text":"","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#bytecode-instructions-comparison","title":"Bytecode Instructions Comparison","text":"Instruction Used For Lookup Method <code>invokevirtual</code> Class methods VTable offset (O(1)) <code>invokeinterface</code> Interface methods ITable search (slightly slower)","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#why-interface-calls-can-be-slower","title":"Why Interface Calls Can Be Slower","text":"<pre><code>flowchart LR\n    subgraph vtable[\" VTABLE (Classes) \"]\n        direction TB\n        V1[\"Fixed offset for each method\"]\n        V2[\"Direct jump to method\"]\n        V1 --&gt; V2\n    end\n\n    subgraph itable[\" ITABLE (Interfaces) \"]\n        direction TB\n        I1[\"Multiple interfaces possible\"]\n        I2[\"Must find correct interface first\"]\n        I3[\"Then find method offset\"]\n        I1 --&gt; I2 --&gt; I3\n    end\n\n    vtable --&gt;|\"invokevirtual\"| FAST[Fast]\n    itable --&gt;|\"invokeinterface\"| SLOWER[Slightly slower]\n\n    style FAST fill:#4CAF50,color:#fff\n    style SLOWER fill:#FF9800</code></pre> <p>Why the difference?</p> <ol> <li>Vtable (classes): Method at fixed offset \u2192 Single array lookup</li> <li>Itable (interfaces): Class may implement many interfaces \u2192 Must search</li> </ol>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#jvm-optimizations-modern-jvms","title":"JVM Optimizations (Modern JVMs)","text":"Optimization Description Monomorphic inline cache If call site always resolves to same type, cache it Devirtualization JIT converts virtual call to direct call Inlining Replace method call with method body Type profiling Track actual types at call sites <pre><code>// If JVM observes that animal is always Dog:\nAnimal animal = new Dog();\nanimal.speak();  // JVM can inline Dog.speak() directly!\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#the-real-world-verdict","title":"The Real-World Verdict","text":"Factor Advice Performance difference ~0-5% in most cases Modern JVMs Heavily optimized, difference often negligible Design Choose based on design needs, not performance Rule of thumb Interface for types, abstract class for shared code <p>Don't Micro-Optimize</p> <ul> <li>The performance difference between interfaces and abstract classes is almost never the bottleneck. Focus on correct design first.</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#class-design-principles","title":"Class Design Principles","text":"","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#solid-principles-applied","title":"SOLID Principles Applied","text":"<pre><code>flowchart LR\n    S[\"S - Single&lt;br&gt;Responsibility\"] --&gt; O[\"O - Open/&lt;br&gt;Closed\"]\n    O --&gt; L[\"L - Liskov&lt;br&gt;Substitution\"]\n    L --&gt; I[\"I - Interface&lt;br&gt;Segregation\"]\n    I --&gt; D[\"D - Dependency&lt;br&gt;Inversion\"]</code></pre> Principle Description Effective Java Item S ingle Responsibility One reason to change Item 15: Minimize accessibility O pen/Closed Open for extension, closed for modification Item 20: Prefer interfaces L iskov Substitution Subtypes replaceable Item 10: equals contract I nterface Segregation Small, specific interfaces Item 20: Prefer interfaces D ependency Inversion Depend on abstractions Item 18: Composition","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#composition-over-inheritance","title":"Composition Over Inheritance","text":"<pre><code>flowchart LR\n    subgraph inheritance[\" \u274c INHERITANCE \"]\n        H1[Tight coupling]\n        H2[Fragile base class]\n        H3[Single inheritance only]\n    end\n\n    subgraph composition[\" \u2705 COMPOSITION \"]\n        C1[Loose coupling]\n        C2[Flexible at runtime]\n        C3[Easy to test]\n    end\n\n    inheritance -.better choice.-&gt; composition</code></pre> <p>From Effective Java Item 18:</p> <pre><code>// \u274c BAD: Inheritance - tightly coupled, fragile\npublic class InstrumentedHashSet&lt;E&gt; extends HashSet&lt;E&gt; { ... }\n\n// \u2705 GOOD: Composition - flexible, robust\npublic class InstrumentedSet&lt;E&gt; implements Set&lt;E&gt; {\n    private final Set&lt;E&gt; s;  // Composition: HAS-A\n    public InstrumentedSet(Set&lt;E&gt; s) { this.s = s; }\n    // Delegate to wrapped set\n}\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#common-pitfalls","title":"Common Pitfalls","text":"","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#1-breaking-encapsulation","title":"1. Breaking Encapsulation","text":"<pre><code>// \u274c BAD: Exposing internal state\npublic List&lt;String&gt; getItems() { return items; }  // Client can modify!\n\n// \u2705 GOOD: Defensive copy\npublic List&lt;String&gt; getItems() { return new ArrayList&lt;&gt;(items); }\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#2-inheritance-abuse","title":"2. Inheritance Abuse","text":"<pre><code>// \u274c BAD: Using inheritance for code reuse\nclass Stack extends ArrayList { }  // Stack IS-NOT-A ArrayList!\n\n// \u2705 GOOD: Composition\nclass Stack {\n    private ArrayList items;  // Stack HAS-A ArrayList\n}\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#3-equalshashcode-contract-violations","title":"3. equals/hashCode Contract Violations","text":"<pre><code>// \u274c BROKEN: Override equals without hashCode\n@Override public boolean equals(Object o) { ... }\n// HashMap/HashSet will break!\n\n// \u2705 CORRECT: Always override both\n@Override public boolean equals(Object o) { ... }\n@Override public int hashCode() { ... }\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#4-not-understanding-runtime-types","title":"4. Not Understanding Runtime Types","text":"<pre><code>// What does this print?\nAnimal a = new Dog();\nSystem.out.println(a.getClass().getName());  // Dog, not Animal!\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#best-practices-checklist","title":"Best Practices Checklist","text":"<p>From Effective Java and the course:</p> <ul> <li> Make classes immutable when possible (Item 17)</li> <li> Favor composition over inheritance (Item 18)</li> <li> Program to interfaces, not implementations (Item 20)</li> <li> Override equals and hashCode together (Items 10-11)</li> <li> Consider static factory methods (Item 1)</li> <li> Minimize accessibility of everything (Item 15)</li> <li> Design for inheritance or prohibit it (make class final)</li> <li> Prefer interfaces to abstract classes (Item 20)</li> <li> Use the Builder pattern for many parameters (Item 2)</li> <li> Eliminate obsolete object references (Item 7)</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#learning-resources","title":"Learning Resources","text":"","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#vtable-method-dispatch","title":"VTable &amp; Method Dispatch","text":"<ul> <li>Aleksey Shipil\u00ebv's blog</li> <li>Dev.to - Virtual Tables in Java</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#object-creation-process","title":"Object Creation Process","text":"<ul> <li>JVM under the hood - Medium</li> <li>A Deep Dive into JVM Start-up - inside Java</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#interface-vs-abstract-class","title":"Interface vs Abstract Class","text":"<ul> <li>StackOverflow - Performance Discussion</li> <li>Oracle - JVM Specification</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#effective-java","title":"Effective Java","text":"<ul> <li>Effective Java 3<sup>rd</sup> Edition</li> <li>GitHub - Effective Java Summary</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#related-topics","title":"Related Topics","text":"<ul> <li>Syntax, Variables &amp; Control Flow</li> <li>Arrays, Lists &amp; Autoboxing</li> <li>Collections Framework</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/summary/#references","title":"References","text":"<ul> <li>Course: Tim Buchalka - Java Programming Masterclass (Sections 7-8)</li> <li>Book: Effective Java - Joshua Bloch (Chapters 2-4)</li> <li>Book: Head First Design Patterns (OOP principles applied)</li> <li>Spec: JVM Specification - Method Invocation</li> </ul> <p>Completed: 2026-01-26 | Confidence: 9/10</p>","tags":[]},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/","title":"OOP Challenges","text":"<p>Course: Java Programming Masterclass - Tim Buchalka (Udemy) Sections: 07 &amp; 08 - OOP &amp; Class Design Status:  Complete</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#challenge-overview","title":"Challenge Overview","text":"Challenge Focus Area Difficulty Inheritance Challenge Classes, Inheritance, Overriding OOP Master Challenge Composition, Encapsulation, Polymorphism, Inheritance"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#challenge-1-inheritance-challenge-worker-hierarchy","title":"Challenge 1: Inheritance Challenge - Worker Hierarchy","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#challenge-overview_1","title":"Challenge Overview","text":"<p>Build a worker management system demonstrating inheritance and method overriding. Create a class hierarchy that models different types of workers at a company.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#requirements-summary","title":"Requirements Summary","text":"<ul> <li>Create a base class <code>Worker</code> with common attributes</li> <li>Create an <code>Employee</code> subclass extending <code>Worker</code></li> <li>Create specialized employee types: <code>SalariedEmployee</code> and <code>HourlyEmployee</code></li> <li>Implement pay calculation differently for each employee type</li> <li>Use constructor chaining across the hierarchy</li> <li>Override methods appropriately</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#class-hierarchy-design","title":"Class Hierarchy Design","text":"<pre><code>classDiagram\n    direction TB\n    class Worker {\n        -String name\n        -String birthDate\n        #String endDate\n        +Worker()\n        +Worker(name, birthDate)\n        +getAge() int\n        +collectPay() double\n        +terminate(endDate)\n        +toString() String\n    }\n\n    class Employee {\n        -long employeeId\n        -String hireDate\n        -static int employeeNo\n        +Employee(name, birthDate, hireDate)\n        +toString() String\n    }\n\n    class SalariedEmployee {\n        ~double annualSalary\n        ~boolean isRetired\n        +SalariedEmployee(name, birthDate, hireDate, salary)\n        +collectPay() double\n        +retire()\n    }\n\n    class HourlyEmployee {\n        -double hourlyPayRate\n        +HourlyEmployee(name, birthDate, hireDate, rate)\n        +collectPay() double\n        +getDoublePay() double\n    }\n\n    Worker &lt;|-- Employee\n    Employee &lt;|-- SalariedEmployee\n    Employee &lt;|-- HourlyEmployee</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#solution-implementation","title":"Solution Implementation","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#workerjava-the-base-class","title":"Worker.java - The Base Class","text":"<pre><code>public class Worker {\n    private String name;\n    private String birthDate;\n    protected String endDate;  // Protected for subclass access\n\n    // Default constructor - gives subclasses flexibility\n    public Worker() { }\n\n    public Worker(String name, String birthDate) {\n        this.name = name;\n        this.birthDate = birthDate;\n    }\n\n    public int getAge() {\n        int currentYear = 2026;\n        int birthYear = Integer.parseInt(birthDate.substring(6));\n        return (currentYear - birthYear);\n    }\n\n    // To be overridden by subclasses\n    public double collectPay() {\n        return 0.0;\n    }\n\n    public void terminate(String endDate) {\n        this.endDate = endDate;\n    }\n\n    @Override\n    public String toString() {\n        return \"Worker{\" +\n                \"name='\" + name + '\\'' +\n                \", birthDate='\" + birthDate + '\\'' +\n                \", endDate='\" + endDate + '\\'' + '}';\n    }\n}\n</code></pre> <p>Key Concepts</p> <ul> <li>Default constructor: Allows subclasses flexibility in their own constructors</li> <li>Protected field: <code>endDate</code> can be accessed/modified by subclasses</li> <li><code>collectPay()</code> returns 0: Designed to be overridden by subclasses</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#employeejava-first-level-subclass","title":"Employee.java - First Level Subclass","text":"<pre><code>public class Employee extends Worker {\n    private long employeeId;\n    private String hireDate;\n\n    // Static field for auto-generating employee IDs\n    private static int employeeNo = 1;\n\n    public Employee(String name, String birthDate, String hireDate) {\n        super(name, birthDate);  // Call Worker constructor\n        this.employeeId = Employee.employeeNo++;  // Auto-increment\n        this.hireDate = hireDate;\n    }\n\n    @Override\n    public String toString() {\n        return \"Employee{\" +\n                \"employeeId=\" + employeeId +\n                \", hireDate='\" + hireDate + '\\'' +\n                \"} \" + super.toString();  // Include parent's toString\n    }\n}\n</code></pre> <p>Static Field for Auto-ID</p> <p>Using <code>static int employeeNo</code> shared across all Employee instances generates unique IDs automatically. Each new Employee gets assigned an ID and increments the counter.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#salariedemployeejava-specialized-employee","title":"SalariedEmployee.java - Specialized Employee","text":"<pre><code>public class SalariedEmployee extends Employee {\n    double annualSalary;\n    boolean isRetired;\n\n    public SalariedEmployee(String name, String birthDate, \n                            String hireDate, double annualSalary) {\n        super(name, birthDate, hireDate);\n        this.annualSalary = annualSalary;\n    }\n\n    @Override\n    public double collectPay() {\n        // Bi-weekly pay (26 pay periods per year)\n        double paycheck = annualSalary / 26;\n\n        // Pension is 90% of salary if retired\n        double adjustedPay = (isRetired) ? 0.9 * paycheck : paycheck;\n\n        return (int) adjustedPay;  // Whole dollars only\n    }\n\n    public void retire() {\n        terminate(\"12/12/2026\");  // Calls Worker's terminate()\n        isRetired = true;\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#hourlyemployeejava-alternative-specialized-employee","title":"HourlyEmployee.java - Alternative Specialized Employee","text":"<pre><code>public class HourlyEmployee extends Employee {\n    private double hourlyPayRate;\n\n    public HourlyEmployee(String name, String birthDate, \n                          String hireDate, double hourlyPayRate) {\n        super(name, birthDate, hireDate);\n        this.hourlyPayRate = hourlyPayRate;\n    }\n\n    @Override\n    public double collectPay() {\n        // 40 hours per week standard\n        return 40 * hourlyPayRate;\n    }\n\n    public double getDoublePay() {\n        // Overtime: double the regular pay\n        return 2 * collectPay();\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#testing-the-hierarchy","title":"Testing the Hierarchy","text":"<pre><code>public class Main {\n    public static void main(String[] args) {\n        // Basic Employee (uses Worker's collectPay - returns 0)\n        Employee tim = new Employee(\"Tim\", \"11/11/1985\", \"01/01/2020\");\n        System.out.println(tim);\n        System.out.println(\"Age = \" + tim.getAge());\n        System.out.println(\"Pay = \" + tim.collectPay());\n\n        // Salaried Employee\n        SalariedEmployee joe = new SalariedEmployee(\"Joe\", \"11/11/1990\",\n                \"03/03/2025\", 60000);\n        System.out.println(joe);\n        System.out.println(\"Joe's Paycheck = $\" + joe.collectPay());\n\n        // Retire Joe and check pension\n        joe.retire();\n        System.out.println(\"Joe's Pension check = $\" + joe.collectPay());\n\n        // Hourly Employee\n        HourlyEmployee mary = new HourlyEmployee(\"Mary\", \"05/05/1970\",\n                \"03/03/2021\", 15);\n        System.out.println(mary);\n        System.out.println(\"Mary's Paycheck = $\" + mary.collectPay());\n        System.out.println(\"Mary's Holiday Pay = $\" + mary.getDoublePay());\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#output","title":"Output","text":"<pre><code>Employee{employeeId=1, hireDate='01/01/2020'} Worker{name='Tim', birthDate='11/11/1985', endDate='null'}\nAge = 41\nPay = 0.0\nEmployee{employeeId=2, hireDate='03/03/2025'} Worker{name='Joe', birthDate='11/11/1990', endDate='null'}\nJoe's Paycheck = $2307\nJoe's Pension check = $2076\nEmployee{employeeId=3, hireDate='03/03/2021'} Worker{name='Mary', birthDate='05/05/1970', endDate='null'}\nMary's Paycheck = $600.0\nMary's Holiday Pay = $1200.0\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#key-learnings","title":"Key Learnings","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#method-resolution-in-inheritance","title":"Method Resolution in Inheritance","text":"<pre><code>flowchart LR\n    subgraph \"Method Calls\"\n        A1[getAge] --&gt; W[Worker]\n        A2[toString] --&gt; E[Employee]\n        A3[collectPay] --&gt; S[SalariedEmployee]\n        A4[collectPay] --&gt; H[HourlyEmployee]\n    end</code></pre> Method Joe (<code>SalariedEmployee</code>) Mary (<code>HourlyEmployee</code>) <code>getAge()</code> Worker (not overridden) Worker (not overridden) <code>toString()</code> Employee (extended from Worker) Employee (extended from Worker) <code>collectPay()</code> SalariedEmployee (overridden) HourlyEmployee (overridden) <code>retire()</code> SalariedEmployee only Not available <code>getDoublePay()</code> Not available HourlyEmployee only"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#challenge-2-oop-master-challenge-burger-restaurant","title":"Challenge 2: OOP Master Challenge - Burger Restaurant","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#challenge-overview_2","title":"Challenge Overview","text":"<p>Build a complete Burger Restaurant Application using ALL OOP principles:</p> <ul> <li>Inheritance - Item \u2192 Burger \u2192 DeluxeBurger</li> <li>Composition - MealOrder contains Burger, Drink, Side</li> <li>Encapsulation - Hide implementation details from calling code</li> <li>Polymorphism - Different pricing behavior for different burger types</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#business-requirements","title":"Business Requirements","text":"<ol> <li>Meal Orders composed of: 1 burger + 1 drink + 1 side item</li> <li>Burgers can have up to 3 extra toppings (additional cost)</li> <li>Drinks have sizes (Small, Medium, Large) affecting price</li> <li>Deluxe Burger (bonus): 5 toppings, fixed price includes everything</li> </ol>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#system-architecture","title":"System Architecture","text":"<pre><code>classDiagram\n    direction TB\n    class Item {\n        -String type\n        -String name\n        -double price\n        -String size\n        +Item(type, name, price)\n        +getName() String\n        +getBasePrice() double\n        +getAdjustedPrice() double\n        +setSize(size)\n        +printItem()\n    }\n\n    class Burger {\n        -Item extra1\n        -Item extra2\n        -Item extra3\n        +Burger(name, price)\n        +getName() String\n        +getAdjustedPrice() double\n        +getExtraPrice(toppingName) double\n        +addToppings(e1, e2, e3)\n        +printItemizedList()\n        +printItem()\n    }\n\n    class DeluxeBurger {\n        ~Item deluxe1\n        ~Item deluxe2\n        +DeluxeBurger(name, price)\n        +addToppings(e1, e2, e3, e4, e5)\n        +printItemizedList()\n        +getExtraPrice(toppingName) double\n    }\n\n    class MealOrder {\n        -Burger burger\n        -Item drink\n        -Item side\n        +MealOrder()\n        +MealOrder(burgerType, drinkType, sideType)\n        +getTotalPrice() double\n        +printItemizedList()\n        +addBurgerToppings(...)\n        +setDrinkSize(size)\n    }\n\n    Item &lt;|-- Burger : extends\n    Burger &lt;|-- DeluxeBurger : extends\n    MealOrder *-- Burger : composition\n    MealOrder *-- Item : composition (drink)\n    MealOrder *-- Item : composition (side)\n    Burger *-- Item : composition (toppings)</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#solution-implementation_1","title":"Solution Implementation","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#itemjava-base-class-for-all-menu-items","title":"Item.java - Base Class for All Menu Items","text":"<pre><code>public class Item {\n    private String type;\n    private String name;\n    private double price;\n    private String size = \"Medium\";  // Default size\n\n    public Item(String type, String name, double price) {\n        this.type = type.toUpperCase();\n        this.name = name.toUpperCase();\n        this.price = price;\n    }\n\n    public String getName() {\n        // Include size for drinks and sides only\n        if (type.equals(\"SIDE\") || type.equals(\"DRINK\")) {\n            return size + \" \" + name;\n        }\n        return name;\n    }\n\n    public double getBasePrice() {\n        return price;\n    }\n\n    public double getAdjustedPrice() {\n        // Adjust price based on size\n        return switch (size) {\n            case \"SMALL\" -&gt; getBasePrice() - 0.5;\n            case \"LARGE\" -&gt; getBasePrice() + 1;\n            default -&gt; getBasePrice();  // Medium = no change\n        };\n    }\n\n    public void setSize(String size) {\n        this.size = size;\n    }\n\n    // Static method - can be called from anywhere\n    public static void printItem(String name, double price) {\n        System.out.printf(\"%20s:%6.2f%n\", name, price);\n    }\n\n    // Instance method - uses this item's data\n    public void printItem() {\n        printItem(getName(), getAdjustedPrice());\n    }\n}\n</code></pre> <p>Polymorphic Design</p> <p>The <code>getName()</code> and <code>getAdjustedPrice()</code> methods are designed to be overridden by subclasses for different behavior.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#burgerjava-extends-item-with-toppings","title":"Burger.java - Extends Item with Toppings","text":"<pre><code>public class Burger extends Item {\n    private Item extra1;\n    private Item extra2;\n    private Item extra3;\n\n    public Burger(String name, double price) {\n        super(\"Burger\", name, price);  // Type is always \"Burger\"\n    }\n\n    @Override\n    public String getName() {\n        return super.getName() + \" BURGER\";\n    }\n\n    @Override\n    public double getAdjustedPrice() {\n        // Base price + all toppings (null-safe)\n        return getBasePrice() +\n                ((extra1 == null) ? 0 : extra1.getAdjustedPrice()) +\n                ((extra2 == null) ? 0 : extra2.getAdjustedPrice()) +\n                ((extra3 == null) ? 0 : extra3.getAdjustedPrice());\n    }\n\n    // Topping pricing logic\n    public double getExtraPrice(String toppingName) {\n        return switch (toppingName.toUpperCase()) {\n            case \"AVOCADO\", \"CHEESE\" -&gt; 1.0;\n            case \"BACON\", \"HAM\", \"SALAMI\" -&gt; 1.5;\n            default -&gt; 0.0;  // Free toppings (lettuce, mayo, etc.)\n        };\n    }\n\n    public void addToppings(String extra1, String extra2, String extra3) {\n        this.extra1 = new Item(\"TOPPING\", extra1, getExtraPrice(extra1));\n        this.extra2 = new Item(\"TOPPING\", extra2, getExtraPrice(extra2));\n        this.extra3 = new Item(\"TOPPING\", extra3, getExtraPrice(extra3));\n    }\n\n    public void printItemizedList() {\n        printItem(\"BASE BURGER\", getBasePrice());\n        if (extra1 != null) extra1.printItem();\n        if (extra2 != null) extra2.printItem();\n        if (extra3 != null) extra3.printItem();\n    }\n\n    @Override\n    public void printItem() {\n        printItemizedList();\n        System.out.println(\"-\".repeat(30));\n        super.printItem();  // Print total burger price\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#deluxeburgerjava-premium-burger-with-fixed-price","title":"DeluxeBurger.java - Premium Burger with Fixed Price","text":"<pre><code>public class DeluxeBurger extends Burger {\n    Item deluxe1;\n    Item deluxe2;\n\n    public DeluxeBurger(String name, double price) {\n        super(name, price);\n    }\n\n    // Overloaded method - 5 toppings for deluxe\n    public void addToppings(String extra1, String extra2, String extra3, \n                            String extra4, String extra5) {\n        super.addToppings(extra1, extra2, extra3);\n        deluxe1 = new Item(\"TOPPING\", extra4, 0);  // Free!\n        deluxe2 = new Item(\"TOPPING\", extra5, 0);  // Free!\n    }\n\n    @Override\n    public void printItemizedList() {\n        super.printItemizedList();\n        if (deluxe1 != null) deluxe1.printItem();\n        if (deluxe2 != null) deluxe2.printItem();\n    }\n\n    @Override\n    public double getExtraPrice(String toppingName) {\n        return 0;  // ALL toppings are FREE on deluxe burger!\n    }\n}\n</code></pre> <p>Polymorphism in Action</p> <p><code>getExtraPrice()</code> returns 0 for DeluxeBurger, overriding the parent's pricing logic. This makes all toppings free!</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#mealorderjava-composition-container","title":"MealOrder.java - Composition Container","text":"<pre><code>public class MealOrder {\n    private Burger burger;\n    private Item drink;\n    private Item side;\n\n    // Default meal constructor - no arguments\n    public MealOrder() {\n        this(\"regular\", \"coke\", \"fries\");\n    }\n\n    // Custom meal constructor\n    public MealOrder(String burgerType, String drinkType, String sideType) {\n        // Create the right type of burger\n        if (burgerType.equalsIgnoreCase(\"deluxe\")) {\n            this.burger = new DeluxeBurger(burgerType, 8.5);\n        } else {\n            this.burger = new Burger(burgerType, 4.0);\n        }\n        this.drink = new Item(\"drink\", drinkType, 1.00);\n        this.side = new Item(\"side\", sideType, 1.50);\n    }\n\n    public double getTotalPrice() {\n        // Deluxe burger includes everything in one price\n        if (burger instanceof DeluxeBurger) {\n            return burger.getAdjustedPrice();\n        }\n        return burger.getAdjustedPrice() + \n               drink.getAdjustedPrice() + \n               side.getAdjustedPrice();\n    }\n\n    public void printItemizedList() {\n        burger.printItem();\n\n        // Deluxe meals show drink/side as free\n        if (burger instanceof DeluxeBurger) {\n            Item.printItem(drink.getName(), 0);\n            Item.printItem(side.getName(), 0);\n        } else {\n            drink.printItem();\n            side.printItem();\n        }\n\n        System.out.println(\"-\".repeat(30));\n        Item.printItem(\"TOTAL PRICE\", getTotalPrice());\n    }\n\n    // Delegate to burger - 3 toppings\n    public void addBurgerToppings(String extra1, String extra2, String extra3) {\n        burger.addToppings(extra1, extra2, extra3);\n    }\n\n    // Delegate to burger - 5 toppings (deluxe)\n    public void addBurgerToppings(String extra1, String extra2, String extra3,\n                                   String extra4, String extra5) {\n        if (burger instanceof DeluxeBurger db) {\n            db.addToppings(extra1, extra2, extra3, extra4, extra5);\n        } else {\n            burger.addToppings(extra1, extra2, extra3);\n        }\n    }\n\n    public void setDrinkSize(String size) {\n        drink.setSize(size);\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#testing-the-application","title":"Testing the Application","text":"<pre><code>public class Main {\n    public static void main(String[] args) {\n\n        // Regular Meal - default constructor\n        MealOrder regularOrder = new MealOrder();\n        regularOrder.addBurgerToppings(\"BACON\", \"CHEESE\", \"MAYO\");\n        regularOrder.setDrinkSize(\"LARGE\");\n        regularOrder.printItemizedList();\n\n        System.out.println(\"\\n\" + \"=\".repeat(30) + \"\\n\");\n\n        // Deluxe Meal - all included in fixed price\n        MealOrder deluxeOrder = new MealOrder(\"deluxe\", \"7-up\", \"chili\");\n        deluxeOrder.addBurgerToppings(\"AVOCADO\", \"BACON\", \"LETTUCE\", \n                                       \"CHEESE\", \"MAYO\");\n        deluxeOrder.setDrinkSize(\"SMALL\");\n        deluxeOrder.printItemizedList();\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#sample-output","title":"Sample Output","text":"<pre><code>          BASE BURGER:  4.00\n               BACON:  1.50\n              CHEESE:  1.00\n                MAYO:  0.00\n------------------------------\n      REGULAR BURGER:  6.50\n         Large COKE:  2.00\n       Medium FRIES:  1.50\n------------------------------\n         TOTAL PRICE: 10.00\n\n==============================\n\n          BASE BURGER:  8.50\n             AVOCADO:  0.00\n               BACON:  0.00\n             LETTUCE:  0.00\n              CHEESE:  0.00\n                MAYO:  0.00\n------------------------------\n       DELUXE BURGER:  8.50\n         Small 7-UP:  0.00\n       Medium CHILI:  0.00\n------------------------------\n         TOTAL PRICE:  8.50\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#oop-concepts-applied","title":"OOP Concepts Applied","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#summary-table","title":"Summary Table","text":"OOP Concept Where Applied Example Inheritance Item \u2192 Burger \u2192 DeluxeBurger <code>class Burger extends Item</code> Composition MealOrder contains parts <code>private Burger burger; private Item drink;</code> Encapsulation Hidden creation details MealOrder constructor creates parts internally Polymorphism Different pricing behavior <code>getExtraPrice()</code> returns 0 for DeluxeBurger Method Overriding Customized behavior <code>Burger.getAdjustedPrice()</code> adds toppings Method Overloading Multiple versions <code>addToppings(3 params)</code> vs <code>addToppings(5 params)</code> Pattern Matching Type checking + casting <code>if (burger instanceof DeluxeBurger db)</code>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#relationship-diagram","title":"Relationship Diagram","text":"<pre><code>flowchart TB\n    subgraph inheritance[\" INHERITANCE \"]\n        I[Item] --&gt; B[Burger]\n        B --&gt; D[DeluxeBurger]\n    end\n\n    subgraph composition[\" COMPOSITION \"]\n        MO[MealOrder]\n        MO -.contains.-&gt; BG[Burger]\n        MO -.contains.-&gt; DR[Drink Item]\n        MO -.contains.-&gt; SD[Side Item]\n        BG -.contains.-&gt; T1[Topping 1]\n        BG -.contains.-&gt; T2[Topping 2]\n        BG -.contains.-&gt; T3[Topping 3]\n    end</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#key-takeaways","title":"Key Takeaways","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#what-makes-this-challenge-complete","title":"What Makes This Challenge Complete","text":"<ol> <li>Real-world modeling: Restaurant ordering system with realistic requirements</li> <li>Multiple OOP patterns: Not just inheritance - composition, encapsulation, polymorphism</li> <li>Extensibility: Easy to add new burger types, toppings, or menu items</li> <li>Encapsulation: Calling code only interacts with <code>MealOrder</code> - doesn't need to know about <code>Item</code> or <code>Burger</code> internals</li> </ol>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#design-decisions-explained","title":"Design Decisions Explained","text":"<ul> <li>Why <code>Item</code> as base class? Everything on the menu has name, type, price</li> <li>Why composition for <code>MealOrder</code>? A meal HAS-A burger, drink, side (not IS-A)</li> <li>Why override <code>getExtraPrice()</code>? Different pricing rules for deluxe burgers</li> <li>Why <code>instanceof</code> check? Deluxe meals have special total price calculation</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-challenges/#related-notes","title":"Related Notes","text":"Part Topic Link 1 Classes, Objects &amp; Encapsulation Part 1 2 Inheritance &amp; Method Overriding Part 2 3 Strings &amp; StringBuilder Part 3 4 Composition Part 4 5 Encapsulation (Advanced) Part 5 6 Polymorphism Part 6 <p>Last Updated: 2026-01-26</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/","title":"Topic Note Part 2: Inheritance","text":"<p>Course: Java Programming Masterclass - Tim Buchalka (Udemy) Section: 07. Mastering Java OOP Classes &amp; Inheritance Status:  Complete</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#learning-objectives","title":"Learning Objectives","text":"<ul> <li> Understand the concept of inheritance and its purpose</li> <li> Use the <code>extends</code> keyword to create subclasses</li> <li> Master the <code>super</code> keyword for accessing parent class members</li> <li> Understand and implement method overriding</li> <li> Know the difference between <code>this</code> and <code>super</code> keywords</li> <li> Understand <code>java.lang.Object</code> as the root of all classes</li> <li> Distinguish between method overloading and method overriding</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#what-is-inheritance","title":"What is Inheritance?","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#definition","title":"Definition","text":"<p>Inheritance is a mechanism where a new class (child/subclass) acquires the properties and behaviors of an existing class (parent/superclass). It enables:</p> <ul> <li>Code reuse - Write once, use in multiple subclasses</li> <li>Hierarchical organization - Model \"is-a\" relationships</li> <li>Polymorphism - Treat subclasses as their parent type</li> </ul> <pre><code>graph TD\n    A[Animal] --&gt; B[Dog]\n    A --&gt; C[Fish]\n    A --&gt; D[Bird]\n\n    subgraph \"Inheritance Relationship\"\n        E[\"Dog IS-A Animal\"]\n        F[\"Fish IS-A Animal\"]\n    end</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#the-extends-keyword","title":"The <code>extends</code> Keyword","text":"<p>Use <code>extends</code> to declare that a class inherits from another:</p> <pre><code>public class Animal {\n    protected String type;\n    private String size;\n    private double weight;\n\n    public void move(String speed) {\n        System.out.println(type + \" moves \" + speed);\n    }\n\n    public void makeNoise() {\n        System.out.println(type + \" makes noise\");\n    }\n}\n\npublic class Dog extends Animal {\n    // Dog inherits all non-private members from Animal\n    private String earShape;\n    private String tailShape;\n\n    // Dog-specific methods\n    private void bark() {\n        System.out.println(\"Woof!\");\n    }\n}\n</code></pre> <p>Single Inheritance</p> <p>Java only supports single inheritance for classes. A class can extend only ONE other class: <pre><code>public class Dog extends Animal { }       // \u2705 Valid\npublic class Dog extends Animal, Pet { }  // \u274c Invalid - can't extend multiple classes\n</code></pre></p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#class-hierarchy","title":"Class Hierarchy","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#terminology","title":"Terminology","text":"Term Definition Example Superclass (Parent, Base) The class being extended <code>Animal</code> Subclass (Child, Derived) The class that extends <code>Dog</code> Inheritance tree Chain of parent-child relationships Object \u2192 Animal \u2192 Dog"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#what-gets-inherited","title":"What Gets Inherited?","text":"Member Type Inherited? Notes <code>public</code> members \u2705 Fully accessible <code>protected</code> members \u2705 Accessible in subclass and same package Package-private (no modifier) \u2705 Only if same package <code>private</code> members \u274c Not directly accessible Constructors \u274c Not inherited, but can be called via <code>super()</code> <p>The <code>protected</code> Access Modifier</p> <p>Use <code>protected</code> when you want subclasses to have direct access to a field or method: <pre><code>public class Animal {\n    protected String type;  // Subclasses can access directly\n    private double weight;  // Only accessible within Animal\n}\n\npublic class Dog extends Animal {\n    public void describe() {\n        System.out.println(type);   // \u2705 Works - protected\n        System.out.println(weight); // \u274c Error - private\n    }\n}\n</code></pre></p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#the-super-keyword","title":"The <code>super</code> Keyword","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#calling-the-parent-constructor","title":"Calling the Parent Constructor","text":"<p>Every subclass constructor must call a parent constructor. Use <code>super()</code> to do this explicitly:</p> <pre><code>public class Dog extends Animal {\n\n    public Dog() {\n        super(\"Mutt\", \"Big\", 50);  // Calls Animal(String, String, double)\n    }\n\n    public Dog(String type, double weight) {\n        super(type, \n              weight &lt; 15 ? \"small\" : (weight &lt; 35 ? \"medium\" : \"large\"),\n              weight);\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#critical-rules-for-super","title":"Critical Rules for <code>super()</code>","text":"Rule Explanation Must be first statement No code can come before <code>super()</code> Only in constructors Can't use <code>super()</code> in regular methods Implicitly added If you don't call <code>super()</code>, Java adds <code>super()</code> (no-args) Parent needs no-args constructor If parent doesn't have one and you don't call <code>super(args)</code>, compile error <pre><code>flowchart TD\n    A[new Dog] --&gt; B{Does Dog constructor call super?}\n    B --&gt;|Yes| C[Execute specified parent constructor]\n    B --&gt;|No| D{Does Animal have no-args constructor?}\n    D --&gt;|Yes| E[Java implicitly adds super]\n    D --&gt;|No| F[Compile Error]</code></pre> <p>Common Error</p> <p>If your parent class only has parameterized constructors, you MUST call <code>super(args)</code> in every child constructor: <pre><code>public class Animal {\n    public Animal(String type) { }  // No no-args constructor\n}\n\npublic class Dog extends Animal {\n    public Dog() {\n        // \u274c Error: No default constructor in Animal\n    }\n\n    public Dog(String type) {\n        super(type);  // \u2705 Must explicitly call parent constructor\n    }\n}\n</code></pre></p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#accessing-parent-members-with-super","title":"Accessing Parent Members with <code>super</code>","text":"<p>Use <code>super.</code> (with dot notation) to access parent class members:</p> <pre><code>public class Dog extends Animal {\n\n    @Override\n    public String toString() {\n        // Call parent's toString() and add our fields\n        return \"Dog{earShape='\" + earShape + \"'} \" + super.toString();\n    }\n\n    @Override\n    public void move(String speed) {\n        super.move(speed);  // Execute parent's move method first\n        // Then add dog-specific behavior\n        if (speed.equals(\"slow\")) {\n            walk();\n            wagTail();\n        } else {\n            run();\n            bark();\n        }\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#the-this-vs-super-keywords","title":"The <code>this</code> vs <code>super</code> Keywords","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#comparison-table","title":"Comparison Table","text":"Aspect <code>this</code> <code>super</code> Refers to Current instance Parent class Access members Current class members Parent class members In constructor Calls another constructor in same class Calls parent constructor Must be first Yes (when calling constructor) Yes (when calling constructor) Can coexist Not with <code>super()</code> in same constructor Not with <code>this()</code> in same constructor"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#this-vs-super-calls","title":"<code>this()</code> vs <code>super()</code> Calls","text":"<pre><code>public class Rectangle extends Shape {\n\n    // Constructor 1: Uses this() to chain to Constructor 2\n    public Rectangle() {\n        this(0, 0, 0, 0);  // Calls Constructor 2\n    }\n\n    // Constructor 2: Uses super() to call parent\n    public Rectangle(int x, int y, int width, int height) {\n        super(x, y);  // Calls Shape constructor\n        this.width = width;\n        this.height = height;\n    }\n}\n</code></pre> <p>Cannot Use Both</p> <p>You cannot have both <code>this()</code> and <code>super()</code> in the same constructor - both must be the first statement: <pre><code>public Dog() {\n    this(\"Mutt\", 50);  // \u2705 Calls another Dog constructor\n    super(\"Mutt\", \"Big\", 50);  // \u274c Error: super() not first statement\n}\n</code></pre></p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#method-overriding","title":"Method Overriding","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#what-is-method-overriding","title":"What is Method Overriding?","text":"<p>Method overriding is when a subclass provides its own implementation of a method that's already defined in its parent class.</p> <pre><code>public class Animal {\n    public void makeNoise() {\n        System.out.println(\"Some generic noise\");\n    }\n}\n\npublic class Dog extends Animal {\n    @Override\n    public void makeNoise() {\n        System.out.println(\"Woof! Woof!\");  // Different behavior\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#the-override-annotation","title":"The <code>@Override</code> Annotation","text":"<p>The <code>@Override</code> annotation is optional but highly recommended:</p> <pre><code>@Override\npublic void makeNoise() {\n    System.out.println(\"Woof!\");\n}\n</code></pre> <p>Benefits: - Compiler verifies you're actually overriding a parent method - Documents intent to readers - Catches typos in method names - Prevents accidental overloading instead of overriding</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#overriding-rules","title":"Overriding Rules","text":"Requirement Rule Method name Must be identical Parameters Must be identical (same number, types, order) Return type Same or covariant (subclass of parent's return type) Access modifier Same or less restrictive (can't reduce visibility) Exceptions Can throw fewer or narrower exceptions (not more) <pre><code>// Parent class\npublic class Animal {\n    protected Animal reproduce() { ... }\n}\n\n// Valid overrides\npublic class Dog extends Animal {\n    @Override\n    public Dog reproduce() { ... }  // \u2705 Covariant return type + wider access\n}\n\n// Invalid overrides\npublic class Cat extends Animal {\n    @Override\n    private Cat reproduce() { ... }  // \u274c More restrictive access (private &lt; protected)\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#access-modifier-hierarchy","title":"Access Modifier Hierarchy","text":"<p>From most restrictive to least:</p> <pre><code>private  \u2192  (package-private)  \u2192  protected  \u2192  public\n   \u2191                                              \u2191\nMost restrictive                          Least restrictive\n</code></pre> <p>When overriding, you can only move right (less restrictive), never left.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#three-ways-to-override","title":"Three Ways to Override","text":"Approach Description Use Case Replace Completely new implementation Different behavior needed Extend Call <code>super.method()</code> + add code Add to existing behavior Call super only Just call <code>super.method()</code> Rarely useful (redundant) <pre><code>// 1. REPLACE - Completely different behavior\n@Override\npublic void makeNoise() {\n    bark();  // Doesn't call parent's makeNoise\n}\n\n// 2. EXTEND - Add to parent's behavior\n@Override\npublic void move(String speed) {\n    super.move(speed);  // Do what Animal does\n    wagTail();          // Plus dog-specific behavior\n}\n\n// 3. CALL SUPER ONLY - Redundant (avoid)\n@Override\npublic void move(String speed) {\n    super.move(speed);  // Same as not overriding at all\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#the-javalangobject-class","title":"The <code>java.lang.Object</code> Class","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#every-class-extends-object","title":"Every Class Extends Object","text":"<p>In Java, every class implicitly extends <code>java.lang.Object</code>:</p> <pre><code>// These two declarations are equivalent:\npublic class Student { }\npublic class Student extends Object { }\n</code></pre> <pre><code>graph TD\n    Object[\"java.lang.Object\"] --&gt; Animal\n    Object --&gt; String\n    Object --&gt; Student\n    Animal --&gt; Dog\n    Animal --&gt; Fish\n    Student --&gt; PrimarySchoolStudent</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#methods-inherited-from-object","title":"Methods Inherited from Object","text":"<p>Every class automatically has these methods available:</p> Method Purpose <code>toString()</code> Returns string representation of object <code>equals(Object obj)</code> Compares this object with another <code>hashCode()</code> Returns hash code for the object <code>getClass()</code> Returns runtime class of the object <code>clone()</code> Creates and returns a copy of the object <code>finalize()</code> Called by garbage collector (deprecated)"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#default-tostring-behavior","title":"Default <code>toString()</code> Behavior","text":"<p>Without overriding, <code>toString()</code> returns: <pre><code>ClassName@hexHashCode\n</code></pre></p> <pre><code>Student max = new Student(\"Max\", 21);\nSystem.out.println(max);  // Output: Student@65ab7765\n</code></pre> <p>Override it for meaningful output: <pre><code>@Override\npublic String toString() {\n    return name + \" is \" + age + \" years old\";\n}\n\nSystem.out.println(max);  // Output: Max is 21 years old\n</code></pre></p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#inheritance-chain","title":"Inheritance Chain","text":"<p>When you call a method, Java looks up the inheritance tree:</p> <pre><code>class PrimarySchoolStudent extends Student {\n    @Override\n    public String toString() {\n        return parentName + \"'s kid, \" + super.toString();\n    }\n}\n</code></pre> <pre><code>flowchart TD\n    A[\"jimmy.toString()\"] --&gt; B{\"toString() in&lt;br/&gt;PrimarySchoolStudent?\"}\n    B --&gt;|Yes| C[\"Execute it\"]\n    B --&gt;|No| D{\"toString() in&lt;br/&gt;Student?\"}\n    D --&gt;|Yes| E[\"Execute it\"]\n    D --&gt;|No| F{\"toString() in&lt;br/&gt;Object?\"}\n    F --&gt;|Always Yes| G[\"Execute Object's toString()\"]</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#method-overloading-vs-overriding","title":"Method Overloading vs. Overriding","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#side-by-side-comparison","title":"Side-by-Side Comparison","text":"Aspect Overloading Overriding Definition Same method name, different parameters Same method name AND parameters Where Usually same class (can be in subclass) Always in subclass Parameters Must be different Must be same Return type Can be different Same or covariant Access Can be different Same or less restrictive Static methods Can be overloaded Cannot be overridden Binding Compile-time (static) Runtime (dynamic) Also called Compile-time polymorphism Runtime polymorphism"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#visual-comparison","title":"Visual Comparison","text":"<pre><code>// OVERLOADING - Same class, different parameters\npublic class Calculator {\n    public int add(int a, int b) { return a + b; }\n    public int add(int a, int b, int c) { return a + b + c; }\n    public double add(double a, double b) { return a + b; }\n}\n\n// OVERRIDING - Different classes, same signature\npublic class Animal {\n    public void speak() { System.out.println(\"...\"); }\n}\n\npublic class Dog extends Animal {\n    @Override\n    public void speak() { System.out.println(\"Woof!\"); }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#complete-inheritance-example","title":"Complete Inheritance Example","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#animal-hierarchy","title":"Animal Hierarchy","text":"<pre><code>// Base class\npublic class Animal {\n    protected String type;\n    private String size;\n    private double weight;\n\n    public Animal(String type, String size, double weight) {\n        this.type = type;\n        this.size = size;\n        this.weight = weight;\n    }\n\n    public void move(String speed) {\n        System.out.println(type + \" moves \" + speed);\n    }\n\n    public void makeNoise() {\n        System.out.println(type + \" makes noise\");\n    }\n\n    @Override\n    public String toString() {\n        return \"Animal{type='\" + type + \"', size='\" + size + \n               \"', weight=\" + weight + \"}\";\n    }\n}\n\n// Subclass with specialized behavior\npublic class Dog extends Animal {\n    private String earShape;\n    private String tailShape;\n\n    public Dog(String type, double weight, String earShape, String tailShape) {\n        super(type, \n              weight &lt; 15 ? \"small\" : (weight &lt; 35 ? \"medium\" : \"large\"),\n              weight);\n        this.earShape = earShape;\n        this.tailShape = tailShape;\n    }\n\n    @Override\n    public void makeNoise() {\n        if (type.equals(\"Wolf\")) {\n            System.out.print(\"Howl! \");\n        }\n        bark();\n    }\n\n    @Override\n    public void move(String speed) {\n        super.move(speed);  // Call parent's move first\n        if (speed.equals(\"slow\")) {\n            walk();\n            wagTail();\n        } else {\n            run();\n            bark();\n        }\n    }\n\n    private void bark() { System.out.println(\"Woof!\"); }\n    private void run() { System.out.println(\"Dog running\"); }\n    private void walk() { System.out.println(\"Dog walking\"); }\n    private void wagTail() { System.out.println(\"Tail wagging\"); }\n\n    @Override\n    public String toString() {\n        return \"Dog{earShape='\" + earShape + \"', tailShape='\" + tailShape + \n               \"'} \" + super.toString();\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#using-polymorphism","title":"Using Polymorphism","text":"<pre><code>public class Main {\n    public static void main(String[] args) {\n        // Can pass any Animal subclass to this method\n        doAnimalStuff(new Animal(\"Generic\", \"Large\", 400));\n        doAnimalStuff(new Dog(\"Labrador\", 65, \"Floppy\", \"Swimmer\"));\n        doAnimalStuff(new Fish(\"Goldfish\", 0.25, 2, 3));\n    }\n\n    public static void doAnimalStuff(Animal animal) {\n        animal.makeNoise();  // Calls appropriate overridden method\n        animal.move(\"fast\"); // Polymorphic behavior\n        System.out.println(animal);\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#key-insights-best-practices","title":"Key Insights &amp; Best Practices","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#dos","title":"Do's \u2705","text":"<ol> <li>Use <code>@Override</code> annotation - Always mark overridden methods</li> <li>Call super constructor - Explicitly when parent has no no-args constructor</li> <li>Use <code>protected</code> wisely - When subclasses need direct access</li> <li>Override <code>toString()</code> - For meaningful object representation</li> <li>Use constructor chaining - Reduce code duplication</li> </ol>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#donts","title":"Don'ts \u274c","text":"<ol> <li>Don't call overridable methods from constructors - Can cause unexpected behavior</li> <li>Don't reduce access modifier - public \u2192 protected \u2192 private is not allowed</li> <li>Don't confuse overloading with overriding - Parameters make the difference</li> <li>Don't forget <code>super(args)</code> - When parent has no default constructor</li> </ol>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#quick-reference","title":"Quick Reference","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#inheritance-syntax","title":"Inheritance Syntax","text":"<pre><code>public class ChildClass extends ParentClass {\n\n    // Constructor must call parent constructor\n    public ChildClass(/* params */) {\n        super(/* parent params */);  // MUST be first statement\n        // ... child-specific initialization\n    }\n\n    // Override parent method\n    @Override\n    public ReturnType methodName(/* same params as parent */) {\n        super.methodName(/* args */);  // Optional - call parent's version\n        // ... child-specific behavior\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#questions-explored","title":"Questions Explored","text":"<ul> <li> What is inheritance and why is it useful?</li> <li> How do I create a subclass in Java?</li> <li> What's the difference between <code>this</code> and <code>super</code>?</li> <li> When and how do I override methods?</li> <li> What is <code>java.lang.Object</code> and why does it matter?</li> <li> What's the difference between overloading and overriding?</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part2/#related-notes","title":"Related Notes","text":"Part Topic Link 1 Classes, Objects &amp; Encapsulation \u2190 Part 1 2 Inheritance &amp; Method Overriding You are here 3 Strings &amp; StringBuilder Part 3 \u2192 4 Composition Part 4 \u2192 5 Encapsulation (Advanced) Part 5 \u2192 6 Polymorphism Part 6 \u2192 <p>Last Updated: 2026-01-26</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/","title":"Topic Note Part 3: Strings &amp; StringBuilder","text":"<p>Course: Java Programming Masterclass - Tim Buchalka (Udemy) Section: 07. Mastering Java OOP Classes &amp; Inheritance Status:  Complete</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#learning-objectives","title":"Learning Objectives","text":"<ul> <li> Master Text Blocks for multi-line strings (JDK 15+)</li> <li> Understand escape sequences and format specifiers</li> <li> Use <code>printf()</code> and <code>String.format()</code> for formatted output</li> <li> Apply String inspection methods (length, charAt, indexOf)</li> <li> Use String comparison methods (equals, contains, startsWith)</li> <li> Perform String manipulation (substring, replace, join)</li> <li> Understand StringBuilder for mutable string operations</li> <li> Know when to use String vs StringBuilder</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#text-blocks-jdk-15","title":"Text Blocks (JDK 15+)","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#what-is-a-text-block","title":"What is a Text Block?","text":"<p>A Text Block is a multi-line string literal introduced in Java 15. It eliminates the need for escape sequences and concatenation when working with multi-line text.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#traditional-vs-text-block","title":"Traditional vs Text Block","text":"<pre><code>// Traditional approach - messy with escape sequences\nString bulletIt = \"Print a Bulleted List:\\n\" +\n        \"\\t\\u2022 First Point\\n\" +\n        \"\\t\\t\\u2022 Sub Point\";\n\n// Text Block approach - clean and readable\nString textBlock = \"\"\"\n        Print a Bulleted List:\n              \u2022 First Point\n                  \u2022 Sub Point\n        \"\"\";\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#text-block-rules","title":"Text Block Rules","text":"Rule Description Opening delimiter Must be <code>\"\"\"</code> followed by a newline Closing delimiter <code>\"\"\"</code> on its own line or at end of content Whitespace Leading whitespace relative to closing <code>\"\"\"</code> is preserved Line breaks Natural line breaks are included automatically <p>Incidental Whitespace</p> <p>The position of the closing <code>\"\"\"</code> determines the base indentation. All whitespace to the left of it is removed from each line.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#escape-sequences","title":"Escape Sequences","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#common-escape-sequences","title":"Common Escape Sequences","text":"<p>Use these special character combinations within strings:</p> Escape Sequence Description Example Output <code>\\n</code> Newline Next line <code>\\t</code> Tab Horizontal spacing <code>\\\"</code> Double quote <code>\"</code> <code>\\\\</code> Backslash <code>\\</code> <code>\\uXXXX</code> Unicode character <code>\\u2022</code> \u2192 \u2022 (bullet) <pre><code>String formatted = \"Line 1\\n\\tIndented line 2\\n\\\"Quoted\\\"\";\n// Output:\n// Line 1\n//     Indented line 2\n// \"Quoted\"\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#printf-and-format-specifiers","title":"printf() and Format Specifiers","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#the-printf-method","title":"The <code>printf()</code> Method","text":"<p><code>System.out.printf()</code> provides C-style formatted output:</p> <pre><code>int age = 35;\nint yearOfBirth = 2023 - age;\n\nSystem.out.printf(\"Your age is %d%n\", age);\nSystem.out.printf(\"Age = %d, Birth year = %d%n\", age, yearOfBirth);\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#common-format-specifiers","title":"Common Format Specifiers","text":"Specifier Type Example <code>%d</code> Decimal integer <code>35</code> <code>%f</code> Floating point <code>35.000000</code> <code>%.2f</code> Float with 2 decimals <code>35.00</code> <code>%s</code> String <code>\"Hello\"</code> <code>%c</code> Character <code>'H'</code> <code>%n</code> Platform-specific newline (newline) <code>%6d</code> Integer with width 6 <code>35</code>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#format-specifier-structure","title":"Format Specifier Structure","text":"<pre><code>%[flags][width][.precision]conversion\n</code></pre> <pre><code>// Width: right-align numbers in 6-character field\nfor (int i = 1; i &lt;= 100000; i *= 10) {\n    System.out.printf(\"Number: %6d%n\", i);\n}\n// Output:\n// Number:      1\n// Number:     10\n// Number:    100\n// Number:   1000\n// Number:  10000\n// Number: 100000\n\n// Precision: limit decimal places\nSystem.out.printf(\"Price: %.2f%n\", 19.99);  // Price: 19.99\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#string-formatting-methods","title":"String Formatting Methods","text":"<p>Three ways to format strings:</p> <pre><code>int age = 35;\n\n// 1. printf - prints directly to console\nSystem.out.printf(\"Your age is %d%n\", age);\n\n// 2. String.format() - static method, returns formatted string\nString formatted = String.format(\"Your age is %d\", age);\n\n// 3. formatted() - instance method on String (JDK 15+)\nString formatted = \"Your age is %d\".formatted(age);\n</code></pre> <p>Prefer <code>%n</code> over <code>\\\\n</code></p> <p><code>%n</code> produces the platform-specific line separator (works on Windows, Mac, Linux), while <code>\\n</code> always produces the Unix newline which may not display correctly on all platforms.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#string-inspection-methods","title":"String Inspection Methods","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#strings-as-character-sequences","title":"Strings as Character Sequences","text":"<p>Strings are indexed sequences of characters starting at index 0:</p> <pre><code>Index:      0   1   2   3   4   5   6   7   8   9   10\nCharacter:  H   e   l   l   o       W   o   r   l   d\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#key-inspection-methods","title":"Key Inspection Methods","text":"Method Returns Description <code>length()</code> <code>int</code> Number of characters <code>charAt(int)</code> <code>char</code> Character at specified index <code>indexOf(char/String)</code> <code>int</code> First occurrence position (-1 if not found) <code>lastIndexOf(char/String)</code> <code>int</code> Last occurrence position <code>isEmpty()</code> <code>boolean</code> True if length is 0 <code>isBlank()</code> <code>boolean</code> True if empty or only whitespace"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#code-examples","title":"Code Examples","text":"<pre><code>String str = \"Hello World\";\n\n// Length and character access\nSystem.out.println(str.length());      // 11\nSystem.out.println(str.charAt(0));     // H\nSystem.out.println(str.charAt(10));    // d (last character)\n\n// Finding positions\nSystem.out.println(str.indexOf('W'));        // 6\nSystem.out.println(str.indexOf(\"World\"));    // 6\nSystem.out.println(str.indexOf('l'));        // 2 (first 'l')\nSystem.out.println(str.lastIndexOf('l'));    // 9 (last 'l')\n\n// Search from specific position\nSystem.out.println(str.indexOf('l', 3));     // 3 (find 'l' starting at index 3)\nSystem.out.println(str.lastIndexOf('l', 8)); // 3 (find 'l' backwards from index 8)\n\n// Empty vs Blank\nString empty = \"\";\nString blank = \"   \\t\\n\";\nSystem.out.println(empty.isEmpty());   // true\nSystem.out.println(empty.isBlank());   // true\nSystem.out.println(blank.isEmpty());   // false (has characters)\nSystem.out.println(blank.isBlank());   // true (only whitespace)\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#print-information-helper","title":"Print Information Helper","text":"<pre><code>public static void printInformation(String string) {\n    int length = string.length();\n    System.out.printf(\"Length = %d%n\", length);\n\n    if (string.isEmpty()) {\n        System.out.println(\"String is Empty\");\n        return;\n    }\n\n    if (string.isBlank()) {\n        System.out.println(\"String is Blank\");\n    }\n\n    System.out.printf(\"First char = %c%n\", string.charAt(0));\n    System.out.printf(\"Last char = %c%n\", string.charAt(length - 1));\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#string-comparison-methods","title":"String Comparison Methods","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#comparison-methods-overview","title":"Comparison Methods Overview","text":"Method Description <code>equals(Object)</code> Exact match (case-sensitive) <code>equalsIgnoreCase(String)</code> Match ignoring case <code>contentEquals(CharSequence)</code> Content match (works with StringBuilder) <code>contains(CharSequence)</code> True if string contains substring <code>startsWith(String)</code> True if string starts with prefix <code>endsWith(String)</code> True if string ends with suffix"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#code-examples_1","title":"Code Examples","text":"<pre><code>String helloWorld = \"Hello World\";\nString helloWorldLower = helloWorld.toLowerCase();\n\n// Equality checks\nif (helloWorld.equals(helloWorldLower)) {\n    System.out.println(\"Values match exactly\");  // Won't print\n}\n\nif (helloWorld.equalsIgnoreCase(helloWorldLower)) {\n    System.out.println(\"Values match ignoring case\");  // Prints\n}\n\n// Substring checks\nif (helloWorld.startsWith(\"Hello\")) {\n    System.out.println(\"String starts with Hello\");\n}\n\nif (helloWorld.endsWith(\"World\")) {\n    System.out.println(\"String ends with World\");\n}\n\nif (helloWorld.contains(\"llo Wo\")) {\n    System.out.println(\"String contains 'llo Wo'\");\n}\n</code></pre> <p>equals() vs ==</p> <p>Always use <code>.equals()</code> for String comparison, not <code>==</code>: <pre><code>String a = new String(\"Hello\");\nString b = new String(\"Hello\");\n\nSystem.out.println(a == b);       // false (different objects)\nSystem.out.println(a.equals(b));  // true (same content)\n</code></pre></p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#string-manipulation-methods","title":"String Manipulation Methods","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#two-types-of-manipulation","title":"Two Types of Manipulation","text":"<ol> <li>Cleanup methods - Don't change meaning (trim, case changes)</li> <li>Transformation methods - Create different text values</li> </ol>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#cleanup-methods","title":"Cleanup Methods","text":"Method Description <code>trim()</code> Removes leading/trailing whitespace <code>strip()</code> Unicode-aware trim (JDK 11+) <code>toLowerCase()</code> Converts to lowercase <code>toUpperCase()</code> Converts to uppercase <code>indent(int)</code> Adjusts indentation of each line (JDK 15+)"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#transformation-methods","title":"Transformation Methods","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#substring-extract-parts","title":"substring() - Extract Parts","text":"<pre><code>String birthDate = \"25/11/1982\";\n\n// Get year (from index 6 to end)\nString year = birthDate.substring(6);  // \"1982\"\n\n// Get month (from index 3 to 5, exclusive)\nString month = birthDate.substring(3, 5);  // \"11\"\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#join-combine-strings","title":"join() - Combine Strings","text":"<pre><code>// Static method - joins with delimiter\nString date = String.join(\"/\", \"25\", \"11\", \"1982\");\n// Result: \"25/11/1982\"\n\nString csv = String.join(\", \", \"Apple\", \"Banana\", \"Orange\");\n// Result: \"Apple, Banana, Orange\"\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#concat-append-strings","title":"concat() - Append Strings","text":"<pre><code>String date = \"25\";\ndate = date.concat(\"/\");\ndate = date.concat(\"11\");\n// Result: \"25/11\"\n\n// Method chaining (but inefficient!)\ndate = \"25\".concat(\"/\").concat(\"11\").concat(\"/\").concat(\"1982\");\n</code></pre> <p>Avoid Multiple concat() Calls</p> <p>Each <code>concat()</code> creates a new String object. Use <code>+</code> operator with literals or StringBuilder instead: <pre><code>// Better - compiler optimizes this\nString date = \"25\" + \"/\" + \"11\" + \"/\" + \"1982\";\n</code></pre></p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#replace-methods","title":"replace() Methods","text":"Method Description <code>replace(char, char)</code> Replace all occurrences of character <code>replace(String, String)</code> Replace all occurrences of string <code>replaceFirst(String, String)</code> Replace first occurrence only <code>replaceAll(String, String)</code> Replace using regex pattern <pre><code>String date = \"25/11/1982\";\n\nSystem.out.println(date.replace('/', '-'));     // \"25-11-1982\"\nSystem.out.println(date.replace(\"2\", \"00\"));    // \"005/11/1900\"\nSystem.out.println(date.replaceFirst(\"/\", \"--\")); // \"25--11/1982\"\nSystem.out.println(date.replaceAll(\"/\", \"---\")); // \"25---11---1982\"\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#repeat-and-indent-jdk-1115","title":"repeat() and indent() (JDK 11+/15+)","text":"<pre><code>// Repeat a string\nString line = \"-\".repeat(20);  // \"--------------------\"\n\nString abc = \"ABC\\n\".repeat(3);\n// \"ABC\n//  ABC\n//  ABC\"\n\n// Adjust indentation\nString indented = \"ABC\\n\".repeat(3).indent(4);  // Add 4 spaces to each line\nString outdented = \"    ABC\\n\".repeat(3).indent(-2);  // Remove 2 spaces from each line\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#stringbuilder-mutable-strings","title":"StringBuilder - Mutable Strings","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#why-stringbuilder","title":"Why StringBuilder?","text":"<p>String is immutable - every modification creates a new object:</p> <pre><code>String s = \"Hello\";\ns = s.concat(\" World\");  // Creates NEW string, old one becomes garbage\n</code></pre> <p>StringBuilder is mutable - modifications happen in-place:</p> <pre><code>StringBuilder sb = new StringBuilder(\"Hello\");\nsb.append(\" World\");  // Modifies SAME object\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#creating-stringbuilder","title":"Creating StringBuilder","text":"<pre><code>// Four constructors\nStringBuilder sb1 = new StringBuilder();              // Empty, capacity 16\nStringBuilder sb2 = new StringBuilder(32);            // Empty, capacity 32\nStringBuilder sb3 = new StringBuilder(\"Hello\");       // With initial value\nStringBuilder sb4 = new StringBuilder(anotherStringBuilder);\n</code></pre> <p>Capacity vs Length</p> <ul> <li>Length = actual number of characters</li> <li>Capacity = allocated space (can grow automatically)</li> </ul> <pre><code>StringBuilder sb = new StringBuilder();\nSystem.out.println(sb.length());    // 0\nSystem.out.println(sb.capacity());  // 16 (default)\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#string-vs-stringbuilder-comparison","title":"String vs StringBuilder Comparison","text":"<pre><code>// String - immutable\nString helloWorld = \"Hello\" + \" World\";\nhelloWorld.concat(\" and Goodbye\");  // MISTAKE: result not assigned!\nSystem.out.println(helloWorld);     // Still \"Hello World\"\n\n// StringBuilder - mutable  \nStringBuilder builder = new StringBuilder(\"Hello World\");\nbuilder.append(\" and Goodbye\");     // Modifies builder directly\nSystem.out.println(builder);        // \"Hello World and Goodbye\"\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#stringbuilder-methods","title":"StringBuilder Methods","text":"Method Description <code>append(...)</code> Add to end (many overloaded versions) <code>insert(int, ...)</code> Insert at specified position <code>delete(int, int)</code> Delete from start to end index <code>deleteCharAt(int)</code> Delete character at index <code>replace(int, int, String)</code> Replace range with string <code>reverse()</code> Reverse all characters <code>setLength(int)</code> Truncate or extend (with nulls) <code>toString()</code> Convert to String"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#code-examples_2","title":"Code Examples","text":"<pre><code>StringBuilder builder = new StringBuilder(\"Hello World and Goodbye\");\n\n// Delete and Insert\nbuilder.deleteCharAt(16);  // Remove 'G' at index 16\nbuilder.insert(16, \"g\");   // Insert lowercase 'g'\n\n// Can chain methods (returns self-reference!)\nbuilder.deleteCharAt(16).insert(16, \"g\");\n\n// Replace (different from String.replace!)\nbuilder.replace(16, 17, \"G\");  // Replace character at index 16-17\n\n// Reverse and truncate\nbuilder.reverse().setLength(7);\nSystem.out.println(builder);  // \"eybdooG\" (Goodbye reversed)\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#method-chaining","title":"Method Chaining","text":"<p>StringBuilder methods return <code>this</code>, enabling chaining:</p> <pre><code>StringBuilder sb = new StringBuilder()\n    .append(\"Hello\")\n    .append(\" \")\n    .append(\"World\")\n    .insert(0, \"Say: \")\n    .append(\"!\");\n\nSystem.out.println(sb);  // \"Say: Hello World!\"\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#when-to-use-what","title":"When to Use What?","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#string-vs-stringbuilder-decision-guide","title":"String vs StringBuilder Decision Guide","text":"Scenario Use Why Simple text <code>String</code> Immutable, safe, optimized Concatenating literals <code>String</code> with <code>+</code> Compiler optimizes Building text in loops <code>StringBuilder</code> Avoids creating many objects Many modifications <code>StringBuilder</code> Mutable, efficient Thread-safe needed <code>StringBuffer</code> Synchronized (slower) API return value <code>String</code> Standard convention"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#performance-example","title":"Performance Example","text":"<pre><code>// BAD - creates many String objects\nString result = \"\";\nfor (int i = 0; i &lt; 1000; i++) {\n    result = result + i + \", \";  // New String each iteration!\n}\n\n// GOOD - modifies single StringBuilder\nStringBuilder sb = new StringBuilder();\nfor (int i = 0; i &lt; 1000; i++) {\n    sb.append(i).append(\", \");\n}\nString result = sb.toString();\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#complete-examples","title":"Complete Examples","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#string-information-method","title":"String Information Method","text":"<pre><code>public static void printInformation(String string) {\n    int length = string.length();\n    System.out.printf(\"Length = %d%n\", length);\n\n    if (string.isEmpty()) {\n        System.out.println(\"String is Empty\");\n        return;\n    }\n\n    if (string.isBlank()) {\n        System.out.println(\"String is Blank\");\n    }\n\n    System.out.printf(\"First char = %c%n\", string.charAt(0));\n    System.out.printf(\"Last char = %c%n\", string.charAt(length - 1));\n}\n\npublic static void printInformation(StringBuilder builder) {\n    System.out.println(\"StringBuilder = \" + builder);\n    System.out.println(\"Length = \" + builder.length());\n    System.out.println(\"Capacity = \" + builder.capacity());\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#date-manipulation-example","title":"Date Manipulation Example","text":"<pre><code>String birthDate = \"25/11/1982\";\n\n// Extract year\nint yearIndex = birthDate.indexOf(\"1982\");\nString year = birthDate.substring(yearIndex);  // \"1982\"\n\n// Extract month\nString month = birthDate.substring(3, 5);  // \"11\"\n\n// Rebuild with different format\nString newDate = String.join(\"-\", \"1982\", \"11\", \"25\");  // \"1982-11-25\"\n\n// Replace separators\nString dashes = birthDate.replace('/', '-');  // \"25-11-1982\"\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#quick-reference","title":"Quick Reference","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#format-specifier-cheat-sheet","title":"Format Specifier Cheat Sheet","text":"<pre><code>%d  = integer\n%f  = floating point\n%s  = string\n%c  = character\n%n  = newline\n%6d = width 6, right-aligned\n%.2f = 2 decimal places\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#string-vs-stringbuilder","title":"String vs StringBuilder","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     Aspect      \u2502      String        \u2502   StringBuilder    \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 Mutability      \u2502 Immutable          \u2502 Mutable            \u2502\n\u2502 Thread Safety   \u2502 Yes (immutable)    \u2502 No                 \u2502\n\u2502 Performance     \u2502 New object on mod  \u2502 Same object        \u2502\n\u2502 Literal support \u2502 Yes (\"hello\")      \u2502 No (use new)       \u2502\n\u2502 Main methods    \u2502 concat, replace    \u2502 append, insert     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#questions-explored","title":"Questions Explored","text":"<ul> <li> How do I create multi-line strings easily?</li> <li> What are format specifiers and how do I use printf?</li> <li> How do I inspect and compare strings?</li> <li> How do I manipulate string content?</li> <li> What is StringBuilder and when should I use it?</li> <li> What's the difference between String and StringBuilder?</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part3/#related-notes","title":"Related Notes","text":"Part Topic Link 1 Classes, Objects &amp; Encapsulation \u2190 Part 1 2 Inheritance &amp; Method Overriding \u2190 Part 2 3 Strings &amp; StringBuilder You are here 4 Composition Part 4 \u2192 5 Encapsulation (Advanced) Part 5 \u2192 6 Polymorphism Part 6 \u2192 <p>Last Updated: 2026-01-26</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/","title":"Topic Note Part 4: Composition","text":"<p>Course: Java Programming Masterclass - Tim Buchalka (Udemy) Section: 08. Advanced OOP Techniques Status:  Complete</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#learning-objectives","title":"Learning Objectives","text":"<ul> <li> Understand the difference between IS-A and HAS-A relationships</li> <li> Master Composition as an alternative to Inheritance</li> <li> Learn when to prefer Composition over Inheritance</li> <li> Build complex objects from simpler component parts</li> <li> Implement delegation patterns through composite classes</li> <li> Apply composition in real-world modeling scenarios</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#is-a-vs-has-a-relationships","title":"IS-A vs HAS-A Relationships","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#the-two-fundamental-relationships-in-oop","title":"The Two Fundamental Relationships in OOP","text":"<p>In Object-Oriented Programming, there are two primary ways to relate classes:</p> Relationship Keyword Description Example IS-A <code>extends</code> Inheritance - subclass is a type of parent <code>Dog extends Animal</code> \u2192 Dog IS-A Animal HAS-A field reference Composition - class contains other classes <code>Car has-a Engine</code> \u2192 Car HAS-A Engine <pre><code>flowchart LR\n    subgraph Inheritance\n        direction TB\n        A[Animal] --&gt; B[Dog]\n    end\n    subgraph Composition\n        direction TB\n        C[Car] -.contains.-&gt; D[Engine]\n        C -.contains.-&gt; E[Wheel]\n    end</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#understanding-the-difference","title":"Understanding the Difference","text":"<p>Inheritance (IS-A):</p> <ul> <li>Creates a class hierarchy where subclasses inherit from parents</li> <li>Establishes a \"type-of\" relationship</li> <li>Subclass can be used anywhere parent is expected</li> <li>Example: A <code>Monitor</code> IS-A <code>Product</code></li> </ul> <p>Composition (HAS-A):</p> <ul> <li>Creates objects from other objects as building blocks</li> <li>Establishes a \"contains\" or \"made-up-of\" relationship</li> <li>The containing class delegates work to its components</li> <li>Example: A <code>PersonalComputer</code> HAS-A <code>Monitor</code>, HAS-A <code>Motherboard</code></li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#what-is-composition","title":"What is Composition?","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#definition","title":"Definition","text":"<p>Composition is a design technique where a class is built by combining references to other objects. The composite class (the container) manages its component parts and delegates behavior to them.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#key-characteristics","title":"Key Characteristics","text":"<ol> <li>Contains references to other objects as instance fields</li> <li>Delegates work to component objects</li> <li>Manages lifecycle of its parts (creates, uses, destroys)</li> <li>Hides complexity from external code</li> <li>More flexible than inheritance for many scenarios</li> </ol>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#visual-comparison","title":"Visual Comparison","text":"<pre><code>flowchart TB\n    subgraph inheritance[\" INHERITANCE \"]\n        direction TB\n        P[Product&lt;br&gt;Base Class]\n        P --&gt; M[Monitor]\n        P --&gt; MB[Motherboard]\n        P --&gt; CC[ComputerCase]\n        note1[Each subclass IS-A Product]\n    end</code></pre> <pre><code>flowchart TB\n    subgraph composition[\" COMPOSITION \"]\n        direction TB\n        PC[PersonalComputer&lt;br&gt;Contains parts]\n        PC -.HAS-A.-&gt; M2[Monitor]\n        PC -.HAS-A.-&gt; MB2[Motherboard]\n        PC -.HAS-A.-&gt; CC2[Case]\n        note2[PC HAS-A Monitor, Motherboard, Case]\n    end</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#building-a-computer-with-composition","title":"Building a Computer with Composition","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#the-product-hierarchy-inheritance","title":"The Product Hierarchy (Inheritance)","text":"<p>First, let's establish a base class for computer products:</p> <pre><code>public class Product {\n    private String model;\n    private String manufacturer;\n    private int width;\n    private int height;\n    private int depth;\n\n    public Product(String model, String manufacturer) {\n        this.model = model;\n        this.manufacturer = manufacturer;\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#the-component-parts-subclasses","title":"The Component Parts (Subclasses)","text":"<p>Each computer part IS-A Product with its own specific behavior:</p> <pre><code>class Monitor extends Product {\n    private int size;\n    private String resolution;\n\n    public Monitor(String model, String manufacturer) {\n        super(model, manufacturer);\n    }\n\n    public Monitor(String model, String manufacturer, \n                   int size, String resolution) {\n        super(model, manufacturer);\n        this.size = size;\n        this.resolution = resolution;\n    }\n\n    public void drawPixelAt(int x, int y, String color) {\n        System.out.printf(\"Drawing pixel at %d,%d in color %s%n\", \n                          x, y, color);\n    }\n}\n\nclass Motherboard extends Product {\n    private int ramSlots;\n    private int cardSlots;\n    private String bios;\n\n    public Motherboard(String model, String manufacturer,\n                       int ramSlots, int cardSlots, String bios) {\n        super(model, manufacturer);\n        this.ramSlots = ramSlots;\n        this.cardSlots = cardSlots;\n        this.bios = bios;\n    }\n\n    public void loadProgram(String programName) {\n        System.out.println(\"Program: \" + programName + \" is now loading...\");\n    }\n}\n\nclass ComputerCase extends Product {\n    private String powerSupply;\n\n    public ComputerCase(String model, String manufacturer, \n                        String powerSupply) {\n        super(model, manufacturer);\n        this.powerSupply = powerSupply;\n    }\n\n    public void pressPowerButton() {\n        System.out.println(\"Power button pressed!\");\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#the-composite-class-personalcomputer","title":"The Composite Class (PersonalComputer)","text":"<p>Now, the PersonalComputer uses BOTH inheritance AND composition:</p> <pre><code>public class PersonalComputer extends Product {\n    // COMPOSITION: These are HAS-A relationships\n    private ComputerCase computerCase;\n    private Monitor monitor;\n    private Motherboard motherboard;\n\n    public PersonalComputer(String model, String manufacturer,\n                            ComputerCase computerCase, \n                            Monitor monitor,\n                            Motherboard motherboard) {\n        super(model, manufacturer);  // Inheritance\n        this.computerCase = computerCase;\n        this.monitor = monitor;\n        this.motherboard = motherboard;\n    }\n\n    // Private method - internal behavior\n    private void drawLogo() {\n        monitor.drawPixelAt(1200, 50, \"yellow\");\n    }\n\n    // Public method - delegates to parts\n    public void powerUp() {\n        computerCase.pressPowerButton();\n        drawLogo();\n    }\n}\n</code></pre> <p>Combining Inheritance and Composition</p> <p><code>PersonalComputer</code> IS-A <code>Product</code> (inherits common attributes) AND HAS-A <code>Monitor</code>, <code>Motherboard</code>, and <code>ComputerCase</code>. This is a powerful combination!</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#two-approaches-to-using-composition","title":"Two Approaches to Using Composition","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#approach-1-exposing-components-via-getters","title":"Approach 1: Exposing Components via Getters","text":"<p>The calling code directly accesses parts through getter methods:</p> <pre><code>// With getter methods on PersonalComputer:\npublic ComputerCase getComputerCase() { return computerCase; }\npublic Monitor getMonitor() { return monitor; }\npublic Motherboard getMotherboard() { return motherboard; }\n</code></pre> <pre><code>// Calling code\nPersonalComputer pc = new PersonalComputer(\"2208\", \"Dell\", \n                                          theCase, theMonitor, theMotherboard);\n\n// Direct access through getters - method chaining\npc.getMonitor().drawPixelAt(10, 10, \"red\");\npc.getMotherboard().loadProgram(\"Windows OS\");\npc.getComputerCase().pressPowerButton();\n</code></pre> <p>Disadvantages:</p> <ul> <li>Exposes internal structure</li> <li>Calling code needs to know about parts</li> <li>Changes to parts affect all calling code</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#approach-2-hiding-components-via-delegation-preferred","title":"Approach 2: Hiding Components via Delegation (Preferred)","text":"<p>The composite class provides public methods that delegate to parts:</p> <pre><code>public class PersonalComputer extends Product {\n    private ComputerCase computerCase;\n    private Monitor monitor;\n    private Motherboard motherboard;\n\n    // NO GETTERS - parts are hidden\n\n    // Private method - only PC can draw logo\n    private void drawLogo() {\n        monitor.drawPixelAt(1200, 50, \"yellow\");\n    }\n\n    // Public method - high-level interface\n    public void powerUp() {\n        computerCase.pressPowerButton();\n        drawLogo();\n    }\n}\n</code></pre> <pre><code>// Calling code - much simpler!\nPersonalComputer pc = new PersonalComputer(\"2208\", \"Dell\", \n                                          theCase, theMonitor, theMotherboard);\n\npc.powerUp();  // One method, handles everything\n</code></pre> <p>Advantages:</p> <ul> <li>Parts are encapsulated</li> <li>Calling code doesn't need to know details</li> <li>Changes to parts don't affect calling code</li> <li>Simpler interface (better encapsulation)</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#smart-kitchen-challenge-example","title":"Smart Kitchen Challenge Example","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#the-composite-container","title":"The Composite Container","text":"<pre><code>public class SmartKitchen {\n    private CoffeeMaker brewMaster;\n    private Refrigerator iceBox;\n    private DishWasher dishWasher;\n\n    // No-args constructor creates all appliances\n    public SmartKitchen() {\n        brewMaster = new CoffeeMaker();\n        iceBox = new Refrigerator();\n        dishWasher = new DishWasher();\n    }\n\n    // Method 1: Set state of all appliances\n    public void setKitchenState(boolean coffeeFlag, \n                                 boolean fridgeFlag,\n                                 boolean dishWasherFlag) {\n        brewMaster.setHasWorkToDo(coffeeFlag);\n        iceBox.setHasWorkToDo(fridgeFlag);\n        dishWasher.setHasWorkToDo(dishWasherFlag);\n    }\n\n    // Method 2: Delegate work to all appliances\n    public void doKitchenWork() {\n        brewMaster.brewCoffee();\n        iceBox.orderFood();\n        dishWasher.doDishes();\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#the-component-appliances","title":"The Component Appliances","text":"<pre><code>class CoffeeMaker {\n    private boolean hasWorkToDo;\n\n    public void setHasWorkToDo(boolean hasWorkToDo) {\n        this.hasWorkToDo = hasWorkToDo;\n    }\n\n    public void brewCoffee() {\n        if (hasWorkToDo) {\n            System.out.println(\"Coffee is brewing...\");\n            hasWorkToDo = false;\n        }\n    }\n}\n\nclass Refrigerator {\n    private boolean hasWorkToDo;\n\n    public void setHasWorkToDo(boolean hasWorkToDo) {\n        this.hasWorkToDo = hasWorkToDo;\n    }\n\n    public void orderFood() {\n        if (hasWorkToDo) {\n            System.out.println(\"Ordering Food...\");\n            hasWorkToDo = false;\n        }\n    }\n}\n\nclass DishWasher {\n    private boolean hasWorkToDo;\n\n    public void setHasWorkToDo(boolean hasWorkToDo) {\n        this.hasWorkToDo = hasWorkToDo;\n    }\n\n    public void doDishes() {\n        if (hasWorkToDo) {\n            System.out.println(\"Washing dishes...\");\n            hasWorkToDo = false;\n        }\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#using-the-smart-kitchen","title":"Using the Smart Kitchen","text":"<pre><code>SmartKitchen kitchen = new SmartKitchen();\n\n// Set which appliances have work to do\nkitchen.setKitchenState(true, false, true);  // Coffee &amp; dishes only\n\n// Do all the work - kitchen delegates to parts\nkitchen.doKitchenWork();\n\n// Output:\n// Coffee is brewing...\n// Washing dishes...\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#composition-vs-inheritance","title":"Composition vs Inheritance","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#why-prefer-composition-over-inheritance","title":"Why Prefer Composition Over Inheritance?","text":"Aspect Inheritance Composition Flexibility Less flexible - locked into hierarchy More flexible - can swap parts Coupling Tight coupling between classes Loose coupling - parts are independent Changes Changes cascade to all subclasses Changes isolated to components Reuse Limited to hierarchy Reuse outside class hierarchy Testing Harder to test in isolation Easy to test parts independently Encapsulation May break encapsulation (protected) Preserves encapsulation"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#when-to-use-each","title":"When to Use Each","text":"<pre><code>flowchart TD\n    A{Does it make sense to say&lt;br&gt;X IS-A Y?}\n    A --&gt;|Yes| B{Will subclass use ALL&lt;br&gt;parent functionality?}\n    A --&gt;|No| C[Use Composition]\n    B --&gt;|Yes| D[Consider Inheritance]\n    B --&gt;|No| C\n    D --&gt; E{Is behavior fixed&lt;br&gt;at compile time?}\n    E --&gt;|Yes| F[Inheritance is OK]\n    E --&gt;|No| C</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#the-digital-product-problem","title":"The Digital Product Problem","text":"<p>Consider adding <code>DigitalProduct</code> to a <code>Product</code> hierarchy:</p> <pre><code>public class Product {\n    private String manufacturer;\n    private String model;\n    private int width;    // What about digital products?\n    private int height;   // They don't have dimensions!\n    private int depth;\n}\n\nclass DigitalProduct extends Product {\n    // PROBLEM: Inherits width, height, depth\n    // which makes no sense for software!\n}\n</code></pre> <p>Solution with Composition:</p> <pre><code>// Make Product more generic\npublic class Product {\n    private String manufacturer;\n    private String model;\n}\n\n// Create Dimensions as a component\nclass Dimensions {\n    private int width;\n    private int height;\n    private int depth;\n}\n\n// Physical products USE Dimensions\nclass Motherboard extends Product {\n    private Dimensions dimensions;  // HAS-A dimensions\n}\n\n// Digital products don't need Dimensions\nclass SoftwareProduct extends Product {\n    private String licenseKey;\n    // No Dimensions needed!\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#key-takeaways","title":"Key Takeaways","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#composition-best-practices","title":"Composition Best Practices","text":"<ol> <li>\"Favor composition over inheritance\" - Common OOP design principle</li> <li>Use inheritance for IS-A relationships where subclass truly is a type of parent</li> <li>Use composition for HAS-A relationships where class contains other objects</li> <li>Combine both when appropriate (class inherits AND contains)</li> <li>Hide components when possible - delegate through public methods</li> <li>Create parts internally when they don't need to be configured externally</li> </ol>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#benefits-summary","title":"Benefits Summary","text":"<ul> <li>Flexibility: Add/remove/change parts without affecting hierarchy</li> <li>Reuse: Same components can be used in different composites</li> <li>Encapsulation: Hide complexity behind simple interfaces</li> <li>Maintainability: Changes are localized to components</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part4/#related-notes","title":"Related Notes","text":"Part Topic Link 1 Classes, Objects &amp; Encapsulation \u2190 Part 1 2 Inheritance &amp; Method Overriding \u2190 Part 2 3 Strings &amp; StringBuilder \u2190 Part 3 4 Composition You are here 5 Encapsulation Part 5 \u2192 6 Polymorphism Part 6 \u2192 <p>Last Updated: 2026-01-26</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/","title":"Topic Note Part 5: Encapsulation","text":"<p>Course: Java Programming Masterclass - Tim Buchalka (Udemy) Section: 08. Advanced OOP Techniques Status:  Complete</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#learning-objectives","title":"Learning Objectives","text":"<ul> <li> Understand what encapsulation means and why it matters</li> <li> Learn the three major problems of poor encapsulation</li> <li> Master creating properly encapsulated classes</li> <li> Implement data validation in constructors and setters</li> <li> Apply access modifiers correctly for data protection</li> <li> Decouple internal implementation from public interface</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#what-is-encapsulation","title":"What is Encapsulation?","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#definition","title":"Definition","text":"<p>Encapsulation is the bundling of data (fields) and methods that operate on that data within a single unit (class), while restricting direct access to some of the object's components.</p> <p>In simpler terms: Encapsulation means hiding things by making them private or inaccessible.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#the-three-goals-of-encapsulation","title":"The Three Goals of Encapsulation","text":"<pre><code>flowchart TD\n    E[Encapsulation] --&gt; A[Simplify Interface]\n    E --&gt; B[Protect Data Integrity]\n    E --&gt; C[Decouple Implementation]\n\n    A --&gt; A1[Hide unnecessary details]\n    B --&gt; B1[Control access to data]\n    B --&gt; B2[Validate before changes]\n    C --&gt; C1[Change internals without&lt;br&gt;breaking external code]</code></pre> Goal Description Simplify Interface Hide unnecessary implementation details from users Protect Data Integrity Ensure data is always valid through controlled access Decouple Implementation Allow internal changes without affecting external code"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#the-black-box-concept","title":"The \"Black Box\" Concept","text":"<p>Think of an encapsulated class as a black box:</p> <ul> <li>Users know WHAT it does (public interface)</li> <li>Users don't know/need to know HOW it does it (private implementation)</li> </ul> <pre><code>flowchart TB\n    subgraph blackbox[\" ENCAPSULATED CLASS \"]\n        direction TB\n        subgraph hidden[\"  HIDDEN INTERNALS \"]\n            F1[Private fields]\n            F2[Private methods]\n            F3[Implementation details]\n        end\n\n        subgraph public[\" PUBLIC INTERFACE \"]\n            C[Constructors]\n            PM[Public methods]\n            GS[Getters/Setters&lt;br&gt;if needed]\n        end\n    end\n\n    User([External Code]) --&gt;|calls| public\n    public -.accesses.-&gt; hidden</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#problems-without-encapsulation","title":"Problems Without Encapsulation","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#the-bad-example-player-class","title":"The Bad Example: Player Class","text":"<p>Here's a class that violates encapsulation principles:</p> <pre><code>public class Player {\n    public String name;    // \u26a0\ufe0f PUBLIC - Direct access!\n    public int health;     // \u26a0\ufe0f PUBLIC - No protection!\n    public String weapon;  // \u26a0\ufe0f PUBLIC - Anyone can modify!\n\n    public void loseHealth(int damage) {\n        health = health - damage;\n        if (health &lt;= 0) {\n            System.out.println(\"Player knocked out of game\");\n        }\n    }\n\n    public int healthRemaining() {\n        return health;\n    }\n\n    public void restoreHealth(int extraHealth) {\n        health = health + extraHealth;\n        if (health &gt; 100) {\n            System.out.println(\"Player restored to 100%\");\n            health = 100;\n        }\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#problem-1-bypassing-validation","title":"Problem 1: Bypassing Validation","text":"<pre><code>Player player = new Player();\nplayer.name = \"Tim\";\nplayer.health = 20;\nplayer.weapon = \"sword\";\n\n// ... later in the code ...\n\nplayer.health = 200;  // \u26a0\ufe0f BYPASSED restoreHealth() validation!\n                      // Health should never exceed 100!\n</code></pre> <p>Data Integrity Broken</p> <p>The <code>restoreHealth()</code> method enforces that health never exceeds 100. But because <code>health</code> is public, any code can set it directly, bypassing this rule.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#problem-2-field-renaming-breaks-code","title":"Problem 2: Field Renaming Breaks Code","text":"<p>If you change a field name internally, all external code breaks:</p> <pre><code>// Before: name field\npublic String name;\n\n// After: changed to fullName\npublic String fullName;  // \u26a0\ufe0f All code using \"player.name\" now fails!\n</code></pre> <pre><code>// External code that was working...\nplayer.name = \"Tim\";\n\n// ...now fails with compile error:\n// \"Cannot resolve symbol 'name'\"\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#problem-3-no-guaranteed-initialization","title":"Problem 3: No Guaranteed Initialization","text":"<p>Without constructors, calling code must manually initialize:</p> <pre><code>Player player = new Player();\n// Forgot to set health!\nplayer.name = \"Tim\";\nplayer.weapon = \"sword\";\n\n// health is 0 (default) - player is dead before game starts!\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#the-encapsulated-solution-enhancedplayer","title":"The Encapsulated Solution: EnhancedPlayer","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#properly-encapsulated-class","title":"Properly Encapsulated Class","text":"<pre><code>public class EnhancedPlayer {\n    // \u2705 PRIVATE fields - no direct access\n    private String fullName;\n    private int healthPercentage;\n    private String weapon;\n\n    // \u2705 Constructor ensures valid initialization\n    public EnhancedPlayer(String fullName) {\n        this(fullName, 100, \"Sword\");  // Chaining with defaults\n    }\n\n    public EnhancedPlayer(String fullName, int health, String weapon) {\n        this.fullName = fullName;\n\n        // \u2705 Validation in constructor\n        if (health &lt;= 0) {\n            this.healthPercentage = 1;\n        } else if (health &gt; 100) {\n            this.healthPercentage = 100;\n        } else {\n            this.healthPercentage = health;\n        }\n\n        this.weapon = weapon;\n    }\n\n    // \u2705 Controlled modification through methods\n    public void loseHealth(int damage) {\n        healthPercentage = healthPercentage - damage;\n        if (healthPercentage &lt;= 0) {\n            System.out.println(\"Player knocked out of game\");\n        }\n    }\n\n    public int healthRemaining() {\n        return healthPercentage;\n    }\n\n    public void restoreHealth(int extraHealth) {\n        healthPercentage = healthPercentage + extraHealth;\n        if (healthPercentage &gt; 100) {\n            System.out.println(\"Player restored to 100%\");\n            healthPercentage = 100;\n        }\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#how-encapsulation-solves-the-problems","title":"How Encapsulation Solves the Problems","text":"<p>Problem 1 \u2192 Solved: Can't bypass validation</p> <pre><code>EnhancedPlayer player = new EnhancedPlayer(\"Tim\", 200, \"sword\");\nSystem.out.println(player.healthRemaining());  // 100, not 200!\n\n// player.healthPercentage = 200;  // \u274c WON'T COMPILE - private!\n</code></pre> <p>Problem 2 \u2192 Solved: Internal changes don't break external code</p> <pre><code>// Internal change: health \u2192 healthPercentage\n// External code still uses healthRemaining() method\n// No changes needed in calling code!\n</code></pre> <p>Problem 3 \u2192 Solved: Constructor guarantees valid state</p> <pre><code>EnhancedPlayer player = new EnhancedPlayer(\"Tim\");\n// health is 100 (default)\n// weapon is \"Sword\" (default)\n// Player is ready to play!\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#encapsulation-challenge-printer-class","title":"Encapsulation Challenge: Printer Class","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#requirements","title":"Requirements","text":"<p>Create a <code>Printer</code> class with:</p> <ul> <li>Fields: <code>tonerLevel</code> (0-100%), <code>pagesPrinted</code>, <code>duplex</code> (boolean)</li> <li>Constructor: Validates toner level is in valid range</li> <li>Methods: <code>addToner()</code> and <code>printPages()</code></li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#solution","title":"Solution","text":"<pre><code>public class Printer {\n    private int tonerLevel;\n    private int pagesPrinted;\n    private boolean duplex;\n\n    public Printer(int tonerLevel, boolean duplex) {\n        this.pagesPrinted = 0;\n        // Validate toner level in constructor\n        this.tonerLevel = (tonerLevel &gt;= 0 &amp;&amp; tonerLevel &lt;= 100) \n                          ? tonerLevel : -1;\n        this.duplex = duplex;\n    }\n\n    public int addToner(int tonerAmount) {\n        int tempAmount = tonerAmount + tonerLevel;\n\n        // Validate: must stay in 0-100 range\n        if (tempAmount &gt; 100 || tempAmount &lt; 0) {\n            return -1;  // Error indicator\n        }\n\n        tonerLevel += tonerAmount;\n        return tonerLevel;\n    }\n\n    public int printPages(int pages) {\n        // Duplex: 2 pages per sheet, odd pages need extra sheet\n        int jobPages = (duplex) \n                       ? (pages / 2) + (pages % 2) \n                       : pages;\n\n        pagesPrinted += jobPages;\n        return jobPages;\n    }\n\n    public int getPagesPrinted() {\n        return pagesPrinted;\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#using-the-encapsulated-printer","title":"Using the Encapsulated Printer","text":"<pre><code>Printer printer = new Printer(50, true);  // 50% toner, duplex enabled\n\nSystem.out.println(printer.getPagesPrinted());  // 0\n\nint sheets = printer.printPages(5);   // 5 pages, duplex = 3 sheets\nSystem.out.printf(\"Job: %d sheets, Total: %d%n\", \n                  sheets, printer.getPagesPrinted());\n\nsheets = printer.printPages(10);      // 10 pages, duplex = 5 sheets\nSystem.out.printf(\"Job: %d sheets, Total: %d%n\", \n                  sheets, printer.getPagesPrinted());\n\n// Output:\n// 0\n// Job: 3 sheets, Total: 3\n// Job: 5 sheets, Total: 8\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#encapsulation-rules","title":"Encapsulation Rules","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#the-four-principles","title":"The Four Principles","text":"<pre><code>flowchart LR\n    A[Encapsulation Rules] --&gt; B[Private Fields]\n    A --&gt; C[Constructors]\n    A --&gt; D[Controlled Setters]\n    A --&gt; E[Minimal Exposure]</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#1-use-private-for-fields","title":"1. Use <code>private</code> for Fields","text":"<pre><code>// \u274c BAD\npublic String name;\npublic int health;\n\n// \u2705 GOOD\nprivate String name;\nprivate int health;\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#2-use-constructors-for-initialization","title":"2. Use Constructors for Initialization","text":"<pre><code>public EnhancedPlayer(String fullName, int health, String weapon) {\n    this.fullName = fullName;\n\n    // Validate in constructor!\n    if (health &lt;= 0) {\n        this.healthPercentage = 1;\n    } else if (health &gt; 100) {\n        this.healthPercentage = 100;\n    } else {\n        this.healthPercentage = health;\n    }\n\n    this.weapon = weapon;\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#3-use-setters-sparingly-only-when-needed","title":"3. Use Setters Sparingly (Only When Needed)","text":"<pre><code>// \u274c Don't automatically generate setters for all fields\npublic void setHealth(int health) {\n    this.health = health;  // No validation!\n}\n\n// \u2705 Only provide setters when necessary, with validation\npublic void restoreHealth(int extraHealth) {\n    health = health + extraHealth;\n    if (health &gt; 100) {\n        health = 100;  // Enforce business rule\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#4-expose-only-whats-necessary","title":"4. Expose Only What's Necessary","text":"<pre><code>// \u274c Don't expose internal details\npublic Motherboard getMotherboard() {\n    return motherboard;  // Exposes internal component\n}\n\n// \u2705 Provide high-level operations instead\npublic void powerUp() {\n    computerCase.pressPowerButton();\n    drawLogo();\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#before-vs-after-comparison","title":"Before vs After Comparison","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#player-class-comparison","title":"Player Class Comparison","text":"Aspect Non-Encapsulated (Player) Encapsulated (EnhancedPlayer) Field access <code>public</code> <code>private</code> Initialization Manual by caller Constructor with validation Health modification Direct access possible Only through methods Field names exposed Yes No Validation enforced Can be bypassed Always enforced Breaking changes Affect all callers Contained in class"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#code-comparison","title":"Code Comparison","text":"<pre><code>// \u274c Non-encapsulated usage\nPlayer player = new Player();\nplayer.name = \"Tim\";        // Direct access\nplayer.health = 200;        // Can set invalid values!\n\n// \u2705 Encapsulated usage\nEnhancedPlayer player = new EnhancedPlayer(\"Tim\", 200, \"Sword\");\n// Health automatically capped to 100\n// Can only modify through provided methods\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#benefits-of-encapsulation","title":"Benefits of Encapsulation","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#summary-table","title":"Summary Table","text":"Benefit Description Data Protection Private fields prevent unauthorized modification Validation Constructors and methods can validate all changes Flexibility Internal implementation can change without breaking callers Simpler Interface Users see only what they need (public API) Maintainability Changes are localized to the class Debugging Easier to track data changes through methods"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#real-world-analogy","title":"Real-World Analogy","text":"<p>Think of encapsulation like a bank account:</p> <ul> <li>You can't directly modify your balance (private field)</li> <li>You must use <code>deposit()</code> or <code>withdraw()</code> methods</li> <li>The bank validates every transaction</li> <li>You don't need to know how the bank stores your balance internally</li> </ul> <pre><code>public class BankAccount {\n    private double balance;  // You can't touch this directly!\n\n    public void deposit(double amount) {\n        if (amount &gt; 0) {\n            balance += amount;  // Validation\n        }\n    }\n\n    public boolean withdraw(double amount) {\n        if (amount &gt; 0 &amp;&amp; balance &gt;= amount) {\n            balance -= amount;\n            return true;\n        }\n        return false;  // Insufficient funds\n    }\n\n    public double getBalance() {\n        return balance;  // Read-only access\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#quick-reference","title":"Quick Reference","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#encapsulation-checklist","title":"Encapsulation Checklist","text":"<ul> <li> All instance fields are <code>private</code></li> <li> Constructor(s) validate input data</li> <li> Only necessary getters are provided</li> <li> Setters include validation (or use specialized methods instead)</li> <li> Public methods form a clean, simple interface</li> <li> Internal implementation details are hidden</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#access-modifiers-reminder","title":"Access Modifiers Reminder","text":"Modifier Same Class Same Package Subclass World <code>private</code> \u2705 \u274c \u274c \u274c (default) \u2705 \u2705 \u274c \u274c <code>protected</code> \u2705 \u2705 \u2705 \u274c <code>public</code> \u2705 \u2705 \u2705 \u2705"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#questions-explored","title":"Questions Explored","text":"<ul> <li> What is encapsulation and why do we need it?</li> <li> What problems occur without proper encapsulation?</li> <li> How do I create a properly encapsulated class?</li> <li> When should I use getters and setters?</li> <li> How does encapsulation relate to the \"black box\" concept?</li> <li> What's the relationship between encapsulation and validation?</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part5/#related-notes","title":"Related Notes","text":"Part Topic Link 1 Classes, Objects &amp; Encapsulation \u2190 Part 1 2 Inheritance &amp; Method Overriding \u2190 Part 2 3 Strings &amp; StringBuilder \u2190 Part 3 4 Composition \u2190 Part 4 5 Encapsulation You are here 6 Polymorphism Part 6 \u2192 <p>Last Updated: 2026-01-26</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/","title":"Topic Note Part 6: Polymorphism","text":"<p>Course: Java Programming Masterclass - Tim Buchalka (Udemy) Section: 08. Advanced OOP Techniques Status:  Complete</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#learning-objectives","title":"Learning Objectives","text":"<ul> <li> Understand what polymorphism means and how it works in Java</li> <li> Master the difference between compile-time and runtime types</li> <li> Learn to write polymorphic code using inheritance</li> <li> Implement factory methods for object creation</li> <li> Understand type casting and its implications</li> <li> Use <code>instanceof</code> operator and pattern matching (JDK 16+)</li> <li> Apply Local Variable Type Inference (<code>var</code> keyword)</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#what-is-polymorphism","title":"What is Polymorphism?","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#definition","title":"Definition","text":"<p>Polymorphism literally means \"many forms.\" In Java, it allows us to:</p> <ul> <li>Write code that calls a method</li> <li>Have different behavior execute for different objects at runtime</li> <li>Use a single reference type to work with multiple object types</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#the-core-concept","title":"The Core Concept","text":"<pre><code>Movie movie = new Adventure(\"Star Wars\");  // Declared: Movie, Actual: Adventure\nmovie.watchMovie();  // Calls Adventure's watchMovie(), not Movie's!\n</code></pre> <p>The declared type (comp\u0131le-time) is <code>Movie</code>, but the actual type (runtime) is <code>Adventure</code>. Java automatically calls the method on the actual runtime object.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#how-polymorphism-works","title":"How Polymorphism Works","text":"<pre><code>flowchart TD\n    A[Code calls movie.watchMovie] --&gt; B{What is the RUNTIME type?}\n    B --&gt; C[Movie]\n    B --&gt; D[Adventure]\n    B --&gt; E[Comedy]\n    B --&gt; F[ScienceFiction]\n    C --&gt; G[Execute Movie.watchMovie]\n    D --&gt; H[Execute Adventure.watchMovie]\n    E --&gt; I[Execute Comedy.watchMovie]\n    F --&gt; J[Execute ScienceFiction.watchMovie]</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#movie-class-hierarchy-example","title":"Movie Class Hierarchy Example","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#the-base-class-movie","title":"The Base Class: Movie","text":"<pre><code>public class Movie {\n    private String title;\n\n    public Movie(String title) {\n        this.title = title;\n    }\n\n    public void watchMovie() {\n        // getClass().getSimpleName() returns the RUNTIME class name\n        String instanceType = this.getClass().getSimpleName();\n        System.out.println(title + \" is a \" + instanceType + \" film\");\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#the-subclasses-adventure-comedy-sciencefiction","title":"The Subclasses: Adventure, Comedy, ScienceFiction","text":"<pre><code>class Adventure extends Movie {\n    public Adventure(String title) {\n        super(title);\n    }\n\n    @Override\n    public void watchMovie() {\n        super.watchMovie();  // Call parent's method first\n        System.out.printf(\"..%s%n\".repeat(3),\n            \"Pleasant Scene\",\n            \"Scary Music\",\n            \"Something Bad Happens\");\n    }\n\n    public void watchAdventure() {\n        System.out.println(\"Watching an Adventure!\");\n    }\n}\n\nclass Comedy extends Movie {\n    public Comedy(String title) {\n        super(title);\n    }\n\n    @Override\n    public void watchMovie() {\n        super.watchMovie();\n        System.out.printf(\"..%s%n\".repeat(3),\n            \"Something funny happens\",\n            \"Something even funnier happens\",\n            \"Happy Ending\");\n    }\n\n    public void watchComedy() {\n        System.out.println(\"Watching a Comedy!\");\n    }\n}\n\nclass ScienceFiction extends Movie {\n    public ScienceFiction(String title) {\n        super(title);\n    }\n\n    @Override\n    public void watchMovie() {\n        super.watchMovie();\n        System.out.printf(\"..%s%n\".repeat(3),\n            \"Bad Aliens do Bad Stuff\",\n            \"Space Guys Chase Aliens\",\n            \"Planet Blows Up\");\n    }\n\n    public void watchScienceFiction() {\n        System.out.println(\"Watching a Science Fiction Thriller!\");\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#polymorphism-in-action","title":"Polymorphism in Action","text":"<pre><code>// Same declared type (Movie), different runtime types\nMovie movie1 = new Movie(\"Generic Film\");\nMovie movie2 = new Adventure(\"Star Wars\");\nMovie movie3 = new Comedy(\"Airplane\");\nMovie movie4 = new ScienceFiction(\"The Matrix\");\n\n// Each call executes DIFFERENT behavior!\nmovie1.watchMovie();  // Movie.watchMovie()\nmovie2.watchMovie();  // Adventure.watchMovie()\nmovie3.watchMovie();  // Comedy.watchMovie()\nmovie4.watchMovie();  // ScienceFiction.watchMovie()\n</code></pre> <p>Output: <pre><code>Generic Film is a Movie film\nStar Wars is a Adventure film\n..Pleasant Scene\n..Scary Music\n..Something Bad Happens\nAirplane is a Comedy film\n..Something funny happens\n..Something even funnier happens\n..Happy Ending\nThe Matrix is a ScienceFiction film\n..Bad Aliens do Bad Stuff\n..Space Guys Chase Aliens\n..Planet Blows Up\n</code></pre></p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#factory-methods","title":"Factory Methods","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#what-is-a-factory-method","title":"What is a Factory Method?","text":"<p>A factory method is a static method that returns instances of objects. It hides the details of object creation from calling code.</p> <pre><code>public class Movie {\n    // ... fields and constructor ...\n\n    public static Movie getMovie(String type, String title) {\n        return switch (type.toUpperCase().charAt(0)) {\n            case 'A' -&gt; new Adventure(title);\n            case 'C' -&gt; new Comedy(title);\n            case 'S' -&gt; new ScienceFiction(title);\n            default -&gt; new Movie(title);\n        };\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#using-the-factory-method","title":"Using the Factory Method","text":"<pre><code>// Calling code doesn't need to know about subclasses!\nMovie movie = Movie.getMovie(\"S\", \"Star Wars\");\nmovie.watchMovie();\n\n// Output:\n// Star Wars is a ScienceFiction film\n// ..Bad Aliens do Bad Stuff\n// ..Space Guys Chase Aliens\n// ..Planet Blows Up\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#benefits-of-factory-methods","title":"Benefits of Factory Methods","text":"<ol> <li>Encapsulation: Subclass details hidden from caller</li> <li>Flexibility: Easy to add new types without changing caller code</li> <li>Centralized creation: All instantiation logic in one place</li> <li>Polymorphism-friendly: Returns parent type, actual type varies</li> </ol> <pre><code>flowchart LR\n    A[Calling Code] --&gt; B[Movie.getMovie type, title]\n    B --&gt; C{Type?}\n    C --&gt;|A| D[new Adventure]\n    C --&gt;|C| E[new Comedy]\n    C --&gt;|S| F[new ScienceFiction]\n    C --&gt;|default| G[new Movie]\n    D --&gt; H[Returns Movie reference]\n    E --&gt; H\n    F --&gt; H\n    G --&gt; H</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#compile-time-vs-runtime-types","title":"Compile-Time vs Runtime Types","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#understanding-the-difference","title":"Understanding the Difference","text":"Aspect Compile-Time Type Runtime Type When determined At compilation During execution Also called Declared type Actual type What decides Variable declaration <code>new</code> statement Method resolution Checks if method exists Determines which version runs"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#example-breakdown","title":"Example Breakdown","text":"<pre><code>Movie movie = new Adventure(\"Star Wars\");\n//    \u2191              \u2191\n//    \u2502              \u2514\u2500\u2500 Runtime type (Adventure)\n//    \u2514\u2500\u2500 Compile-time type (Movie)\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#what-the-compiler-sees-vs-what-jvm-executes","title":"What the Compiler Sees vs What JVM Executes","text":"<pre><code>Movie movie = new Adventure(\"Jaws\");\n\n// Compile-time: Compiler checks if Movie has watchMovie() \u2713\n// Runtime: JVM executes Adventure's watchMovie()\n\nmovie.watchMovie();  // Adventure's version runs!\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#method-visibility-based-on-declared-type","title":"Method Visibility Based on Declared Type","text":"<pre><code>Movie movie = new Adventure(\"Jaws\");\n\nmovie.watchMovie();      // \u2705 Works - watchMovie() is on Movie\nmovie.watchAdventure();  // \u274c COMPILE ERROR - watchAdventure() not on Movie!\n</code></pre> <p>The compiler only knows about methods on the declared type (<code>Movie</code>), even though the runtime type (<code>Adventure</code>) has additional methods.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#type-casting","title":"Type Casting","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#why-cast","title":"Why Cast?","text":"<p>When you need to access methods specific to a subclass:</p> <pre><code>Movie movie = Movie.getMovie(\"A\", \"Jaws\");\n\n// Can't call watchAdventure() on Movie reference\n// movie.watchAdventure();  // \u274c Won't compile\n\n// Solution: Cast to Adventure\nAdventure adventure = (Adventure) movie;\nadventure.watchAdventure();  // \u2705 Works!\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#casting-risks","title":"Casting Risks","text":"<pre><code>Movie movie = Movie.getMovie(\"C\", \"Airplane\");  // Actually a Comedy\n\n// Dangerous: Casting to wrong type!\nAdventure adventure = (Adventure) movie;  // \u274c Runtime Exception!\n</code></pre> <pre><code>java.lang.ClassCastException: class Comedy cannot be cast to class Adventure\n</code></pre> <p>ClassCastException</p> <p>Casting to the wrong type compiles successfully but throws a <code>ClassCastException</code> at runtime. Always verify the type before casting!</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#the-object-reference-problem","title":"The Object Reference Problem","text":"<pre><code>Object movie = Movie.getMovie(\"C\", \"Airplane\");\n\nmovie.watchMovie();  // \u274c COMPILE ERROR - watchMovie() not on Object!\n</code></pre> <p>When declared as <code>Object</code>, only <code>Object</code>'s methods are available (like <code>toString()</code>, <code>equals()</code>, etc.).</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#local-variable-type-inference-var","title":"Local Variable Type Inference (<code>var</code>)","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#what-is-var","title":"What is <code>var</code>?","text":"<p>Introduced in Java 10, <code>var</code> lets the compiler infer the type:</p> <pre><code>var movie = Movie.getMovie(\"C\", \"Airplane\");\n//  \u2191\n//  \u2514\u2500\u2500 Compiler infers: Movie (from method return type)\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#how-type-inference-works","title":"How Type Inference Works","text":"<pre><code>// Method signature determines inferred type\npublic static Movie getMovie(String type, String title) { ... }\n\nvar movie = Movie.getMovie(\"C\", \"Airplane\");  // Inferred as Movie\n\nmovie.watchMovie();      // \u2705 Works - Movie has watchMovie()\nmovie.watchComedy();     // \u274c Error - Movie doesn't have watchComedy()\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#direct-instantiation-with-var","title":"Direct Instantiation with var","text":"<pre><code>var plane = new Comedy(\"Airplane\");  // Inferred as Comedy\n\nplane.watchMovie();   // \u2705 Works\nplane.watchComedy();  // \u2705 Works - plane is a Comedy reference!\n</code></pre> <p>When using <code>new ClassName()</code>, the type is inferred as that specific class.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#limitations-of-var","title":"Limitations of <code>var</code>","text":"<pre><code>// \u274c Can't use in field declarations\n// private var name;  // Won't compile\n\n// \u274c Can't use in method parameters\n// public void process(var item) {}  // Won't compile\n\n// \u274c Can't use in method return types\n// public var getItem() {}  // Won't compile\n\n// \u274c Must have initializer\n// var x;  // Won't compile - can't infer type\n\n// \u274c Can't assign null\n// var x = null;  // Won't compile - can't infer type from null\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#runtime-type-checking","title":"Runtime Type Checking","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#method-1-using-getclass","title":"Method 1: Using getClass()","text":"<pre><code>Object unknownObject = Movie.getMovie(\"C\", \"Airplane\");\n\nif (unknownObject.getClass().getSimpleName().equals(\"Comedy\")) {\n    Comedy c = (Comedy) unknownObject;\n    c.watchComedy();\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#method-2-using-instanceof-operator","title":"Method 2: Using <code>instanceof</code> Operator","text":"<pre><code>Object unknownObject = Movie.getMovie(\"A\", \"Jaws\");\n\nif (unknownObject instanceof Adventure) {\n    Adventure a = (Adventure) unknownObject;\n    a.watchAdventure();\n}\n</code></pre> <p>The <code>instanceof</code> operator checks if an object is an instance of a specific type.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#method-3-pattern-matching-for-instanceof-jdk-16","title":"Method 3: Pattern Matching for <code>instanceof</code> (JDK 16+)","text":"<pre><code>Object unknownObject = Movie.getMovie(\"S\", \"Star Wars\");\n\n// Old way (pre-JDK 16):\nif (unknownObject instanceof ScienceFiction) {\n    ScienceFiction scifi = (ScienceFiction) unknownObject;\n    scifi.watchScienceFiction();\n}\n\n// NEW way (JDK 16+) - Pattern Matching:\nif (unknownObject instanceof ScienceFiction scifi) {\n    // scifi is already typed and ready to use!\n    scifi.watchScienceFiction();\n}\n</code></pre> <p>Pattern Matching Benefits</p> <ul> <li>No explicit cast needed</li> <li>Variable (<code>scifi</code>) is automatically typed</li> <li>Cleaner, more readable code</li> <li>Variable scope is limited to the <code>if</code> block</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#complete-example","title":"Complete Example","text":"<pre><code>Object unknownObject = Movie.getMovie(\"C\", \"Airplane\");\n\nif (unknownObject.getClass().getSimpleName().equals(\"Comedy\")) {\n    Comedy c = (Comedy) unknownObject;\n    c.watchComedy();\n} else if (unknownObject instanceof Adventure) {\n    ((Adventure) unknownObject).watchAdventure();  // Cast inline\n} else if (unknownObject instanceof ScienceFiction scifi) {\n    scifi.watchScienceFiction();  // Pattern matching\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#polymorphism-challenge-car-classes","title":"Polymorphism Challenge: Car Classes","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#the-car-base-class","title":"The Car Base Class","text":"<pre><code>public class Car {\n    private String description;\n\n    public Car(String description) {\n        this.description = description;\n    }\n\n    public void startEngine() {\n        System.out.println(\"Car -&gt; startEngine\");\n    }\n\n    protected void runEngine() {\n        System.out.println(\"Car -&gt; runEngine\");\n    }\n\n    public void drive() {\n        System.out.println(\"Car -&gt; driving, type is \" + \n                          getClass().getSimpleName());\n        runEngine();\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#subclasses-with-overridden-methods","title":"Subclasses with Overridden Methods","text":"<pre><code>class GasPoweredCar extends Car {\n    private double avgKmPerLiter;\n    private int cylinders = 6;\n\n    public GasPoweredCar(String description, \n                         double avgKmPerLiter, int cylinders) {\n        super(description);\n        this.avgKmPerLiter = avgKmPerLiter;\n        this.cylinders = cylinders;\n    }\n\n    @Override\n    public void startEngine() {\n        System.out.printf(\"Gas -&gt; All %d cylinders are fired up, Ready!%n\", \n                          cylinders);\n    }\n\n    @Override\n    protected void runEngine() {\n        System.out.printf(\"Gas -&gt; usage exceeds the average: %.2f%n\", \n                          avgKmPerLiter);\n    }\n}\n\nclass ElectricCar extends Car {\n    private double avgKmPerCharge;\n    private int batterySize = 6;\n\n    public ElectricCar(String description, \n                       double avgKmPerCharge, int batterySize) {\n        super(description);\n        this.avgKmPerCharge = avgKmPerCharge;\n        this.batterySize = batterySize;\n    }\n\n    @Override\n    public void startEngine() {\n        System.out.printf(\"BEV -&gt; switch %d KWh battery on, Ready!%n\", \n                          batterySize);\n    }\n\n    @Override\n    protected void runEngine() {\n        System.out.printf(\"BEV -&gt; usage under the average: %.2f%n\", \n                          avgKmPerCharge);\n    }\n}\n\nclass HybridCar extends Car {\n    private double avgKmPerLiter;\n    private int cylinders = 6;\n    private int batterySize;\n\n    public HybridCar(String description, double avgKmPerLiter, \n                     int cylinders, int batterySize) {\n        super(description);\n        this.avgKmPerLiter = avgKmPerLiter;\n        this.cylinders = cylinders;\n        this.batterySize = batterySize;\n    }\n\n    @Override\n    public void startEngine() {\n        System.out.printf(\"Hybrid -&gt; %d cylinders are fired up, Ready!%n\", \n                          cylinders);\n        System.out.printf(\"Hybrid -&gt; switch %d KWh battery on, Ready!%n\", \n                          batterySize);\n    }\n\n    @Override\n    protected void runEngine() {\n        System.out.printf(\"Hybrid -&gt; usage below the average: %.2f%n\", \n                          avgKmPerLiter);\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#polymorphic-method","title":"Polymorphic Method","text":"<pre><code>public class Main {\n    public static void main(String[] args) {\n        Car ferrari = new GasPoweredCar(\"2022 Ferrari 296 GTS\", 15.4, 6);\n        Car tesla = new ElectricCar(\"2022 Tesla Model 3\", 568, 75);\n        Car ferrariHybrid = new HybridCar(\"2022 Ferrari SF90\", 16, 8, 8);\n\n        runRace(ferrari);\n        runRace(tesla);\n        runRace(ferrariHybrid);\n    }\n\n    // Polymorphic method - works with ANY Car subclass!\n    public static void runRace(Car car) {\n        car.startEngine();\n        car.drive();\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#key-insight-indirect-polymorphism","title":"Key Insight: Indirect Polymorphism","text":"<pre><code>public void drive() {\n    System.out.println(\"Car -&gt; driving, type is \" + getClass().getSimpleName());\n    runEngine();  // \u2190 Calls the OVERRIDDEN version!\n}\n</code></pre> <p>Even though <code>drive()</code> is NOT overridden, it calls <code>runEngine()</code>, which IS overridden. The JVM resolves to the subclass's version!</p> <pre><code>// Output for GasPoweredCar:\nGas -&gt; All 6 cylinders are fired up, Ready!\nCar -&gt; driving, type is GasPoweredCar\nGas -&gt; usage exceeds the average: 15.40\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#key-takeaways","title":"Key Takeaways","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#polymorphism-summary","title":"Polymorphism Summary","text":"<ol> <li>\"Many Forms\": Same method call, different behavior based on object type</li> <li>Enabled by inheritance: Subclasses override parent methods</li> <li>Resolution at runtime: JVM decides which method to execute</li> <li>Works with parent references: <code>Car car = new ElectricCar(...)</code></li> </ol>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#when-to-use-polymorphism","title":"When to Use Polymorphism","text":"<ul> <li>When writing code that should work with any subclass</li> <li>When you want to add new types without changing existing code</li> <li>When implementing factory patterns</li> <li>When designing flexible, extensible systems</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#type-handling-rules","title":"Type Handling Rules","text":"Scenario Solution Call method on any subclass Use parent reference, call overridden method Call subclass-specific method Cast to specific type (after checking) Check object's actual type Use <code>instanceof</code> (prefer pattern matching) Let compiler infer type Use <code>var</code> keyword"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#quick-reference","title":"Quick Reference","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#polymorphism-checklist","title":"Polymorphism Checklist","text":"<ul> <li> Base class defines method to be overridden</li> <li> Subclasses override with <code>@Override</code> annotation</li> <li> Use parent class as reference type for flexibility</li> <li> Factory methods return parent type</li> <li> Cast only after type checking</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#pattern-matching-syntax-jdk-16","title":"Pattern Matching Syntax (JDK 16+)","text":"<pre><code>if (object instanceof SpecificType variableName) {\n    // variableName is already typed as SpecificType\n    variableName.specificMethod();\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#questions-explored","title":"Questions Explored","text":"<ul> <li> What is polymorphism and how does it work?</li> <li> What's the difference between compile-time and runtime types?</li> <li> How do I write code that works with any subclass?</li> <li> What is a factory method and why use it?</li> <li> When and how should I cast objects?</li> <li> How do I check an object's runtime type safely?</li> <li> What is <code>var</code> and when can I use it?</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note-part6/#related-notes","title":"Related Notes","text":"Part Topic Link 1 Classes, Objects &amp; Encapsulation \u2190 Part 1 2 Inheritance &amp; Method Overriding \u2190 Part 2 3 Strings &amp; StringBuilder \u2190 Part 3 4 Composition \u2190 Part 4 5 Encapsulation \u2190 Part 5 6 Polymorphism You are here <p>Last Updated: 2026-01-26</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/","title":"Topic Note Part 1: Classes, Objects &amp; Encapsulation","text":"<p>Course: Java Programming Masterclass - Tim Buchalka (Udemy) Section: 07. Mastering Java OOP Classes &amp; Inheritance Status:  Complete</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#learning-objectives","title":"Learning Objectives","text":"<ul> <li> Understand the fundamentals of Object-Oriented Programming (OOP)</li> <li> Master class creation with fields, methods, and access modifiers</li> <li> Implement encapsulation using getters and setters</li> <li> Learn to create and instantiate objects using the <code>new</code> keyword</li> <li> Understand constructors: default, parameterized, overloading, and chaining</li> <li> Distinguish between references, objects, and instances</li> <li> Compare static vs instance members (variables and methods)</li> <li> Work with POJOs (Plain Old Java Objects) and Java Records</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#core-concepts","title":"Core Concepts","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#what-is-object-oriented-programming","title":"What is Object-Oriented Programming?","text":"<p>Object-Oriented Programming (OOP) is a programming paradigm that models real-world entities as software objects containing both data (state) and code (behavior).</p> <pre><code>graph TD\n    subgraph \"Real World\"\n        A[Object: Computer]\n        B[State: RAM, OS, HDD Size]\n        C[Behavior: Boot, Shutdown, Beep]\n    end\n\n    subgraph \"Software World\"\n        D[Class: Computer Blueprint]\n        E[Fields: ram, os, hddSize]\n        F[Methods: boot, shutdown, beep]\n    end\n\n    A --&gt; D\n    B --&gt; E\n    C --&gt; F</code></pre> Real-World Concept Java Equivalent Object characteristics Fields (variables/attributes) Object actions Methods Blueprint/Template Class <p>Key Insight</p> <p>A class is not a data type in the traditional sense\u2014it's a blueprint or template for creating objects. Think of it as a powerful, user-defined data type.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#classes-in-java","title":"Classes in Java","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#anatomy-of-a-class","title":"Anatomy of a Class","text":"<p>A class is declared using the <code>class</code> keyword and contains members (fields and methods).</p> <pre><code>public class Car {\n    // Fields (instance variables) - represent STATE\n    private String make;\n    private String model;\n    private String color;\n    private int doors;\n    private boolean convertible;\n\n    // Methods - represent BEHAVIOR\n    public void describeCar() {\n        System.out.println(doors + \"-door \" + color + \" \" + make + \" \" + model);\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#access-modifiers","title":"Access Modifiers","text":"<p>Java provides four access levels for controlling visibility of class members:</p> Modifier Class Package Subclass World <code>public</code> \u2705 \u2705 \u2705 \u2705 <code>protected</code> \u2705 \u2705 \u2705 \u274c no modifier (package-private) \u2705 \u2705 \u274c \u274c <code>private</code> \u2705 \u274c \u274c \u274c <p>Best Practice</p> <p>Always make fields <code>private</code> unless you have a compelling reason not to. This is the foundation of encapsulation.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#for-top-level-classes","title":"For Top-Level Classes","text":"<p>A top-level class (defined in its own source file) can only have:</p> <ul> <li><code>public</code> - accessible from anywhere</li> <li>no modifier (package-private) - accessible only within the same package</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#encapsulation","title":"Encapsulation","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#what-is-encapsulation","title":"What is Encapsulation?","text":"<p>Encapsulation has two meanings in OOP:</p> <ol> <li>Bundling of data (fields) and behavior (methods) into a single unit (class)</li> <li>Information hiding - restricting direct access to internal state</li> </ol>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#why-encapsulate","title":"Why Encapsulate?","text":"<pre><code>flowchart LR\n    subgraph Without_Encapsulation\n        A[External Code] --&gt;|Direct Access| B[car.make = Invalid]\n        B --&gt; C[Invalid State]\n    end\n\n    subgraph With_Encapsulation\n        D[External Code] --&gt;|setMake| E{Validation}\n        E --&gt;|Valid| F[Valid State]\n        E --&gt;|Invalid| G[Rejected]\n    end</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#getters-and-setters","title":"Getters and Setters","text":"<p>Getters retrieve field values; Setters modify them with optional validation.</p> <pre><code>public class Car {\n    private String make = \"Tesla\";\n\n    // GETTER - retrieves the value\n    public String getMake() {\n        return make;\n    }\n\n    // SETTER - sets the value with validation\n    public void setMake(String make) {\n        if (make == null) {\n            this.make = \"Unknown\";\n            return;\n        }\n\n        String lowerCaseMake = make.toLowerCase();\n        switch (lowerCaseMake) {\n            case \"holden\", \"porsche\", \"tesla\" -&gt; this.make = make;\n            default -&gt; this.make = \"Unsupported\";\n        }\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#naming-conventions","title":"Naming Conventions","text":"Field Type Getter Name Setter Name <code>String name</code> <code>getName()</code> <code>setName(String name)</code> <code>int age</code> <code>getAge()</code> <code>setAge(int age)</code> <code>boolean active</code> <code>isActive()</code> <code>setActive(boolean active)</code> <p>The <code>this</code> Keyword</p> <p>When a parameter name matches a field name, use <code>this.fieldName</code> to refer to the instance field: <pre><code>public void setMake(String make) {\n    this.make = make;  // this.make = field, make = parameter\n}\n</code></pre></p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#creating-objects","title":"Creating Objects","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#the-new-keyword","title":"The <code>new</code> Keyword","text":"<p>Objects are created (instantiated) using the <code>new</code> keyword:</p> <pre><code>// Declaration and instantiation\nCar car = new Car();\n\n// Using the object\ncar.setMake(\"Porsche\");\ncar.setModel(\"Carrera\");\ncar.describeCar();  // Output: 2-door Gray Porsche Carrera\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#what-happens-in-memory","title":"What Happens in Memory?","text":"<pre><code>graph LR\n    subgraph \"Stack Memory\"\n        A[car reference]\n    end\n\n    subgraph \"Heap Memory\"\n        B[Car Object&lt;br/&gt;make: Porsche&lt;br/&gt;model: Carrera&lt;br/&gt;...]\n    end\n\n    A --&gt;|points to| B</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#default-field-values","title":"Default Field Values","text":"<p>Unlike local variables, class fields are automatically initialized with default values:</p> Type Default Value <code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code> <code>0</code> <code>float</code>, <code>double</code> <code>0.0</code> <code>char</code> <code>'\\u0000'</code> (null character) <code>boolean</code> <code>false</code> Reference types (<code>String</code>, objects) <code>null</code> <p>null vs. Uninitialized</p> <ul> <li>Uninitialized variable: Compile-time error when accessed</li> <li>null reference: Compiles but throws <code>NullPointerException</code> at runtime</li> </ul> <pre><code>Car car;          // Uninitialized - compiler error if used\nCar car = null;   // Null - compiles but NPE if methods called\nCar car = new Car(); // \u2705 Properly initialized\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#constructors","title":"Constructors","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#what-is-a-constructor","title":"What is a Constructor?","text":"<p>A constructor is a special code block that initializes an object when it's created. It:</p> <ul> <li>Has the same name as the class</li> <li>Has no return type (not even <code>void</code>)</li> <li>Is called automatically when <code>new</code> is used</li> </ul> <pre><code>public class Account {\n    private String number;\n    private double balance;\n\n    // Constructor\n    public Account(String number, double balance) {\n        this.number = number;\n        this.balance = balance;\n    }\n}\n\n// Usage\nAccount bobsAccount = new Account(\"12345\", 1000.00);\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#the-default-constructor","title":"The Default Constructor","text":"<p>If you don't declare any constructor, Java provides an implicit default (no-args) constructor:</p> <pre><code>// This is implicitly added if no constructor exists:\npublic Account() {\n}\n</code></pre> <p>Critical Rule</p> <p>If you declare ANY constructor, Java will NOT create the default constructor for you. You must explicitly declare it if needed.</p> <pre><code>public class Account {\n    public Account(String number) { }  // Only this exists\n}\n\nAccount a = new Account();  // \u274c Compile error! No no-args constructor\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#constructor-overloading","title":"Constructor Overloading","text":"<p>Like methods, constructors can be overloaded with different parameter lists:</p> <pre><code>public class Customer {\n    private String name;\n    private double creditLimit;\n    private String email;\n\n    // Constructor 1: All fields\n    public Customer(String name, double creditLimit, String email) {\n        this.name = name;\n        this.creditLimit = creditLimit;\n        this.email = email;\n    }\n\n    // Constructor 2: Name and email only (default credit limit)\n    public Customer(String name, String email) {\n        this(name, 1000.00, email);  // Calls Constructor 1\n    }\n\n    // Constructor 3: No args (all defaults)\n    public Customer() {\n        this(\"Default name\", \"nobody@email.com\");  // Calls Constructor 2\n    }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#constructor-chaining-with-this","title":"Constructor Chaining with <code>this()</code>","text":"<p>The <code>this()</code> call invokes another constructor in the same class:</p> <pre><code>flowchart TD\n    A[\"new Customer()\"] --&gt; B[\"Customer() no-args\"]\n    B --&gt;|\"this('Default', 'email')\"| C[\"Customer(name, email)\"]\n    C --&gt;|\"this(name, 1000, email)\"| D[\"Customer(name, creditLimit, email)\"]\n    D --&gt; E[\"Fields initialized\"]</code></pre> <p>Critical Rule</p> <p><code>this()</code> MUST be the first statement in the constructor body: <pre><code>public Customer() {\n    System.out.println(\"Hello\");  // \u274c Compile error!\n    this(\"Default\", \"email\");\n}\n</code></pre></p> <p>Best Practice: Single Point of Initialization</p> <p>Put all field initialization logic in one main constructor and have others delegate to it. This avoids code duplication and ensures consistency.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#direct-field-assignment-vs-calling-setters","title":"Direct Field Assignment vs. Calling Setters","text":"<p>In constructors, prefer direct field assignment over calling setters:</p> <pre><code>// \u2705 Recommended\npublic Account(String number) {\n    this.number = number;\n}\n\n// \u26a0\ufe0f Can cause issues with inheritance (covered later)\npublic Account(String number) {\n    setNumber(number);\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#references-objects-and-instances","title":"References, Objects, and Instances","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#understanding-the-terminology","title":"Understanding the Terminology","text":"Term Definition Class Blueprint/template for creating objects Object An instance of a class in memory Instance Synonym for object Reference A variable that \"points to\" an object in memory"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#the-house-analogy","title":"The House Analogy","text":"<pre><code>graph TD\n    subgraph \"Blueprint (Class)\"\n        A[House Blueprint]\n    end\n\n    subgraph \"Physical Houses (Objects)\"\n        B[House at 123 Main St]\n        C[House at 456 Oak Ave]\n    end\n\n    subgraph \"Addresses (References)\"\n        D[\"blueHouse (123 Main)\"]\n        E[\"anotherHouse (123 Main)\"]\n        F[\"greenHouse (456 Oak)\"]\n    end\n\n    A --&gt;|\"new House()\"| B\n    A --&gt;|\"new House()\"| C\n    D --&gt; B\n    E --&gt; B\n    F --&gt; C</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#multiple-references-to-same-object","title":"Multiple References to Same Object","text":"<pre><code>House blueHouse = new House(\"blue\");\nHouse anotherHouse = blueHouse;  // Same object, new reference\n\nanotherHouse.setColor(\"yellow\");\n\nSystem.out.println(blueHouse.getColor());    // \"yellow\"\nSystem.out.println(anotherHouse.getColor()); // \"yellow\"\n// Both print \"yellow\" - they reference the SAME object!\n</code></pre> <p>Key Insight</p> <p>When you assign one reference to another, you're copying the address, not the object. Both variables now point to the same object in memory.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#dereferencing-and-garbage-collection","title":"Dereferencing and Garbage Collection","text":"<pre><code>// Object created with no reference - immediately eligible for GC\nnew House(\"red\");  // Cannot access this object!\n\n// Object with reference\nHouse myHouse = new House(\"beige\");\n\n// Creating new object and reassigning reference\nHouse anotherRed = new House(\"red\");\nmyHouse = anotherRed;  // Beige house is now eligible for GC\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#static-vs-instance-members","title":"Static vs. Instance Members","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#static-variables","title":"Static Variables","text":"<p>A static variable is shared by ALL instances of a class:</p> <pre><code>public class Dog {\n    private static String name;  // Shared by all dogs!\n\n    public Dog(String name) {\n        Dog.name = name;\n    }\n\n    public void printName() {\n        System.out.println(name);\n    }\n}\n\n// Usage\nDog rex = new Dog(\"Rex\");\nDog fluffy = new Dog(\"Fluffy\");\n\nrex.printName();    // \"Fluffy\" - not \"Rex\"!\nfluffy.printName(); // \"Fluffy\"\n// Both print \"Fluffy\" because static variable is shared\n</code></pre> <pre><code>graph TD\n    subgraph \"Class Level - Static\"\n        A[\"static name = Fluffy\"]\n    end\n\n    subgraph \"Instance Level\"\n        B[rex instance] --&gt; A\n        C[fluffy instance] --&gt; A\n    end</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#when-to-use-static-variables","title":"When to Use Static Variables","text":"Use Case Example Counters <code>private static int instanceCount;</code> Unique ID generators <code>private static long nextId;</code> Constants <code>public static final double PI = 3.14159;</code> Shared resources Database connections, loggers <p>Access Convention</p> <p>Always access static members using the class name, not an instance: <pre><code>// \u2705 Good - makes it clear this is static\nMath.PI\n\n// \u26a0\ufe0f Works but misleading\nmyMath.PI\n</code></pre></p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#instance-variables","title":"Instance Variables","text":"<p>Instance variables are unique to each object:</p> <pre><code>public class Dog {\n    private String name;  // Instance variable - unique per dog\n\n    public Dog(String name) {\n        this.name = name;\n    }\n}\n\nDog rex = new Dog(\"Rex\");\nDog fluffy = new Dog(\"Fluffy\");\n\nrex.printName();    // \"Rex\"\nfluffy.printName(); // \"Fluffy\"\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#static-vs-instance-methods","title":"Static vs. Instance Methods","text":"Aspect Static Method Instance Method Declaration <code>public static void method()</code> <code>public void method()</code> Access instance fields? \u274c No \u2705 Yes Access static fields? \u2705 Yes \u2705 Yes Requires object to call? \u274c No \u2705 Yes Can use <code>this</code>? \u274c No \u2705 Yes <pre><code>public class Calculator {\n    // Static method - no instance needed\n    public static int add(int a, int b) {\n        return a + b;\n    }\n}\n\n// Call without creating an object\nint sum = Calculator.add(5, 3);\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#decision-flowchart","title":"Decision Flowchart","text":"<pre><code>flowchart TD\n    A[Should method be static?] --&gt; B{Uses instance&lt;br/&gt;variables or methods?}\n    B --&gt;|Yes| C[Make it an&lt;br/&gt;INSTANCE method]\n    B --&gt;|No| D[Consider making it&lt;br/&gt;STATIC]</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#pojos-and-java-records","title":"POJOs and Java Records","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#plain-old-java-objects-pojos","title":"Plain Old Java Objects (POJOs)","text":"<p>A POJO is a class primarily used to store data with minimal behavior.</p> <pre><code>public class Student {\n    private String id;\n    private String name;\n    private String dateOfBirth;\n    private String classList;\n\n    // Constructor\n    public Student(String id, String name, String dateOfBirth, String classList) {\n        this.id = id;\n        this.name = name;\n        this.dateOfBirth = dateOfBirth;\n        this.classList = classList;\n    }\n\n    // toString for printing\n    @Override\n    public String toString() {\n        return \"Student{\" +\n                \"id='\" + id + '\\'' +\n                \", name='\" + name + '\\'' +\n                \", dateOfBirth='\" + dateOfBirth + '\\'' +\n                \", classList='\" + classList + '\\'' +\n                '}';\n    }\n\n    // Getters and setters for all fields...\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#related-terms","title":"Related Terms","text":"Term Description POJO Plain Old Java Object - simple data class JavaBean POJO with specific rules (no-arg constructor, serializable) Entity POJO that mirrors a database table DTO Data Transfer Object - for moving data between layers"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#the-override-annotation","title":"The <code>@Override</code> Annotation","text":"<p>The <code>@Override</code> annotation tells the compiler that a method is meant to override a method from a parent class:</p> <pre><code>@Override\npublic String toString() {\n    return \"Student: \" + name;\n}\n</code></pre> <p>toString() Method</p> <p>Every class inherits a <code>toString()</code> method from <code>Object</code>. When you pass an object to <code>System.out.println()</code>, Java automatically calls its <code>toString()</code> method.</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#java-records-java-16","title":"Java Records (Java 16+)","text":"<p>Records are a modern, concise alternative to POJOs for immutable data:</p> <pre><code>// Traditional POJO: ~60 lines of boilerplate\npublic class Student { ... }\n\n// Record: 1 line!\npublic record LPAStudent(String id, String name, String dateOfBirth, String classList) { }\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#what-records-generate-automatically","title":"What Records Generate Automatically","text":"<p>For each component in the record header, Java creates:</p> Generated Description <code>private final</code> field Immutable storage Public accessor method Same name as field (e.g., <code>name()</code> not <code>getName()</code>) <code>toString()</code> Formatted output of all fields <code>equals()</code> and <code>hashCode()</code> Based on all fields Constructor With all parameters"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#using-records","title":"Using Records","text":"<pre><code>// Creating a record instance\nLPAStudent student = new LPAStudent(\"S001\", \"Bill\", \"1985-11-05\", \"Java Masterclass\");\n\n// Accessor methods (no \"get\" prefix!)\nSystem.out.println(student.name());       // \"Bill\"\nSystem.out.println(student.classList());  // \"Java Masterclass\"\n\n// Implicit toString()\nSystem.out.println(student);  // LPAStudent[id=S001, name=Bill, ...]\n\n// No setters - records are IMMUTABLE\nstudent.setName(\"Bob\");  // \u274c Compile error!\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#pojo-vs-record","title":"POJO vs Record","text":"Feature POJO Record Mutability Mutable (has setters) Immutable (no setters) Boilerplate Lots of code Minimal Field access <code>getXxx()</code> / <code>isXxx()</code> <code>xxx()</code> (field name) When to use Need to modify data Read-only data transfer <p>When to Use Records</p> <p>Use records when: - Data is read-only after creation - You're passing data between layers (DTOs) - You want to reduce boilerplate</p> <p>Use POJOs when: - You need to modify fields after creation - You need custom behavior in getters/setters - Framework requires JavaBean conventions</p>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#key-insights-best-practices","title":"Key Insights &amp; Best Practices","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#encapsulation-best-practices","title":"Encapsulation Best Practices","text":"<ol> <li>Always make fields <code>private</code> - control access through methods</li> <li>Use getters for read access - even if they just return the value</li> <li>Add validation in setters - reject invalid data before it corrupts state</li> <li>Consider immutability - use final fields and records when possible</li> </ol>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#constructor-best-practices","title":"Constructor Best Practices","text":"<ol> <li>Use constructor chaining - centralize initialization in one constructor</li> <li>Don't call overridable methods in constructors (more on this in inheritance)</li> <li>Assign directly to fields rather than calling setters in constructors</li> <li>Validate parameters - throw exceptions for invalid input</li> </ol>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#static-vs-instance-decision","title":"Static vs. Instance Decision","text":"Scenario Use Method needs object state Instance Method is a utility/helper Static Counter shared across instances Static Each object has unique data Instance"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#quick-reference","title":"Quick Reference","text":""},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#class-declaration-template","title":"Class Declaration Template","text":"<pre><code>public class ClassName {\n    // 1. Fields (instance variables)\n    private Type fieldName;\n\n    // 2. Constructors\n    public ClassName() { }\n    public ClassName(Type param) {\n        this.fieldName = param;\n    }\n\n    // 3. Getters and Setters\n    public Type getFieldName() { return fieldName; }\n    public void setFieldName(Type fieldName) { this.fieldName = fieldName; }\n\n    // 4. Other methods\n    public void doSomething() { }\n\n    // 5. toString (optional)\n    @Override\n    public String toString() { return \"...\"; }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#record-declaration-template","title":"Record Declaration Template","text":"<pre><code>public record RecordName(Type field1, Type field2) {\n    // Optional: Custom compact constructor for validation\n    public RecordName {\n        if (field1 == null) throw new IllegalArgumentException();\n    }\n\n    // Optional: Additional methods\n    public String formatted() { return field1 + \": \" + field2; }\n}\n</code></pre>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#questions-explored","title":"Questions Explored","text":"<ul> <li> What is a class and how does it relate to objects?</li> <li> What is encapsulation and why is it important?</li> <li> How do constructors work and what is constructor chaining?</li> <li> What's the difference between a reference and an object?</li> <li> When should I use static vs. instance members?</li> <li> What are POJOs and when should I use Java Records?</li> </ul>"},{"location":"notes/phase-1/topic-2-oop-class-design/topic-note/#related-notes","title":"Related Notes","text":"Part Topic Link 1 Classes, Objects &amp; Encapsulation You are here 2 Inheritance &amp; Method Overriding Part 2 \u2192 3 Strings &amp; StringBuilder Part 3 \u2192 4 Composition Part 4 \u2192 5 Encapsulation (Advanced) Part 5 \u2192 6 Polymorphism Part 6 \u2192 <p>Last Updated: 2026-01-26</p>"},{"location":"notes/phase-1/topic-3-arrays-lists-generics/","title":"Topic 3: Arrays, Lists &amp; Autoboxing","text":"<p>Understanding Java's core data structures \u2014 from fixed-size arrays to dynamic lists, wrapper classes, and enum types.</p>"},{"location":"notes/phase-1/topic-3-arrays-lists-generics/#topic-structure","title":"Topic Structure","text":"Document Purpose Status  Part 1 \u2014 Arrays Array fundamentals, <code>java.util.Arrays</code>, multi-dimensional arrays, varargs  Complete  Part 2 \u2014 ArrayList Collections intro, <code>ArrayList</code> CRUD, searching, sorting, Array \u2194 ArrayList conversion  Complete  Part 3 \u2014 LinkedList &amp; Iterators LinkedList as List/Queue/Deque/Stack, <code>Iterator</code>, <code>ListIterator</code>, Travel Itinerary challenge  Complete  Part 4 \u2014 Autoboxing, Unboxing &amp; Enums Wrapper classes, autoboxing/unboxing, Banking challenge, enum types &amp; custom methods  Complete  Book Reading Effective Java insights (Items 28, 34\u201339)  Complete  Summary Combined final understanding  Complete"},{"location":"notes/phase-1/topic-3-arrays-lists-generics/#what-youll-master","title":"What You'll Master","text":"<ul> <li>Arrays \u2014 Declaration, initialization, <code>java.util.Arrays</code> utilities, multi-dimensional arrays, varargs</li> <li>ArrayList \u2014 Resizable arrays, CRUD operations, searching, sorting, <code>List.of()</code> vs <code>Arrays.asList()</code></li> <li>LinkedList \u2014 Doubly linked list, Queue/Deque/Stack interfaces, Big O performance comparison</li> <li>Iterators \u2014 <code>Iterator</code> and <code>ListIterator</code>, safe modification during iteration, bidirectional traversal</li> <li>Autoboxing &amp; Unboxing \u2014 Primitives vs wrapper classes, automatic conversions, common pitfalls</li> <li>Enums \u2014 Predefined constants, <code>name()</code>/<code>ordinal()</code>/<code>values()</code>, switch statements, custom methods</li> </ul>"},{"location":"notes/phase-1/topic-3-arrays-lists-generics/#resources","title":"Resources","text":""},{"location":"notes/phase-1/topic-3-arrays-lists-generics/#primary-course","title":"Primary Course","text":"<ul> <li>Tim Buchalka's Java Masterclass \u2014 Sections 9 &amp; 10</li> </ul>"},{"location":"notes/phase-1/topic-3-arrays-lists-generics/#book-reference","title":"Book Reference","text":"<ul> <li>Effective Java by Joshua Bloch \u2014 Items related to Lists and Autoboxing</li> </ul>"},{"location":"notes/phase-1/topic-3-arrays-lists-generics/#course-sections-covered","title":"Course Sections Covered","text":"Section Lectures Part Section 9: Arrays 13 lectures Part 1 Section 10: Lists &amp; Autoboxing Lectures 1\u20136 Part 2 Section 10: LinkedList &amp; Iterators Lectures 7, 9\u201313 Part 3 Section 10: Autoboxing &amp; Enums Lectures 15\u201318, 20\u201321 Part 4"},{"location":"notes/phase-1/topic-3-arrays-lists-generics/#key-internals-to-understand","title":"Key Internals to Understand","text":"<ul> <li>How arrays store elements contiguously in memory (cache-friendly access)</li> <li>ArrayList's dynamic resizing strategy (grow by 50%, amortized O(1) add)</li> <li>LinkedList's node-based memory layout (non-contiguous, pointer overhead)</li> <li>Why <code>Iterator.remove()</code> is safe during iteration but <code>List.remove()</code> throws <code>ConcurrentModificationException</code></li> <li>Autoboxing: when the JVM inserts <code>Integer.valueOf()</code> and <code>intValue()</code> calls</li> <li>Integer cache: <code>Integer.valueOf()</code> caches values [-128, 127] (identity vs equality trap)</li> <li>Enum's implementation as a class with <code>public static final</code> instances</li> </ul>"},{"location":"notes/phase-1/topic-3-arrays-lists-generics/#progress-tracker","title":"Progress Tracker","text":"<ul> <li> Complete Tim's course Section 9 (Arrays)</li> <li> Complete Tim's course Section 10 (Lists, Iterators, Autoboxing, Enums)</li> <li> Write Part 1 topic notes (Arrays)</li> <li> Write Part 2 topic notes (ArrayList)</li> <li> Write Part 3 topic notes (LinkedList &amp; Iterators)</li> <li> Write Part 4 topic notes (Autoboxing, Unboxing &amp; Enums)</li> <li> Read Effective Java related items</li> <li> Complete book reading notes</li> <li> Synthesize final summary</li> </ul> <p>Last Updated: 2026-02-11</p>"},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/","title":"Book Reading: Arrays, Lists &amp; Autoboxing","text":"<p>Book: Effective Java by Joshua Bloch (3<sup>rd</sup> Edition) Relevant Items: 28 (Generics), 34\u201339 (Enums &amp; Annotations) Status:  Complete</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#reading-goals","title":"Reading Goals","text":"<ul> <li> Understand why lists are preferred over arrays for type safety</li> <li> Master enum best practices (constants, instance fields, EnumSet, EnumMap)</li> <li> Learn to avoid the <code>ordinal()</code> trap</li> <li> Know when to use <code>EnumSet</code> and <code>EnumMap</code> over traditional approaches</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#chapter-5-generics-selected","title":"Chapter 5: Generics (Selected)","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#item-28-prefer-lists-to-arrays","title":"Item 28: Prefer Lists to Arrays","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#key-takeaways","title":"Key Takeaways","text":"<p>Arrays and generics have fundamentally different type systems. Arrays are covariant (if <code>Sub</code> is a subtype of <code>Super</code>, then <code>Sub[]</code> is a subtype of <code>Super[]</code>), while generics are invariant (<code>List&lt;Sub&gt;</code> is NOT a subtype of <code>List&lt;Super&gt;</code>). This makes arrays less type-safe.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#the-danger-of-covariant-arrays","title":"The Danger of Covariant Arrays","text":"<pre><code>// \u274c COMPILES but FAILS at runtime!\nObject[] objectArray = new Long[1];\nobjectArray[0] = \"I don't fit in here!\"; // Throws ArrayStoreException at RUNTIME\n\n// \u2705 CAUGHT at compile time \u2014 much safer!\nList&lt;Object&gt; ol = new ArrayList&lt;Long&gt;(); // Won't compile!\nol.add(\"I don't fit in here!\");\n</code></pre> <p>Runtime vs Compile Time</p> <p>With arrays, you discover type errors when your code is running in production. With lists, the compiler catches them before you even ship.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#arrays-vs-lists-comparison","title":"Arrays vs Lists Comparison","text":"Aspect Arrays Generic Lists Variance Covariant \u2014 <code>Sub[]</code> is <code>Super[]</code> Invariant \u2014 <code>List&lt;Sub&gt;</code> \u2260 <code>List&lt;Super&gt;</code> Type checking Runtime \u2014 <code>ArrayStoreException</code> Compile time \u2014 won't compile Reification Reified \u2014 types enforced at runtime Erased \u2014 types removed at runtime Can hold primitives \u2705 <code>int[]</code> directly \u274c Must use <code>Integer</code> (autoboxing) Mix with generics \u274c Can't create <code>new T[]</code> \u2705 Designed for generics <pre><code>flowchart LR\n    subgraph arrays[\" ARRAYS \"]\n        A1[\"Covariant \u2192 Runtime errors\"]\n        A2[\"Reified \u2192 Types at runtime\"]\n    end\n    subgraph lists[\" GENERIC LISTS \"]\n        L1[\"Invariant \u2192 Compile errors\"]\n        L2[\"Erased \u2192 Types at compile only\"]\n    end\n\n    arrays -.prefer.-&gt; lists</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#when-arrays-are-still-ok","title":"When Arrays Are Still OK","text":"<ul> <li>Performance-critical inner loops with primitives (<code>int[]</code>, <code>double[]</code>)</li> <li>Varargs parameters (the language requires them)</li> <li>Low-level code where you control all access</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#connection-to-course-material","title":"Connection to Course Material","text":"<p>In Part 1 we learned arrays and <code>java.util.Arrays</code>.</p> <p>In Part 2 we switched to <code>ArrayList</code> and saw how much more convenient and type-safe it is.</p> <p>Bloch's Item 28 gives us the theoretical why \u2014 lists catch type errors at compile time, arrays defer them to runtime.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#chapter-6-enums-and-annotations","title":"Chapter 6: Enums and Annotations","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#item-34-use-enums-instead-of-int-constants","title":"Item 34: Use Enums Instead of int Constants","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#key-takeaways_1","title":"Key Takeaways","text":"<p>The int enum pattern (using <code>public static final int</code> for constants) is fragile, unreadable, and provides no type safety. Java enums are full-fledged classes that provide compile-time type safety, readability, and extensibility.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#the-bad-old-way-int-constants","title":"The Bad Old Way: int Constants","text":"<pre><code>// \u274c BAD: The int enum anti-pattern\npublic static final int APPLE_FUJI         = 0;\npublic static final int APPLE_PIPPIN       = 1;\npublic static final int APPLE_GRANNY_SMITH = 2;\n\npublic static final int ORANGE_NAVEL  = 0;\npublic static final int ORANGE_TEMPLE = 1;\npublic static final int ORANGE_BLOOD  = 2;\n\n// No type safety! Nothing stops you from comparing apples to oranges:\nif (APPLE_FUJI == ORANGE_NAVEL) { ... }  // Compiles! Both are 0!\n</code></pre> Problem Description No type safety An <code>int</code> for apples can be compared to oranges No namespace Must prefix names to avoid collisions (<code>APPLE_FUJI</code>) Brittle Changing the value requires recompilation No iteration Can't iterate over all values Not printable <code>System.out.println(0)</code> \u2014 meaningless","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#the-enum-solution","title":"The Enum Solution","text":"<pre><code>// \u2705 GOOD: Real enums!\npublic enum Apple  { FUJI, PIPPIN, GRANNY_SMITH }\npublic enum Orange { NAVEL, TEMPLE, BLOOD }\n\n// Compile error! Can't compare different enum types!\nif (Apple.FUJI == Orange.NAVEL) { ... }  // Won't compile!\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#enums-are-classes","title":"Enums Are Classes","text":"<p>Bloch emphasizes that Java enums are far more powerful than enums in other languages \u2014 they are full classes that can have fields, methods, and implement interfaces:</p> <pre><code>public enum Planet {\n    MERCURY(3.302e+23, 2.439e6),\n    VENUS  (4.869e+24, 6.052e6),\n    EARTH  (5.975e+24, 6.378e6);\n    // ... more planets\n\n    private final double mass;           // In kilograms\n    private final double radius;         // In meters\n    private final double surfaceGravity; // Computed\n\n    Planet(double mass, double radius) {\n        this.mass = mass;\n        this.radius = radius;\n        this.surfaceGravity = G * mass / (radius * radius);\n    }\n\n    public double surfaceWeight(double mass) {\n        return mass * surfaceGravity;\n    }\n}\n</code></pre> <p>Connection to Our Code</p> <ul> <li> <p>Our <code>Topping</code> enum from Part 4 follows this exact pattern</p> </li> <li> <p>adding a <code>getPrice()</code> method with instance-specific behavior via switch expressions.</p> </li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#item-35-use-instance-fields-instead-of-ordinals","title":"Item 35: Use Instance Fields Instead of Ordinals","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#key-takeaways_2","title":"Key Takeaways","text":"<p>Every enum has an <code>ordinal()</code> method that returns its position (0-based). Never derive a value from the ordinal \u2014 use instance fields instead.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#the-temptation","title":"The Temptation","text":"<pre><code>// \u274c BAD: Deriving values from ordinal position\npublic enum Ensemble {\n    SOLO, DUET, TRIO, QUARTET, QUINTET,\n    SEXTET, SEPTET, OCTET, NONET, DECTET;\n\n    public int numberOfMusicians() {\n        return ordinal() + 1;  // Fragile! Tied to declaration order!\n    }\n}\n</code></pre> <p>Problems:</p> <ul> <li>Reordering constants breaks the method</li> <li>Can't have two constants with the same int value (e.g., <code>DOUBLE_QUARTET</code> = 8, same as <code>OCTET</code>)</li> <li>Can't skip values (e.g., no ensemble of size 12 without filling gaps)</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#the-fix-instance-fields","title":"The Fix: Instance Fields","text":"<pre><code>// \u2705 GOOD: Use instance fields\npublic enum Ensemble {\n    SOLO(1), DUET(2), TRIO(3), QUARTET(4), QUINTET(5),\n    SEXTET(6), SEPTET(7), OCTET(8), DOUBLE_QUARTET(8),\n    NONET(9), DECTET(10), TRIPLE_QUARTET(12);\n\n    private final int numberOfMusicians;\n\n    Ensemble(int size) { this.numberOfMusicians = size; }\n\n    public int numberOfMusicians() { return numberOfMusicians; }\n}\n</code></pre> <pre><code>flowchart TD\n    subgraph bad[\" \u274c ORDINAL APPROACH \"]\n        O1[\"ordinal() + 1\"]\n        O2[\"Breaks on reorder\"]\n        O3[\"No duplicate values\"]\n        O4[\"No gaps allowed\"]\n    end\n    subgraph good[\" \u2705 INSTANCE FIELD \"]\n        I1[\"Explicit field value\"]\n        I2[\"Order-independent\"]\n        I3[\"Duplicates OK\"]\n        I4[\"Gaps OK\"]\n    end\n    bad -.replace with.-&gt; good</code></pre> <p>Connection to Our Code</p> <p>In Part 4 we demonstrated <code>ordinal()</code> with <code>DayOfTheWeek</code>. While it's useful to know about, Bloch warns: never use <code>ordinal()</code> to derive associated data. Our <code>Topping</code> enum already follows the correct pattern</p> <ul> <li>it uses a switch expression in <code>getPrice()</code> rather than ordinal math.</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#item-36-use-enumset-instead-of-bit-fields","title":"Item 36: Use EnumSet Instead of Bit Fields","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#key-takeaways_3","title":"Key Takeaways","text":"<p>Before enums, developers used bit fields to represent sets of constants. <code>EnumSet</code> is the modern, type-safe replacement that's just as fast.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#the-old-way-bit-fields","title":"The Old Way: Bit Fields","text":"<pre><code>// \u274c BAD: Bit field constants\npublic class Text {\n    public static final int STYLE_BOLD          = 1 &lt;&lt; 0; // 1\n    public static final int STYLE_ITALIC        = 1 &lt;&lt; 1; // 2\n    public static final int STYLE_UNDERLINE     = 1 &lt;&lt; 2; // 4\n    public static final int STYLE_STRIKETHROUGH = 1 &lt;&lt; 3; // 8\n\n    // Apply styles using bitwise OR\n    public void applyStyles(int styles) { ... }\n}\n\n// Usage - cryptic!\ntext.applyStyles(STYLE_BOLD | STYLE_ITALIC);\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#the-modern-way-enumset","title":"The Modern Way: EnumSet","text":"<pre><code>// \u2705 GOOD: EnumSet\npublic class Text {\n    public enum Style { BOLD, ITALIC, UNDERLINE, STRIKETHROUGH }\n\n    // Accept Set&lt;Style&gt; \u2014 backed by EnumSet internally\n    public void applyStyles(Set&lt;Style&gt; styles) { ... }\n}\n\n// Usage - readable and type-safe!\ntext.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC));\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#why-enumset-wins","title":"Why EnumSet Wins","text":"Aspect Bit Fields EnumSet Type safety \u274c Just <code>int</code> \u2705 Compile-time checked Readability \u274c <code>1 &lt;&lt; 3</code> means what? \u2705 <code>Style.STRIKETHROUGH</code> Iteration \u274c Manual bit manipulation \u2705 Standard <code>for-each</code> Performance \u2705 Single <code>long</code> \u2705 Also single <code>long</code> (\u226464 elements) Printing \u274c Just a number \u2705 Meaningful names <p>Internal Implementation</p> <ul> <li> <p>For enums with \u226464 constants, <code>EnumSet</code> is backed by a single <code>long</code></p> </li> <li> <p>it uses bit manipulation internally, so you get the same performance as bit fields with all the benefits of enums.</p> </li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#item-37-use-enummap-instead-of-ordinal-indexing","title":"Item 37: Use EnumMap Instead of Ordinal Indexing","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#key-takeaways_4","title":"Key Takeaways","text":"<p>When you need to map data by enum values, use <code>EnumMap</code> instead of indexing an array by <code>ordinal()</code>. It's faster, safer, and clearer.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#the-bad-way-ordinal-indexing","title":"The Bad Way: Ordinal Indexing","text":"<pre><code>// \u274c BAD: Array indexed by ordinal\npublic class Plant {\n    enum LifeCycle { ANNUAL, PERENNIAL, BIENNIAL }\n\n    final LifeCycle lifeCycle;\n\n    // Grouping plants by lifecycle using ordinal\n    Set&lt;Plant&gt;[] plantsByLifeCycle =\n        (Set&lt;Plant&gt;[]) new Set[LifeCycle.values().length];\n\n    for (int i = 0; i &lt; plantsByLifeCycle.length; i++)\n        plantsByLifeCycle[i] = new HashSet&lt;&gt;();\n\n    for (Plant p : garden)\n        plantsByLifeCycle[p.lifeCycle.ordinal()].add(p);  // ordinal = fragile!\n}\n</code></pre> <p>Problems: Unchecked cast, no type safety on the index, <code>ArrayIndexOutOfBoundsException</code> risk, requires manual labeling for output.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#the-good-way-enummap","title":"The Good Way: EnumMap","text":"<pre><code>// \u2705 GOOD: EnumMap \u2014 type-safe, fast, readable\nMap&lt;LifeCycle, Set&lt;Plant&gt;&gt; plantsByLifeCycle =\n    new EnumMap&lt;&gt;(LifeCycle.class);\n\nfor (LifeCycle lc : LifeCycle.values())\n    plantsByLifeCycle.put(lc, new HashSet&lt;&gt;());\n\nfor (Plant p : garden)\n    plantsByLifeCycle.get(p.lifeCycle).add(p);\n\n// Even better with streams (Java 8+):\nMap&lt;LifeCycle, List&lt;Plant&gt;&gt; plantsByLifeCycle = garden.stream()\n    .collect(groupingBy(p -&gt; p.lifeCycle,\n        () -&gt; new EnumMap&lt;&gt;(LifeCycle.class), toList()));\n</code></pre> <pre><code>flowchart LR\n    subgraph ordinal[\" \u274c ORDINAL INDEXING \"]\n        A[\"array[enum.ordinal()]\"]\n        A1[\"Unchecked casts\"]\n        A2[\"No type safety\"]\n    end\n    subgraph enummap[\" \u2705 ENUM MAP \"]\n        E[\"enumMap.get(enum)\"]\n        E1[\"Type-safe keys\"]\n        E2[\"Internally array-backed\"]\n    end\n    ordinal -.replace with.-&gt; enummap</code></pre> <p>Performance</p> <p><code>EnumMap</code> is internally backed by an array, so it matches the performance of ordinal indexing while being type-safe. It's essentially a compiler-checked version of ordinal indexing.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#item-38-emulate-extensible-enums-with-interfaces","title":"Item 38: Emulate Extensible Enums with Interfaces","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#key-takeaways_5","title":"Key Takeaways","text":"<p>Enums cannot extend other enums \u2014 this is by design, because enum inheritance would break the guarantee that you can enumerate all constants. However, you can make enums implement interfaces to achieve a form of extensibility.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#the-pattern-operation-interface","title":"The Pattern: Operation Interface","text":"<pre><code>// Interface defines the contract\npublic interface Operation {\n    double apply(double x, double y);\n}\n\n// Basic operations \u2014 one enum\npublic enum BasicOperation implements Operation {\n    PLUS(\"+\")  { public double apply(double x, double y) { return x + y; } },\n    MINUS(\"-\") { public double apply(double x, double y) { return x - y; } },\n    TIMES(\"*\") { public double apply(double x, double y) { return x * y; } },\n    DIVIDE(\"/\"){ public double apply(double x, double y) { return x / y; } };\n\n    private final String symbol;\n    BasicOperation(String symbol) { this.symbol = symbol; }\n    @Override public String toString() { return symbol; }\n}\n\n// Extended operations \u2014 another enum implementing the same interface!\npublic enum ExtendedOperation implements Operation {\n    EXP(\"^\")  { public double apply(double x, double y) { return Math.pow(x, y); } },\n    MOD(\"%\")  { public double apply(double x, double y) { return x % y; } };\n\n    private final String symbol;\n    ExtendedOperation(String symbol) { this.symbol = symbol; }\n    @Override public String toString() { return symbol; }\n}\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#using-the-pattern","title":"Using the Pattern","text":"<pre><code>// Works with ANY Operation implementation!\nprivate static &lt;T extends Enum&lt;T&gt; &amp; Operation&gt; void test(\n        Class&lt;T&gt; opEnumType, double x, double y) {\n    for (Operation op : opEnumType.getEnumConstants())\n        System.out.printf(\"%f %s %f = %f%n\", x, op, y, op.apply(x, y));\n}\n\ntest(BasicOperation.class, 3, 2);\ntest(ExtendedOperation.class, 3, 2);  // Seamlessly extended!\n</code></pre> <pre><code>flowchart TD\n    I[Operation Interface] --&gt; B[BasicOperation Enum]\n    I --&gt; E[ExtendedOperation Enum]\n    I --&gt; F[Future Operations...]\n\n    B --&gt; PLUS &amp; MINUS &amp; TIMES &amp; DIVIDE\n    E --&gt; EXP &amp; MOD</code></pre> <p>When to Use</p> <ul> <li>Use this pattern when you need a fixed set of operations that clients might want to extend \u2014 such as calculation engines, command patterns, or plugin systems.</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#item-39-prefer-annotations-to-naming-patterns","title":"Item 39: Prefer Annotations to Naming Patterns","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#key-takeaways_6","title":"Key Takeaways","text":"<p>Before annotations, frameworks relied on naming conventions to identify special methods (e.g., JUnit 3 required test methods to start with <code>test</code>). Annotations are superior because the compiler can enforce them.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#naming-patterns-were-fragile","title":"Naming Patterns Were Fragile","text":"<pre><code>// \u274c BAD: JUnit 3 naming pattern\npublic class MyTest {\n    // Oops! \"tset\" instead of \"test\" \u2014 silently ignored, no error!\n    public void tsetSafetyOverride() {\n        // This test NEVER runs, and you don't even know it!\n    }\n}\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#annotations-are-enforced","title":"Annotations Are Enforced","text":"<pre><code>// \u2705 GOOD: JUnit 4+ annotations\npublic class MyTest {\n    @Test  // Clear intent, compiler-checked\n    public void safetyOverride() {\n        // Will definitely run!\n    }\n\n    @Test(expected = ArithmeticException.class)\n    public void divisionByZero() {\n        int result = 1 / 0;\n    }\n}\n</code></pre> Aspect Naming Patterns Annotations Typo detection \u274c Silent failure \u2705 Compile error Parameter support \u274c No \u2705 Yes (<code>expected</code>, <code>timeout</code>) Scope control \u274c Limited \u2705 Methods, classes, fields, etc. IDE support \u274c Minimal \u2705 Auto-complete, warnings <p>The Bigger Picture</p> <ul> <li> <p>While we haven't written custom annotations yet, this item teaches an important principle: prefer compiler-enforced contracts over convention-based ones. This mindset applies beyond annotations</p> </li> <li> <p>it's why enums beat int constants (Item 34) and generics beat casts.</p> </li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#theoretical-framework","title":"Theoretical Framework","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#mental-model-for-enums-in-java","title":"Mental Model for Enums in Java","text":"<pre><code>flowchart TD\n    subgraph what[\" WHAT ARE ENUMS? \"]\n        W1[\"Full-fledged classes\"]\n        W2[\"Fixed set of instances\"]\n        W3[\"Can have fields &amp; methods\"]\n        W4[\"Can implement interfaces\"]\n    end\n\n    subgraph tools[\" ENUM TOOLING \"]\n        T1[\"EnumSet \u2192 replaces bit fields\"]\n        T2[\"EnumMap \u2192 replaces ordinal arrays\"]\n        T3[\"Interfaces \u2192 emulate extensibility\"]\n    end\n\n    subgraph rules[\" GOLDEN RULES \"]\n        R1[\"Never derive from ordinal()\"]\n        R2[\"Use instance fields for data\"]\n        R3[\"Prefer enums to int constants\"]\n    end\n\n    what --&gt; tools --&gt; rules</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#arrays-vs-lists-decision-tree","title":"Arrays vs Lists Decision Tree","text":"<pre><code>flowchart TD\n    A[Need a collection?] --&gt; B{Primitives in hot loop?}\n    B --&gt;|Yes| C[\"Use array: int[], double[]\"]\n    B --&gt;|No| D{Fixed size known?}\n    D --&gt;|Yes, and small| E{Need type safety?}\n    E --&gt;|No| F[\"Array is OK\"]\n    E --&gt;|Yes| G[\"Use List\"]\n    D --&gt;|No| G\n    G --&gt; H{Need fast random access?}\n    H --&gt;|Yes| I[\"ArrayList\"]\n    H --&gt;|Lots of insert/remove| J[\"LinkedList\"]</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#reflections-connections","title":"Reflections &amp; Connections","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#connections-to-course-material","title":"Connections to Course Material","text":"Effective Java Tim's Course (Topic 3) Item 28: Lists &gt; Arrays Part 1 \u2192 Part 2 transition showed this in practice Item 34: Enums &gt; int constants Part 4: <code>DayOfTheWeek</code> enum vs raw int days Item 35: Instance fields &gt; ordinals Part 4: <code>Topping.getPrice()</code> uses switch, not ordinal math Item 36: EnumSet &gt; bit fields New concept \u2014 extends Part 4's enum knowledge Item 37: EnumMap &gt; ordinal indexing New concept \u2014 type-safe enum-keyed maps Item 38: Extensible enums via interfaces New concept \u2014 combines enums with interfaces","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#new-perspectives-gained","title":"New Perspectives Gained","text":"<ol> <li>Arrays are covariant \u2014 this is Java's design mistake that generics corrected with invariance</li> <li>Enums are classes \u2014 not just named integers; they can have fields, methods, and constructors</li> <li><code>ordinal()</code> is a trap \u2014 it exists for internal use by <code>EnumSet</code> and <code>EnumMap</code>, not for application code</li> <li>EnumSet is magic \u2014 it combines the readability of enums with the performance of bit manipulation</li> <li>Extensible enums via interfaces \u2014 elegant workaround for enum's single-inheritance limitation</li> </ol>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#summary-points","title":"Summary Points","text":"<ol> <li>Lists over Arrays: Prefer <code>List&lt;T&gt;</code> to <code>T[]</code> \u2014 you get compile-time type safety instead of runtime <code>ArrayStoreException</code></li> <li>Enums over int constants: Enums provide type safety, namespace, iteration, printing, and extensibility</li> <li>Instance fields over ordinals: Never use <code>ordinal()</code> to derive data \u2014 add explicit fields to your enums</li> <li>EnumSet over bit fields: Same performance, much better readability and type safety</li> <li>EnumMap over ordinal arrays: Internally array-backed but compiler-checked \u2014 best of both worlds</li> <li>Interfaces for extensibility: When enums need to be \"extended\", define a common interface</li> <li>Annotations over naming: Prefer compiler-enforced contracts to convention-based ones</li> </ol>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/book-reading/#bookmarks-page-references","title":"Bookmarks &amp; Page References","text":"Topic Item Key Insight Lists &gt; Arrays Item 28 Arrays are covariant (runtime errors), generics are invariant (compile errors) Enums &gt; int constants Item 34 Enums are full classes with type safety and iteration Instance fields &gt; ordinals Item 35 <code>ordinal()</code> is fragile \u2014 always use explicit fields EnumSet &gt; bit fields Item 36 Single <code>long</code> internally, readable <code>EnumSet.of()</code> externally EnumMap &gt; ordinal arrays Item 37 Type-safe, array-backed, no unchecked casts Extensible enums Item 38 Implement interface to share behavior across enum types Annotations &gt; naming Item 39 Compiler catches typos that naming conventions miss <p>Last Updated: 2026-02-11</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/","title":"Summary: Arrays, Lists &amp; Autoboxing","text":"<p>Combined Knowledge from: Tim Buchalka's Course + Effective Java Mastery Level: </p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#topic-overview","title":"Topic Overview","text":"<p>A deep understanding of Java's core data structures \u2014 from fixed-size arrays to resizable lists, the iteration patterns that traverse them, and the autoboxing mechanism that bridges primitive and object worlds. This summary covers both the how (practical usage) and the why (memory layout, performance, JVM internals).</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#the-four-data-structures","title":"The Four Data Structures","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#1-arrays","title":"1. Arrays","text":"<p>Definition: A fixed-size, contiguous block of memory holding elements of the same type. The most fundamental data structure in Java.</p> <pre><code>flowchart LR\n    subgraph memory[\" ARRAY MEMORY LAYOUT \"]\n        direction LR\n        I0[\"[0] = 10\"]\n        I1[\"[1] = 20\"]\n        I2[\"[2] = 30\"]\n        I3[\"[3] = 40\"]\n        I4[\"[4] = 50\"]\n    end\n\n    REF[\"int[] arr\"] --&gt; I0</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#key-properties","title":"Key Properties","text":"Property Detail Size Fixed at creation \u2014 cannot grow or shrink Memory Contiguous \u2014 elements stored side-by-side Access O(1) random access via index Type Can hold primitives (<code>int[]</code>) or objects (<code>String[]</code>) Covariant <code>Sub[]</code> is a subtype of <code>Super[]</code> \u2014 a design flaw (Item 28)","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#essential-operations-big-o","title":"Essential Operations &amp; Big O","text":"Operation Big O Notes Access by index O(1) Direct memory offset calculation Search (unsorted) O(n) Linear scan required Search (sorted) O(log n) <code>Arrays.binarySearch()</code> Insert/Delete O(n) Must shift elements Sort O(n log n) <code>Arrays.sort()</code> \u2014 Dual-Pivot Quicksort for primitives, TimSort for objects","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#javautilarrays-utilities","title":"java.util.Arrays Utilities","text":"<pre><code>int[] arr = {5, 3, 1, 4, 2};\n\nArrays.sort(arr);                    // [1, 2, 3, 4, 5]\nArrays.fill(arr, 0);                 // [0, 0, 0, 0, 0]\nint[] copy = Arrays.copyOf(arr, 10); // Copy with new length\nString s = Arrays.toString(arr);     // \"[0, 0, 0, 0, 0]\"\nboolean eq = Arrays.equals(a, b);    // Deep value comparison\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#2-arraylist","title":"2. ArrayList","text":"<p>Definition: A resizable array implementation of the <code>List</code> interface. Internally backed by an <code>Object[]</code> that grows automatically.</p> <pre><code>flowchart TD\n    subgraph al[\" ArrayList INTERNALS \"]\n        direction TB\n        ARR[\"Object[] elementData\"]\n        SIZE[\"size = 3\"]\n        CAP[\"capacity = 10\"]\n\n        subgraph data[\" Backing Array \"]\n            D0[\"[0] A\"]\n            D1[\"[1] B\"]\n            D2[\"[2] C\"]\n            D3[\"[3] null\"]\n            D4[\"[4] null\"]\n            D5[\"...\"]\n        end\n    end\n\n    ARR --&gt; data</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#key-properties_1","title":"Key Properties","text":"Property Detail Size Dynamic \u2014 grows automatically (by ~50%) Memory Contiguous backing array + overhead for bookkeeping Access O(1) random access (like arrays) Insertion O(1) amortized at end, O(n) at arbitrary position Deletion O(n) \u2014 must shift elements to fill gap","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#growth-strategy","title":"Growth Strategy","text":"<p>When the backing array is full: 1. Allocate new array with <code>newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code> (~50% growth) 2. Copy all elements to the new array \u2014 <code>Arrays.copyOf()</code> 3. Old array becomes eligible for garbage collection</p> <pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();  // Default capacity: 10\n// After adding 11th element: capacity grows to 15\n// After adding 16th element: capacity grows to 22\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#crud-quick-reference","title":"CRUD Quick Reference","text":"<pre><code>List&lt;String&gt; items = new ArrayList&lt;&gt;(List.of(\"A\", \"B\", \"C\"));\n\n// CREATE\nitems.add(\"D\");              // Append\nitems.add(1, \"X\");           // Insert at index 1\n\n// READ\nString first = items.get(0); // By index O(1)\nint idx = items.indexOf(\"B\");// By value O(n)\n\n// UPDATE\nitems.set(0, \"Z\");           // Replace at index\n\n// DELETE\nitems.remove(0);             // By index\nitems.remove(\"B\");           // By value (first occurrence)\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#3-linkedlist","title":"3. LinkedList","text":"<p>Definition: A doubly-linked list where each node holds a value and pointers to the previous and next nodes. Also implements <code>Queue</code>, <code>Deque</code>, and can be used as a <code>Stack</code>.</p> <pre><code>flowchart LR\n    HEAD[\"head\"] --&gt; N1\n    subgraph N1[\"Node 1\"]\n        V1[\"data: A\"]\n    end\n    N1 &lt;--&gt; N2\n    subgraph N2[\"Node 2\"]\n        V2[\"data: B\"]\n    end\n    N2 &lt;--&gt; N3\n    subgraph N3[\"Node 3\"]\n        V3[\"data: C\"]\n    end\n    N3 --&gt; TAIL[\"tail\"]</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#key-properties_2","title":"Key Properties","text":"Property Detail Size Dynamic \u2014 grows node-by-node Memory Non-contiguous \u2014 each node is a separate heap object Access O(n) \u2014 must traverse from head or tail Insert/Delete at ends O(1) \u2014 just rewire pointers Insert/Delete at middle O(n) \u2014 must traverse to position first","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#arraylist-vs-linkedlist","title":"ArrayList vs LinkedList","text":"Operation ArrayList LinkedList Winner <code>get(i)</code> O(1) O(n) ArrayList <code>add(end)</code> O(1) amortized O(1) Tie <code>add(0, e)</code> O(n) shift O(1) LinkedList <code>remove(0)</code> O(n) shift O(1) LinkedList Memory per element ~4 bytes (ref) ~24 bytes (node) ArrayList Cache friendliness Excellent Poor ArrayList Iterator remove O(n) shift O(1) LinkedList <p>Rule of thumb: Use <code>ArrayList</code> by default. Use <code>LinkedList</code> only when you need frequent insertions/removals at both ends (Queue/Deque pattern) or safe removal during iteration.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#multi-interface-usage","title":"Multi-Interface Usage","text":"<pre><code>LinkedList&lt;String&gt; ll = new LinkedList&lt;&gt;();\n\n// As List\nll.add(\"A\"); ll.get(0);\n\n// As Queue (FIFO)\nll.offer(\"B\"); ll.poll();     // Add to tail, remove from head\n\n// As Deque (double-ended)\nll.offerFirst(\"C\"); ll.offerLast(\"D\");\nll.pollFirst(); ll.pollLast();\n\n// As Stack (LIFO)\nll.push(\"E\"); ll.pop();       // Add/remove from head\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#4-enums","title":"4. Enums","text":"<p>Definition: A special class type that defines a fixed set of named constants. Each constant is a <code>public static final</code> instance of the enum class.</p> <pre><code>flowchart TD\n    subgraph enum[\" DayOfTheWeek.class \"]\n        SUN[\"SUN (ordinal: 0)\"]\n        MON[\"MON (ordinal: 1)\"]\n        TUE[\"TUE (ordinal: 2)\"]\n        WED[\"WED (ordinal: 3)\"]\n        THU[\"THU (ordinal: 4)\"]\n        FRI[\"FRI (ordinal: 5)\"]\n        SAT[\"SAT (ordinal: 6)\"]\n    end\n\n    VALUES[\"values()\"] --&gt; enum</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#what-enums-really-are","title":"What Enums Really Are","text":"<p>Under the hood, <code>enum DayOfTheWeek { SUN, MON, ... }</code> compiles to:</p> <pre><code>public final class DayOfTheWeek extends Enum&lt;DayOfTheWeek&gt; {\n    public static final DayOfTheWeek SUN = new DayOfTheWeek(\"SUN\", 0);\n    public static final DayOfTheWeek MON = new DayOfTheWeek(\"MON\", 1);\n    // ...\n\n    private DayOfTheWeek(String name, int ordinal) {\n        super(name, ordinal);\n    }\n\n    public static DayOfTheWeek[] values() { ... }\n    public static DayOfTheWeek valueOf(String name) { ... }\n}\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#enum-capabilities","title":"Enum Capabilities","text":"Feature Example Built-in methods <code>name()</code>, <code>ordinal()</code>, <code>values()</code>, <code>valueOf()</code> Switch support <code>switch(day) { case MON -&gt; ... }</code> Custom fields <code>BACON(1.50)</code> \u2014 constructor with args Custom methods <code>getPrice()</code> \u2014 behavior per constant Implement interfaces <code>enum Op implements Calculable { ... }</code>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#golden-rules-from-effective-java","title":"Golden Rules (from Effective Java)","text":"<ol> <li>Use enums instead of <code>int</code> constants (Item 34) \u2014 type safety, readability, iteration</li> <li>Never derive data from <code>ordinal()</code> (Item 35) \u2014 use instance fields instead</li> <li>Use <code>EnumSet</code> for sets of enums (Item 36) \u2014 replaces bit fields, same performance</li> <li>Use <code>EnumMap</code> for enum-keyed maps (Item 37) \u2014 type-safe, array-backed internally</li> </ol>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#key-internals-to-understand","title":"Key Internals to Understand","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#1-array-memory-layout-cache-performance","title":"1. Array Memory Layout &amp; Cache Performance","text":"<p>Arrays store elements in a contiguous block of memory. This is critical for performance because of CPU cache behavior.</p> <pre><code>flowchart LR\n    subgraph cache[\" CPU CACHE LINE (64 bytes) \"]\n        direction LR\n        A0[\"arr[0]\"]\n        A1[\"arr[1]\"]\n        A2[\"arr[2]\"]\n        A3[\"arr[3]\"]\n        A4[\"arr[4]\"]\n        A5[\"arr[5]\"]\n        A6[\"arr[6]\"]\n        A7[\"arr[7]\"]\n    end\n\n    CPU[\"CPU\"] --&gt;|\"one fetch\"| cache</code></pre> <p>When you access <code>arr[0]</code>, the CPU fetches an entire cache line (~64 bytes). For <code>int[]</code>, that's ~16 consecutive elements loaded at once. Sequential reads become almost free.</p> <p>LinkedList nodes, by contrast, are scattered across the heap. Each node access may cause a cache miss, requiring a separate memory fetch.</p> Data Structure Cache Behavior Sequential Read Speed <code>int[]</code> Excellent \u2014 contiguous ~1 ns/element <code>ArrayList</code> Good \u2014 contiguous backing array ~2\u20133 ns/element <code>LinkedList</code> Poor \u2014 scattered nodes ~5\u201310 ns/element","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#2-arraylist-resizing-amortized-o1","title":"2. ArrayList Resizing: Amortized O(1)","text":"<p>When ArrayList's backing array is full, it creates a new one ~50% larger and copies everything. This copy is O(n), but happens infrequently enough to be amortized O(1).</p> <pre><code>flowchart TD\n    subgraph adds[\" ADDING 17 ELEMENTS \"]\n        A1[\"Add 1\u201310: fits in initial capacity\"]\n        A2[\"Add 11: RESIZE to 15, copy 10 elements\"]\n        A3[\"Add 12\u201315: fits\"]\n        A4[\"Add 16: RESIZE to 22, copy 15 elements\"]\n        A5[\"Add 17: fits\"]\n    end\n\n    A1 --&gt; A2 --&gt; A3 --&gt; A4 --&gt; A5</code></pre> <p>Amortized analysis: Over n insertions, total copy cost \u2248 n + n/2 + n/4 + ... \u2248 2n. Divided by n insertions = O(1) per insertion on average.</p> <p>Performance Tip</p> <p>If you know the final size, use <code>new ArrayList&lt;&gt;(expectedSize)</code> to avoid all resizing overhead.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#3-concurrentmodificationexception-iterator-safety","title":"3. ConcurrentModificationException &amp; Iterator Safety","text":"<p>The <code>modCount</code> mechanism is Java's fast-fail protection against structural modification during iteration.</p> <pre><code>flowchart TD\n    subgraph safe[\" \u2705 SAFE: Iterator.remove() \"]\n        S1[\"Iterator tracks modCount\"]\n        S2[\"remove() updates BOTH list and iterator's expectedModCount\"]\n        S3[\"Next call: modCount == expectedModCount \u2713\"]\n    end\n\n    subgraph unsafe[\" \u274c UNSAFE: List.remove() during for-each \"]\n        U1[\"For-each uses hidden Iterator\"]\n        U2[\"list.remove() increments modCount\"]\n        U3[\"Iterator.next() checks: modCount \u2260 expectedModCount\"]\n        U4[\"Throws ConcurrentModificationException!\"]\n    end</code></pre> <pre><code>// \u274c THROWS ConcurrentModificationException\nfor (String item : list) {\n    if (item.equals(\"remove me\")) {\n        list.remove(item);  // Modifies list behind iterator's back!\n    }\n}\n\n// \u2705 SAFE \u2014 Iterator.remove() keeps state in sync\nIterator&lt;String&gt; it = list.iterator();\nwhile (it.hasNext()) {\n    if (it.next().equals(\"remove me\")) {\n        it.remove();  // Updates both modCount and expectedModCount\n    }\n}\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#4-autoboxing-what-the-jvm-actually-does","title":"4. Autoboxing: What the JVM Actually Does","text":"<p>When you write <code>Integer x = 42;</code>, the compiler inserts <code>Integer x = Integer.valueOf(42);</code>. This is autoboxing.</p> <pre><code>flowchart LR\n    subgraph boxing[\" AUTOBOXING \"]\n        P1[\"int 42\"] --&gt;|\"Integer.valueOf(42)\"| W1[\"Integer object\"]\n    end\n\n    subgraph unboxing[\" UNBOXING \"]\n        W2[\"Integer object\"] --&gt;|\"intValue()\"| P2[\"int 42\"]\n    end</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#the-integer-cache-trap","title":"The Integer Cache Trap","text":"<p><code>Integer.valueOf()</code> caches values between -128 and 127. This creates a subtle identity trap:</p> <pre><code>Integer a = 127;  // Cached: Integer.valueOf(127)\nInteger b = 127;  // Same cached object!\nSystem.out.println(a == b);      // true \u2014 same object!\n\nInteger c = 128;  // NOT cached: new Integer(128)\nInteger d = 128;  // Different new Integer(128)\nSystem.out.println(c == d);      // false \u2014 different objects!\nSystem.out.println(c.equals(d)); // true \u2014 same VALUE\n</code></pre> Value Range <code>==</code> Behavior Why -128 to 127 Returns <code>true</code> Same cached <code>Integer</code> object &lt; -128 or &gt; 127 Returns <code>false</code> Different heap objects Any range with <code>.equals()</code> Correct Compares values, not references <p>Always Use <code>.equals()</code> for Boxed Types</p> <p>Never use <code>==</code> on <code>Integer</code>, <code>Long</code>, <code>Double</code>, etc. The caching behavior makes <code>==</code> unreliable and unpredictable.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#performance-cost-of-autoboxing","title":"Performance Cost of Autoboxing","text":"<pre><code>// \u274c SLOW: Autoboxing in a loop \u2014 creates ~millions of Integer objects!\nLong sum = 0L;\nfor (long i = 0; i &lt; Integer.MAX_VALUE; i++) {\n    sum += i;  // Unbox sum, add, re-box \u2014 every iteration!\n}\n\n// \u2705 FAST: Use primitives\nlong sum = 0L;\nfor (long i = 0; i &lt; Integer.MAX_VALUE; i++) {\n    sum += i;  // No boxing at all\n}\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#5-enum-internals-how-the-jvm-handles-enums","title":"5. Enum Internals: How the JVM Handles Enums","text":"<p>Enums look like simple constants, but the JVM treats them as full classes:</p> <pre><code>flowchart TD\n    subgraph loading[\" CLASS LOADING \"]\n        L1[\"JVM loads enum class\"]\n        L2[\"Creates static final instances\"]\n        L3[\"Populates $VALUES array\"]\n        L4[\"Enum constants ready\"]\n        L1 --&gt; L2 --&gt; L3 --&gt; L4\n    end\n\n    subgraph guarantees[\" JVM GUARANTEES \"]\n        G1[\"Singleton per constant\"]\n        G2[\"Serialization-safe\"]\n        G3[\"Reflection-proof\"]\n        G4[\"Thread-safe initialization\"]\n    end\n\n    loading --&gt; guarantees</code></pre> <p>Key guarantees: - Each enum constant is instantiated exactly once by the JVM - Enum constructors are called during class loading (static initialization) - <code>values()</code> returns a clone of the internal <code>$VALUES</code> array each time - Enums are inherently thread-safe \u2014 no synchronization needed</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#design-patterns-best-practices","title":"Design Patterns &amp; Best Practices","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#choosing-the-right-data-structure","title":"Choosing the Right Data Structure","text":"<pre><code>flowchart TD\n    START[Need to store multiple elements?] --&gt; Q1{Fixed size known?}\n    Q1 --&gt;|Yes, primitives| ARR[\"Array: int[], double[]\"]\n    Q1 --&gt;|Yes, objects| Q2{Will size change later?}\n    Q2 --&gt;|No| ARR2[\"Array or List.of()\"]\n    Q2 --&gt;|Yes| AL[\"ArrayList\"]\n    Q1 --&gt;|No| Q3{Primary operation?}\n    Q3 --&gt;|\"Random access\"| AL\n    Q3 --&gt;|\"Queue/Deque\"| LL[\"LinkedList or ArrayDeque\"]\n    Q3 --&gt;|\"Insert/remove at ends\"| LL\n    Q3 --&gt;|\"General purpose\"| AL</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#array-arraylist-conversions","title":"Array \u2194 ArrayList Conversions","text":"<pre><code>// Array \u2192 ArrayList (mutable)\nString[] arr = {\"A\", \"B\", \"C\"};\nList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList(arr));\n\n// ArrayList \u2192 Array\nString[] back = list.toArray(new String[0]);\n\n// Immutable list from values\nList&lt;String&gt; immutable = List.of(\"A\", \"B\", \"C\");\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#effective-java-best-practices-applied","title":"Effective Java Best Practices Applied","text":"Practice Item Rationale Prefer lists to arrays Item 28 Compile-time type safety vs runtime errors Use enums, not int constants Item 34 Type safety, namespace, iteration, printing Use instance fields, not ordinals Item 35 Order-independent, allows duplicates and gaps Use <code>EnumSet</code> for flag sets Item 36 Same speed as bit fields, far more readable Use <code>EnumMap</code> for enum keys Item 37 Type-safe, internally array-backed","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#common-pitfalls","title":"Common Pitfalls","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#1-array-index-errors","title":"1. Array Index Errors","text":"<pre><code>int[] arr = new int[5];\narr[5] = 10;  // \u274c ArrayIndexOutOfBoundsException! (valid: 0-4)\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#2-arraysaslist-returns-fixed-size-list","title":"2. Arrays.asList() Returns Fixed-Size List","text":"<pre><code>List&lt;String&gt; list = Arrays.asList(\"A\", \"B\", \"C\");\nlist.add(\"D\");    // \u274c UnsupportedOperationException!\nlist.set(0, \"Z\"); // \u2705 Modification of existing elements is OK\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#3-autoboxing-trap","title":"3. Autoboxing == Trap","text":"<pre><code>Integer a = 200;\nInteger b = 200;\nSystem.out.println(a == b);      // \u274c false! (outside cache range)\nSystem.out.println(a.equals(b)); // \u2705 true\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#4-concurrentmodificationexception","title":"4. ConcurrentModificationException","text":"<pre><code>for (String s : list) {\n    list.remove(s);  // \u274c ConcurrentModificationException!\n}\n// \u2705 Use Iterator.remove() or removeIf()\nlist.removeIf(s -&gt; s.equals(\"target\"));\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#5-nullpointerexception-from-unboxing","title":"5. NullPointerException from Unboxing","text":"<pre><code>Integer boxed = null;\nint value = boxed;  // \u274c NullPointerException! (unboxing null)\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#6-relying-on-ordinal","title":"6. Relying on ordinal()","text":"<pre><code>// \u274c BAD: Breaks if constants are reordered\nint index = myEnum.ordinal();  // Don't use this for logic!\n\n// \u2705 GOOD: Use explicit fields\ndouble price = myTopping.getPrice();  // Instance method\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#best-practices-checklist","title":"Best Practices Checklist","text":"<ul> <li> Prefer <code>ArrayList</code> over arrays for object collections (Item 28)</li> <li> Use arrays for primitives in performance-critical code</li> <li> Pre-size <code>ArrayList</code> when count is known: <code>new ArrayList&lt;&gt;(expectedSize)</code></li> <li> Use <code>Iterator</code> or <code>removeIf()</code> for safe modification during iteration</li> <li> Always use <code>.equals()</code> for boxed primitive comparison, never <code>==</code></li> <li> Use primitives instead of wrapper classes in performance-sensitive loops</li> <li> Use enums instead of <code>public static final int</code> constants (Item 34)</li> <li> Add instance fields to enums instead of deriving from <code>ordinal()</code> (Item 35)</li> <li> Use <code>EnumSet</code> for sets of enum flags (Item 36)</li> <li> Use <code>EnumMap</code> for enum-keyed maps (Item 37)</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#learning-resources","title":"Learning Resources","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#array-memory-performance","title":"Array Memory &amp; Performance","text":"<ul> <li>Baeldung - Arrays in Java Memory</li> <li>Oracle - Arrays Tutorial</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#arraylist-internals","title":"ArrayList Internals","text":"<ul> <li>Baeldung - ArrayList Internals</li> <li>OpenJDK ArrayList Source</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#linkedlist-vs-arraylist","title":"LinkedList vs ArrayList","text":"<ul> <li>Baeldung - ArrayList vs LinkedList</li> <li>StackOverflow - When to use LinkedList</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#autoboxing-integer-cache","title":"Autoboxing &amp; Integer Cache","text":"<ul> <li>Oracle - Autoboxing and Unboxing</li> <li>Baeldung - Integer Cache</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#enums-deep-dive","title":"Enums Deep Dive","text":"<ul> <li>Oracle - Enum Types Tutorial</li> <li>Baeldung - Guide to Java Enums</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#effective-java","title":"Effective Java","text":"<ul> <li>Effective Java 3<sup>rd</sup> Edition</li> <li>GitHub - Effective Java Summary</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#related-topics","title":"Related Topics","text":"<ul> <li>Syntax, Variables &amp; Control Flow</li> <li>OOP &amp; Class Design Internals</li> <li>Abstraction, Interfaces, Generics &amp; Nested Classes</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/summary/#references","title":"References","text":"<ul> <li>Course: Tim Buchalka - Java Programming Masterclass (Sections 9\u201310)</li> <li>Book: Effective Java - Joshua Bloch (Items 28, 34\u201339)</li> <li>API: java.util.Arrays</li> <li>API: java.util.ArrayList</li> <li>API: java.util.LinkedList</li> <li>API: java.util.Iterator</li> <li>API: java.lang.Enum</li> <li>API: java.lang.Integer</li> </ul> <p>Completed: 2026-02-11 | Confidence: 9/10</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/","title":"Topic Note: ArrayList \u2014 Java's Resizable Array","text":"<p>Course: Java Programming Masterclass - Tim Buchalka (Udemy)</p> <p>Section: 10 - Mastering Lists, Iterators, and Autoboxing (Part 1: ArrayList)</p> <p>Status:  Complete (Part 2 of Topic 3)</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#learning-objectives","title":"Learning Objectives","text":"<ul> <li> Understand why arrays aren't enough and what the Collections framework provides</li> <li> Know what the <code>List</code> interface is and what methods it guarantees</li> <li> Create and use <code>ArrayList</code> with proper type safety (parameterized types)</li> <li> Perform CRUD operations: add, get, set, remove, clear</li> <li> Search using <code>contains</code>, <code>indexOf</code>, and <code>lastIndexOf</code></li> <li> Sort with <code>Comparator.naturalOrder()</code> and <code>Comparator.reverseOrder()</code></li> <li> Convert between arrays and ArrayLists in both directions</li> <li> Understand the differences between <code>List.of()</code>, <code>Arrays.asList()</code>, and <code>new ArrayList&lt;&gt;()</code></li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#1-why-collections-beyond-basic-arrays","title":"1. Why Collections? Beyond Basic Arrays","text":"<p>Arrays are powerful, but they have a fundamental limitation: fixed size. Once created, you cannot add or remove elements \u2014 you can only modify existing ones.</p> <p>Java provides a complete library of resizable, feature-rich containers called the Collections Framework (in <code>java.util</code>). Collections take arrays to the next level:</p> Feature Array Collections Size Fixed at creation Dynamic (grows and shrinks) Methods Only <code>.length</code> field Rich API (<code>add</code>, <code>remove</code>, <code>sort</code>, <code>contains</code>, etc.) Type safety Built-in (e.g., <code>int[]</code>) Generics with <code>&lt;Type&gt;</code> Primitives Supported directly Wrapper classes only (<code>Integer</code>, not <code>int</code>) <p>The two most common <code>List</code> implementations are ArrayList and LinkedList. This note focuses on <code>ArrayList</code>.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#2-the-list-interface","title":"2. The List Interface","text":"<p>A <code>List</code> is a special type in Java called an interface. An interface describes a set of method signatures that all implementing classes must provide.</p> <p>Think of it as a contract: any class that \"implements\" <code>List</code> agrees to have methods like <code>add</code>, <code>remove</code>, <code>get</code>, <code>contains</code>, <code>indexOf</code>, etc.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#classes-that-implement-list","title":"Classes That Implement <code>List</code>","text":"Class Description <code>ArrayList</code> Resizable array \u2014 most commonly used <code>LinkedList</code> Doubly-linked list \u2014 efficient insert/remove at ends <code>Stack</code> LIFO collection (legacy, prefer <code>Deque</code>) <code>CopyOnWriteArrayList</code> Thread-safe variant <code>AbstractList</code> Base class for custom list implementations <p>Interface Preview</p> <ul> <li>Interfaces are covered in depth in the next section of the course. For now, think of <code>List</code> as a guarantee that certain methods exist on any list class.</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#3-arraylist-fundamentals","title":"3. ArrayList Fundamentals","text":"<p>An <code>ArrayList</code> is a resizable-array implementation of the <code>List</code> interface. Under the hood, it maintains an internal array that is larger than what you currently need:</p> <pre><code>flowchart LR\n    subgraph arraylist[\" ArrayList Internals \"]\n        direction LR\n        E0[\"[0]&lt;br/&gt;Milk\"] --- E1[\"[1]&lt;br/&gt;Eggs\"] --- E2[\"[2]&lt;br/&gt;Bread\"] --- E3[\"[3]&lt;br/&gt;&lt;i&gt;empty&lt;/i&gt;\"] --- E4[\"[4]&lt;br/&gt;&lt;i&gt;empty&lt;/i&gt;\"]\n    end\n\n    SIZE[\"size = 3\"] -.-&gt; E2\n    CAP[\"capacity = 5\"] -.-&gt; E4</code></pre> Concept Description Size Number of elements actually stored (retrieved via <code>.size()</code>) Capacity Total slots allocated in the internal array Growth When <code>size == capacity</code>, a new, larger array is allocated and elements are copied over \u2014 automatically, behind the scenes <p>This is why <code>ArrayList</code> is called \"resizable\" \u2014 you never manage the capacity yourself.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#4-type-safety-raw-vs-parameterized","title":"4. Type Safety: Raw vs Parameterized","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#the-problem-raw-arraylist","title":"The Problem: Raw ArrayList","text":"<p>If you create an <code>ArrayList</code> without specifying a type, Java defaults to <code>Object</code>:</p> <pre><code>ArrayList objectList = new ArrayList&lt;&gt;();    // Raw type \u2014 WARNING!\nobjectList.add(new GroceryItem(\"Butter\"));   // OK\nobjectList.add(\"Yogurt\");                    // Also OK \u2014 but is this what we want?\n</code></pre> <p>This is called a raw type. Any object can be added, destroying type safety \u2014 exactly the same problem as using an <code>Object[]</code> array.</p> <p>IntelliJ Warning</p> <ul> <li>IntelliJ flags this with: \"Raw use of parameterized class 'ArrayList'\". This means compile-time type checking is disabled.</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#the-solution-parameterized-arraylist","title":"The Solution: Parameterized ArrayList","text":"<p>Specify the element type in angle brackets (<code>&lt;&gt;</code>):</p> <pre><code>ArrayList&lt;GroceryItem&gt; groceryList = new ArrayList&lt;&gt;();\ngroceryList.add(new GroceryItem(\"Butter\"));   // OK\n// groceryList.add(\"Yogurt\");                 // COMPILE ERROR! String \u2260 GroceryItem\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#the-diamond-operator","title":"The Diamond Operator (<code>&lt;&gt;</code>)","text":"<p>On the right side of the assignment, you can use empty angle brackets \u2014 Java infers the type from the left side:</p> <pre><code>// Explicit type argument (verbose but valid)\nArrayList&lt;GroceryItem&gt; groceryList = new ArrayList&lt;GroceryItem&gt;();\n\n// Diamond operator (preferred \u2014 cleaner, inferred)\nArrayList&lt;GroceryItem&gt; groceryList = new ArrayList&lt;&gt;();\n</code></pre> <pre><code>flowchart TD\n    A[\"ArrayList objectList = new ArrayList()\"] --&gt;|\"Raw type\"| B[\"Any Object allowed&lt;br/&gt;No compile-time checks&lt;br/&gt;\u26a0\ufe0f Dangerous\"]\n    C[\"ArrayList&lt;GroceryItem&gt; list = new ArrayList&lt;&gt;()\"] --&gt;|\"Parameterized\"| D[\"Only GroceryItem allowed&lt;br/&gt;Compile-time type safety&lt;br/&gt;\u2705 Safe\"]\n\n    style B fill:#f44336,color:#fff\n    style D fill:#4CAF50,color:#fff</code></pre> <p>Don't Forget the Diamond</p> <ul> <li>If you write <code>new ArrayList()</code> without <code>&lt;&gt;</code>, you get a raw type even if the left side is parameterized. Always include at least the empty diamond <code>&lt;&gt;</code>.</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#the-groceryitem-record","title":"The GroceryItem Record","text":"<p>The course uses a <code>record</code> to model grocery items:</p> <pre><code>record GroceryItem(String name, String type, int count) {\n\n    // Custom constructor: name only, defaults type=\"DAIRY\" and count=1\n    public GroceryItem(String name) {\n        this(name, \"DAIRY\", 1);\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"%d %s in %s\", count, name.toUpperCase(), type);\n    }\n}\n</code></pre> <p>Key points:</p> <ul> <li>Records auto-generate a constructor with all fields</li> <li>Custom constructors must chain to the canonical constructor via <code>this(...)</code></li> <li>Overriding <code>toString()</code> controls how items are printed in the list</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#5-creating-populating-arraylists","title":"5. Creating &amp; Populating ArrayLists","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#method-1-empty-constructor-add","title":"Method 1: Empty Constructor + <code>add()</code>","text":"<pre><code>ArrayList&lt;GroceryItem&gt; groceryList = new ArrayList&lt;&gt;();\ngroceryList.add(new GroceryItem(\"Butter\"));\ngroceryList.add(new GroceryItem(\"Milk\"));\ngroceryList.add(new GroceryItem(\"Oranges\", \"PRODUCE\", 5));\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#method-2-constructor-with-listof-recommended","title":"Method 2: Constructor with <code>List.of()</code> (Recommended)","text":"<pre><code>ArrayList&lt;String&gt; groceries = new ArrayList&lt;&gt;(List.of(\"Apple\", \"Banana\", \"Pear\"));\ngroceries.add(\"yogurt\");  // Mutable \u2014 this works!\n</code></pre> <p>How it works: <code>List.of()</code> creates an immutable list which is then passed to the <code>ArrayList</code> constructor. The constructor copies the elements into a new, mutable <code>ArrayList</code>.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#method-3-one-line-initialization","title":"Method 3: One-Line Initialization","text":"<pre><code>ArrayList&lt;String&gt; nextList = new ArrayList&lt;&gt;(\n        List.of(\"pickles\", \"mustard\", \"cheese\")\n);\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#method-4-constructor-with-arraysaslist","title":"Method 4: Constructor with <code>Arrays.asList()</code>","text":"<pre><code>String[] items = {\"Apple\", \"Banana\", \"Pear\"};\nArrayList&lt;String&gt; groceries = new ArrayList&lt;&gt;(Arrays.asList(items));\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#adding-multiple-items-at-once-addall","title":"Adding Multiple Items at Once: <code>addAll()</code>","text":"<pre><code>ArrayList&lt;String&gt; nextList = new ArrayList&lt;&gt;(\n        List.of(\"pickles\", \"mustard\", \"cheese\")\n);\n\ngroceries.addAll(nextList);       // Adds all elements from nextList\nSystem.out.println(groceries);    // [Apple, Banana, Pear, yogurt, pickles, mustard, cheese]\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#6-crud-operations","title":"6. CRUD Operations","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#adding-elements","title":"Adding Elements","text":"Method Description Example <code>add(element)</code> Appends to the end <code>groceries.add(\"Milk\")</code> <code>add(index, element)</code> Inserts at index, shifts others right <code>groceries.add(0, \"Apples\")</code> <code>addAll(collection)</code> Appends all elements from another collection <code>groceries.addAll(nextList)</code> <pre><code>ArrayList&lt;GroceryItem&gt; groceryList = new ArrayList&lt;&gt;();\ngroceryList.add(new GroceryItem(\"Butter\"));       // [Butter]\ngroceryList.add(new GroceryItem(\"Yogurt\"));       // [Butter, Yogurt]\ngroceryList.add(0,\n        new GroceryItem(\"Milk\", \"PRODUCE\", 6));   // [Milk, Butter, Yogurt]\n</code></pre> <p><code>add(index)</code> Shifts Elements</p> <ul> <li>When adding at index 0, all existing elements shift by one position to the right. Unlike arrays, the list grows automatically to accommodate.</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#reading-elements-get","title":"Reading Elements: <code>get()</code>","text":"<pre><code>System.out.println(\"Third item: \" + groceries.get(2));   // Third item: Pear\n</code></pre> <p>Like arrays, <code>ArrayList</code> uses zero-based indexing. But instead of <code>arr[2]</code>, you call <code>.get(2)</code>.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#updating-elements-set","title":"Updating Elements: <code>set()</code>","text":"<pre><code>groceryList.set(0, new GroceryItem(\"Apples\", \"PRODUCE\", 6));\n// Replaces the element at index 0 (Milk \u2192 Apples)\n</code></pre> <p><code>set()</code> replaces the element at the given index. It does not insert \u2014 the list size stays the same.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#removing-elements","title":"Removing Elements","text":"Method Description Removes <code>remove(int index)</code> Removes by position Single element <code>remove(Object o)</code> Removes first occurrence by value Single element <code>removeAll(Collection)</code> Removes all matching elements Multiple elements <code>retainAll(Collection)</code> Keeps only matching elements, removes everything else Multiple elements <code>clear()</code> Removes everything All elements <pre><code>System.out.println(groceries);\n// [Apple, Banana, Pear, yogurt, pickles, mustard, cheese, yogurt]\n\ngroceries.remove(1);                // Removes \"Banana\" (by index)\nSystem.out.println(groceries);\n// [Apple, Pear, yogurt, pickles, mustard, cheese, yogurt]\n\ngroceries.remove(\"yogurt\");         // Removes FIRST \"yogurt\" only\nSystem.out.println(groceries);\n// [Apple, Pear, pickles, mustard, cheese, yogurt]\n\ngroceries.removeAll(List.of(\"Apple\", \"eggs\"));\n// Removes \"Apple\" (found), ignores \"eggs\" (not in list)\nSystem.out.println(groceries);\n// [Pear, pickles, mustard, cheese, yogurt]\n\ngroceries.retainAll(List.of(\"Apple\", \"milk\", \"mustard\", \"cheese\"));\n// Keeps ONLY mustard and cheese (the rest are removed)\nSystem.out.println(groceries);\n// [mustard, cheese]\n\ngroceries.clear();                   // Removes everything\nSystem.out.println(groceries);       // []\nSystem.out.println(groceries.isEmpty());  // true\n</code></pre> <p>Tip</p> <p>\"<code>retainAll</code> is the Opposite of <code>removeAll</code>\" - <code>removeAll(list)</code> \u2192 removes items that are in <code>list</code> - <code>retainAll(list)</code> \u2192 removes items that are not in <code>list</code></p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#7-searching","title":"7. Searching","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#contains-boolean-check","title":"<code>contains()</code> \u2014 Boolean Check","text":"<p>Returns <code>true</code> if the element exists in the list:</p> <pre><code>if (groceries.contains(\"yogurt\")) {\n    System.out.println(\"List contains yogurt\");\n}\n// Output: List contains yogurt\n</code></pre> <p>How <code>contains</code> Works</p> <p>Internally, <code>contains</code> calls the element's <code>equals()</code> method. For <code>String</code>, this checks character-by-character equality. For your own classes, you may need to override <code>equals()</code>.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#indexof-and-lastindexof-position-lookup","title":"<code>indexOf()</code> and <code>lastIndexOf()</code> \u2014 Position Lookup","text":"<pre><code>groceries.add(\"yogurt\");  // Add a duplicate\nSystem.out.println(\"first = \" + groceries.indexOf(\"yogurt\"));\n// first = 3\n\nSystem.out.println(\"last = \" + groceries.lastIndexOf(\"yogurt\"));\n// last = 8\n</code></pre> Method Returns When Not Found <code>indexOf(element)</code> Index of first occurrence <code>-1</code> <code>lastIndexOf(element)</code> Index of last occurrence <code>-1</code> <p>ArrayList vs Array Search</p> <p>With arrays, you had to use <code>Arrays.binarySearch()</code> which requires sorting first. With <code>ArrayList</code>, <code>contains</code> and <code>indexOf</code> work on unsorted lists \u2014 they perform a linear scan using <code>equals()</code>.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#8-sorting","title":"8. Sorting","text":"<p>Unlike <code>Arrays.sort()</code> which takes no argument for natural ordering, <code>ArrayList.sort()</code> requires a <code>Comparator</code>:</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#ascending-order-natural-order","title":"Ascending Order (Natural Order)","text":"<pre><code>System.out.println(groceries);\n// [Apple, milk, mustard, cheese, eggs, pickles, mustard, ham]\n\ngroceries.sort(Comparator.naturalOrder());\nSystem.out.println(groceries);\n// [Apple, cheese, eggs, ham, milk, mustard, mustard, pickles]\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#descending-order-reverse-order","title":"Descending Order (Reverse Order)","text":"<pre><code>groceries.sort(Comparator.reverseOrder());\nSystem.out.println(groceries);\n// [pickles, mustard, mustard, milk, ham, eggs, cheese, Apple]\n</code></pre> Sort Method Array ArrayList Ascending <code>Arrays.sort(arr)</code> <code>list.sort(Comparator.naturalOrder())</code> Descending Manual (bubble sort) <code>list.sort(Comparator.reverseOrder())</code> <p>What Is a <code>Comparator</code>?</p> <p>A <code>Comparator</code> is an interface that defines how two objects should be compared. <code>Comparator.naturalOrder()</code> and <code>Comparator.reverseOrder()</code> are factory methods that return pre-built comparators for types with a natural ordering (numbers, strings, etc.). Comparators are covered in depth in the interfaces section.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#9-converting-between-arrays-and-arraylists","title":"9. Converting Between Arrays and ArrayLists","text":"<p>There are three factory methods for creating lists from elements, and one method for going back to an array:</p> <pre><code>flowchart TD\n    ARRAY[\"String[] array\"] --&gt;|\"Arrays.asList(array)\"| BACKED[\"List&lt;String&gt;&lt;br/&gt;(array-backed)&lt;br/&gt;Mutable but NOT resizable\"]\n    ARRAY --&gt;|\"List.of(array)\"| IMMUT[\"List&lt;String&gt;&lt;br/&gt;(immutable)&lt;br/&gt;Cannot modify at all\"]\n    BACKED --&gt;|\"new ArrayList&lt;&gt;(list)\"| AL[\"ArrayList&lt;String&gt;&lt;br/&gt;(fully mutable)\"]\n    IMMUT --&gt;|\"new ArrayList&lt;&gt;(list)\"| AL\n    AL --&gt;|\"list.toArray(new String[0])\"| ARRAY2[\"String[] array\"]</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#arraysaslist-array-backed-list-not-resizable","title":"<code>Arrays.asList()</code> \u2014 Array-Backed List (Not Resizable)","text":"<pre><code>String[] originalArray = new String[]{\"First\", \"Second\", \"Third\"};\nvar originalList = Arrays.asList(originalArray);\n\noriginalList.set(0, \"one\");       // OK \u2014 modifying existing element\nSystem.out.println(\"list: \" + originalList);\n// list: [one, Second, Third]\n\nSystem.out.println(\"array: \" + Arrays.toString(originalArray));\n// array: [one, Second, Third]   \u2190 Original array was also modified!\n\n// originalList.add(\"Fourth\");    // UnsupportedOperationException!\n// originalList.remove(0);        // UnsupportedOperationException!\n</code></pre> <p>Key behavior:</p> <ul> <li>Changes to the list modify the underlying array (and vice versa)</li> <li>You cannot add or remove elements \u2014 the list is backed by a fixed-size array</li> <li>You can modify existing elements with <code>set()</code></li> </ul> <p>Array-Backed = Shared Reference</p> <p><code>Arrays.asList()</code> does not copy the array. It wraps it. Any <code>set()</code> call on the list changes the original array.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#listof-immutable-list","title":"<code>List.of()</code> \u2014 Immutable List","text":"<pre><code>List&lt;String&gt; newList = List.of(\"Sunday\", \"Monday\", \"Tuesday\");\nSystem.out.println(newList);  // [Sunday, Monday, Tuesday]\n\n// newList.add(\"Wednesday\");    // UnsupportedOperationException!\n// newList.set(0, \"Funday\");    // UnsupportedOperationException!\n// newList.remove(0);           // UnsupportedOperationException!\n</code></pre> <p><code>List.of()</code> returns a <code>java.util.ImmutableCollections$ListN</code> \u2014 you cannot modify it at all.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#comparison-table","title":"Comparison Table","text":"Method Returns Mutable? Resizable? Backed by Array? <code>Arrays.asList(arr)</code> Fixed-size <code>List</code> \u2705 (set only) \u274c \u2705 (shared) <code>List.of(elements)</code> Immutable <code>List</code> \u274c \u274c \u274c <code>new ArrayList&lt;&gt;(list)</code> <code>ArrayList</code> \u2705 \u2705 \u274c (independent copy)","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#toarray-arraylist-array","title":"<code>toArray()</code> \u2014 ArrayList \u2192 Array","text":"<pre><code>var groceryArray = groceries.toArray(new String[groceries.size()]);\nSystem.out.println(Arrays.toString(groceryArray));\n</code></pre> <p>Pass a typed array as the argument. The returned array will be the same type and contain the list's elements. You can also pass <code>new String[0]</code> \u2014 the method will still return an array sized to the list.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#10-arrays-vs-arraylists-complete-comparison","title":"10. Arrays vs ArrayLists \u2014 Complete Comparison","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#similarities","title":"Similarities","text":"Feature Array ArrayList Indexed Yes (zero-based) Yes (zero-based) Ordered By index By index Duplicates Allowed Allowed Nulls Allowed Allowed Inherits from <code>java.lang.Object</code> <code>java.lang.Object</code> Mutable Yes (elements can change) Yes (elements can change)","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#differences","title":"Differences","text":"Aspect Array ArrayList Primitives \u2705 Supported (<code>int[]</code>) \u274c Wrapper classes only (<code>Integer</code>) Size Fixed Dynamic (resizable) Get size <code>.length</code> (field) <code>.size()</code> (method) Access element <code>arr[i]</code> <code>list.get(i)</code> Set element <code>arr[i] = val</code> <code>list.set(i, val)</code> Print <code>Arrays.toString(arr)</code> <code>System.out.println(list)</code> Print 2D <code>Arrays.deepToString(arr)</code> <code>System.out.println(list)</code> Search <code>Arrays.binarySearch()</code> (sorted!) <code>contains()</code>, <code>indexOf()</code> (unsorted OK) Sort <code>Arrays.sort(arr)</code> <code>list.sort(Comparator.naturalOrder())</code> Add/Remove \u274c Not possible \u2705 <code>add()</code>, <code>remove()</code>, etc. Built-in methods Almost none (use <code>java.util.Arrays</code>) Rich API on the instance itself","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#syntax-comparison","title":"Syntax Comparison","text":"<pre><code>// \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 ARRAY \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\nString[] arr = new String[]{\"a\", \"b\", \"c\"};     // Declaration + initialization\nint len = arr.length;                             // Size\nString first = arr[0];                            // Access\narr[0] = \"z\";                                     // Set\nArrays.sort(arr);                                 // Sort\nSystem.out.println(Arrays.toString(arr));          // Print\n\n// \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 ARRAYLIST \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\nArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(         // Declaration + initialization\n        List.of(\"a\", \"b\", \"c\")\n);\nint size = list.size();                            // Size\nString first = list.get(0);                        // Access\nlist.set(0, \"z\");                                  // Set\nlist.sort(Comparator.naturalOrder());              // Sort\nSystem.out.println(list);                           // Print\nlist.add(\"d\");                                      // Add \u2190 ARRAY CAN'T DO THIS\nlist.remove(\"b\");                                   // Remove \u2190 ARRAY CAN'T DO THIS\n</code></pre> <p>!!! tip \"When to Use Which?\" - Use arrays when the size is known and fixed, and you need maximum performance or primitive types - Use ArrayList when you need to add/remove elements dynamically, or need the rich built-in methods</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#11-arraylist-challenge-interactive-grocery-list","title":"11. ArrayList Challenge: Interactive Grocery List","text":"<p>The challenge builds a complete interactive console application using an <code>ArrayList</code>, a <code>Scanner</code>, enhanced <code>switch</code> statements, and text blocks.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#full-solution","title":"Full Solution","text":"<pre><code>import java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n    private static Scanner scanner = new Scanner(System.in);\n\n    public static void main(String[] args) {\n        boolean flag = true;\n        ArrayList&lt;String&gt; groceries = new ArrayList&lt;&gt;();\n\n        // Manages grocery list until user quits\n        while (flag) {\n            printActions();\n            switch (Integer.parseInt(scanner.nextLine())) {\n                case 1 -&gt; addItems(groceries);\n                case 2 -&gt; removeItems(groceries);\n                default -&gt; flag = false;\n            }\n            groceries.sort(Comparator.naturalOrder());\n            System.out.println(groceries);\n        }\n    }\n\n    /**\n     * Adds unique trimmed items to the grocery list\n     */\n    private static void addItems(ArrayList&lt;String&gt; groceries) {\n        System.out.println(\"Add item(s) [separate items by comma]:\");\n        String[] items = scanner.nextLine().split(\",\");\n\n        for (String item : items) {\n            String trimmedItem = item.trim();\n            if (groceries.indexOf(trimmedItem) &lt; 0) {\n                groceries.add(trimmedItem);\n            }\n        }\n    }\n\n    private static void removeItems(ArrayList&lt;String&gt; groceries) {\n        System.out.println(\"Remove item(s) [separate items by comma]:\");\n        String[] items = scanner.nextLine().split(\",\");\n        for (String item : items) {\n            String trimmedItem = item.trim();\n            groceries.remove(trimmedItem);\n        }\n    }\n\n    private static void printActions() {\n        String textBlock = \"\"\"\n                Available actions:\n\n                0 - to shutdown\n\n                1 - to add item(s) to list (comma delimited list)\n\n                2 - to remove any items (comma delimited list)\n\n                Enter a number for which action you want to do:\"\"\";\n        System.out.println(textBlock + \" \");\n    }\n}\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#key-techniques-used","title":"Key Techniques Used","text":"Technique Code Purpose Text blocks <code>\"\"\"...\"\"\"</code> Multi-line menu display (Java 15+) Enhanced switch <code>case 1 -&gt; addItems(...)</code> No <code>break</code> needed, no fall-through Compound expression <code>Integer.parseInt(scanner.nextLine())</code> Read + parse in one statement Trimming <code>item.trim()</code> Remove whitespace from user input Duplicate prevention <code>indexOf(item) &lt; 0</code> Only add if item is not already in list <code>Comparator.naturalOrder()</code> <code>groceries.sort(...)</code> Alphabetical sort after every action","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#why-not-use-addall-directly","title":"Why Not Use <code>addAll</code> Directly?","text":"<p>The first approach tried in the course was:</p> <pre><code>groceries.addAll(List.of(items));   // Adds ALL items \u2014 no dedup, no trim!\n</code></pre> <p>Two problems:</p> <ol> <li>Duplicates \u2014 If the user enters \"eggs, cereal\" and those are already in the list, they get added again</li> <li>Whitespace \u2014 \"eggs, milk, cereal\" splits into <code>[\"eggs\", \" milk\", \" cereal\"]</code> \u2014 note the leading spaces</li> </ol> <p>The fix: loop through individually, <code>trim()</code> each item, and check with <code>indexOf()</code> before adding.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#common-pitfalls-summary","title":"Common Pitfalls Summary","text":"Pitfall Example Fix Raw ArrayList <code>new ArrayList()</code> <code>new ArrayList&lt;String&gt;()</code> or <code>new ArrayList&lt;&gt;()</code> Missing diamond operator <code>new ArrayList&lt;String&gt;() \u2192 new ArrayList()</code> Always include <code>&lt;&gt;</code> <code>List.of()</code> is immutable <code>List.of(\"a\").add(\"b\")</code> \u2192 crash Wrap: <code>new ArrayList&lt;&gt;(List.of(\"a\"))</code> <code>Arrays.asList()</code> not resizable <code>Arrays.asList(arr).add(\"x\")</code> \u2192 crash Wrap: <code>new ArrayList&lt;&gt;(Arrays.asList(arr))</code> <code>remove(int)</code> vs <code>remove(Object)</code> <code>list.remove(1)</code> removes by index, not value \"1\" Use <code>list.remove(Integer.valueOf(1))</code> for value Whitespace in split <code>\"a, b\".split(\",\")</code> \u2192 <code>[\"a\", \" b\"]</code> Call <code>.trim()</code> on each element","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>ArrayList is a resizable array \u2014 it manages capacity automatically behind the scenes. You focus on the data, not the size.</li> <li>Always parameterize \u2014 use <code>ArrayList&lt;Type&gt;</code> with the diamond operator <code>&lt;&gt;</code> for compile-time type safety.</li> <li><code>List.of()</code> is immutable, <code>Arrays.asList()</code> is fixed-size \u2014 neither is fully mutable. Wrap with <code>new ArrayList&lt;&gt;(...)</code> when you need a mutable list.</li> <li>Printing is easier \u2014 <code>System.out.println(list)</code> works correctly, unlike arrays which print hash codes.</li> <li>Searching is easier \u2014 <code>contains()</code> and <code>indexOf()</code> don't require a sorted list, unlike <code>Arrays.binarySearch()</code>.</li> <li>Sorting requires a <code>Comparator</code> \u2014 use <code>Comparator.naturalOrder()</code> or <code>Comparator.reverseOrder()</code>.</li> <li>No primitives \u2014 ArrayList cannot hold <code>int</code>, <code>double</code>, etc. Use <code>Integer</code>, <code>Double</code>, etc. (autoboxing is covered next).</li> </ol>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#quick-reference","title":"Quick Reference","text":"Operation Syntax Create (empty) <code>ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;()</code> Create (with items) <code>new ArrayList&lt;&gt;(List.of(\"a\", \"b\", \"c\"))</code> Add to end <code>list.add(\"item\")</code> Add at index <code>list.add(0, \"item\")</code> Add all <code>list.addAll(otherList)</code> Get element <code>list.get(0)</code> Set element <code>list.set(0, \"newValue\")</code> Remove by index <code>list.remove(0)</code> Remove by value <code>list.remove(\"item\")</code> Remove multiple <code>list.removeAll(List.of(\"a\", \"b\"))</code> Keep only <code>list.retainAll(List.of(\"a\", \"b\"))</code> Clear all <code>list.clear()</code> Is empty? <code>list.isEmpty()</code> Size <code>list.size()</code> Contains? <code>list.contains(\"item\")</code> First index of <code>list.indexOf(\"item\")</code> Last index of <code>list.lastIndexOf(\"item\")</code> Sort (A\u2192Z) <code>list.sort(Comparator.naturalOrder())</code> Sort (Z\u2192A) <code>list.sort(Comparator.reverseOrder())</code> List \u2192 Array <code>list.toArray(new String[0])</code> Array \u2192 List (mutable) <code>new ArrayList&lt;&gt;(Arrays.asList(arr))</code> Array \u2192 List (immutable) <code>List.of(arr)</code>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#related-notes","title":"Related Notes","text":"Part Topic Link 1 Arrays &amp; <code>java.util.Arrays</code> \u2190 Part 1 2 ArrayList \u2014 Java's Resizable Array You are here 3 LinkedList &amp; Iterators Part 3 \u2192 4 Autoboxing, Unboxing &amp; Enums Part 4 \u2192","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part2/#references","title":"References","text":"<ul> <li>Course: Tim Buchalka - Java Programming Masterclass (Section 10, Lectures 1\u20136)</li> <li>API: java.util.ArrayList (Java 17)</li> <li>API: java.util.List (Java 17)</li> <li>API: java.util.Comparator (Java 17)</li> </ul> <p>Last Updated: 2026-02-11 | Confidence: 9/10</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/","title":"Topic Note: LinkedList &amp; Iterators \u2014 Doubly Linked Lists in Java","text":"<p>Course: Java Programming Masterclass - Tim Buchalka (Udemy)</p> <p>Section: 10 - Mastering Lists, Iterators, and Autoboxing (Part 2: LinkedList)</p> <p>Status:  Complete (Part 3 of Topic 3)</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#learning-objectives","title":"Learning Objectives","text":"<ul> <li> Understand how memory layout differs between arrays, ArrayLists, and LinkedLists</li> <li> Know Big O Notation and how it applies to list operations</li> <li> Use a LinkedList as a List, Queue, Double-Ended Queue, and Stack</li> <li> Perform add/remove operations with Queue/Stack-specific methods</li> <li> Retrieve elements using List, Queue, and Stack APIs</li> <li> Traverse lists with <code>Iterator</code> and <code>ListIterator</code></li> <li> Safely modify a list during iteration (avoiding <code>ConcurrentModificationException</code>)</li> <li> Navigate bidirectionally (forward/backward) with <code>ListIterator</code></li> <li> Build an ordered LinkedList with duplicate prevention and interactive navigation</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#1-why-linkedlist-exists-memory-performance","title":"1. Why LinkedList Exists: Memory &amp; Performance","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#how-arrays-store-data-in-memory","title":"How Arrays Store Data in Memory","text":"<p>When a primitive array is created, all elements are stored contiguously (side by side) in memory:</p> <pre><code>flowchart LR\n    subgraph memory[\"Contiguous Memory (int[] array)\"]\n        direction LR\n        M100[\"addr 100&lt;br/&gt;34\"] --- M104[\"addr 104&lt;br/&gt;18\"] --- M108[\"addr 108&lt;br/&gt;91\"] --- M112[\"addr 112&lt;br/&gt;57\"] --- M116[\"addr 116&lt;br/&gt;22\"]\n    end</code></pre> <p>Java can find any element with simple math: <code>address = baseAddress + (index \u00d7 size)</code>. This makes indexed access O(1) \u2014 constant time, regardless of how many elements there are.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#how-arraylist-stores-data","title":"How ArrayList Stores Data","text":"<p>An <code>ArrayList</code> uses an internal array of references (memory addresses), not the actual objects. The references are contiguous, but the objects they point to can be anywhere in memory:</p> <pre><code>flowchart TD\n    subgraph internal[\"ArrayList Internal Array (references)\"]\n        direction LR\n        R0[\"[0] \u2192 addr 500\"] --- R1[\"[1] \u2192 addr 720\"] --- R2[\"[2] \u2192 addr 340\"]\n    end\n\n    R0 -.-&gt; OBJ0[\"Object at 500&lt;br/&gt;'First'\"]\n    R1 -.-&gt; OBJ1[\"Object at 720&lt;br/&gt;'Second'\"]\n    R2 -.-&gt; OBJ2[\"Object at 340&lt;br/&gt;'Third'\"]</code></pre> <p>Key insight: Indexed access is still O(1) because the reference addresses are contiguous. But inserting or removing requires shifting all subsequent references \u2014 that's O(n).</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#how-linkedlist-stores-data","title":"How LinkedList Stores Data","text":"<p>A <code>LinkedList</code> has no internal array at all. Each element (called a node) stores:</p> <ol> <li>The data itself</li> <li>A reference to the next node</li> <li>A reference to the previous node</li> </ol> <pre><code>flowchart LR\n    HEAD[\"HEAD\"] --&gt; A\n    A[\"Alice Springs&lt;br/&gt;prev: null&lt;br/&gt;next: \u2192\"] &lt;--&gt; B[\"Brisbane&lt;br/&gt;prev: \u2190&lt;br/&gt;next: \u2192\"]\n    B &lt;--&gt; C[\"Canberra&lt;br/&gt;prev: \u2190&lt;br/&gt;next: \u2192\"]\n    C &lt;--&gt; D[\"Darwin&lt;br/&gt;prev: \u2190&lt;br/&gt;next: \u2192\"]\n    D &lt;--&gt; E[\"Sydney&lt;br/&gt;prev: \u2190&lt;br/&gt;next: null\"]\n    E --&gt; TAIL[\"TAIL\"]\n\n    style HEAD fill:#FF9800,color:#fff\n    style TAIL fill:#FF9800,color:#fff</code></pre> <p>This architecture is called a doubly linked list \u2014 each node links to both the next and previous node. The first node is the head and the last is the tail.</p> <p>No Index, No Simple Math</p> <p>To find the 5<sup>th</sup> element, you must start at the head (or tail) and traverse node by node. There's no shortcut \u2014 this makes indexed access O(n).</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#2-big-o-notation-understanding-performance-costs","title":"2. Big O Notation \u2014 Understanding Performance Costs","text":"<p>Big O Notation expresses how the cost of an operation scales with the number of elements <code>n</code>.</p> Notation Name Meaning O(1) Constant time Cost is the same regardless of <code>n</code> O(n) Linear time Cost grows proportionally with <code>n</code> O(1)* Constant amortized Usually O(1), occasionally O(n) when reallocation occurs","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#arraylist-vs-linkedlist-big-o-comparison","title":"ArrayList vs LinkedList \u2014 Big O Comparison","text":"Operation ArrayList LinkedList Notes Get by index O(1) O(n) ArrayList wins: simple math vs traversal Set by index O(1) O(n) Same reason Add to end O(1)* O(1) ArrayList may need reallocation Add to start O(n) O(1) ArrayList shifts all elements Add at index O(n) O(n) Both need to find position, then shift/link Remove from start O(n) O(1) ArrayList shifts all elements Remove from end O(1) O(1) Both are fast Remove by value O(n) O(n) Both must search first Contains / indexOf O(n) O(n) Both do linear scan <p>When to Use Which?</p> <ul> <li> <p>ArrayList is the better default choice, especially for storing and reading data (random access via index).</p> </li> <li> <p>LinkedList is better when you're frequently adding/removing from the start or end of the list, or when the maximum size is unknown and may be very large. - If you know the maximum number of elements, use <code>new ArrayList&lt;&gt;(capacity)</code> to avoid reallocation. - An <code>ArrayList</code>'s maximum capacity is <code>Integer.MAX_VALUE</code> (2,147,483,647). A <code>LinkedList</code> has no such limit.</p> </li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#3-linkedlist-as-four-data-structures","title":"3. LinkedList as Four Data Structures","text":"<p>The <code>LinkedList</code> class implements multiple interfaces, making it usable as four different data structure types:</p> <pre><code>flowchart TD\n    LL[\"LinkedList&lt;E&gt;\"]\n    LL --&gt;|implements| LIST[\"List&lt;E&gt;\"]\n    LL --&gt;|implements| DEQUE[\"Deque&lt;E&gt;&lt;br/&gt;(Double-Ended Queue)\"]\n    DEQUE --&gt;|extends| QUEUE[\"Queue&lt;E&gt;\"]\n\n    subgraph behaviors[\"Behavior Patterns\"]\n        direction TB\n        B1[\"\ud83d\udccb List \u2014 indexed, ordered collection\"]\n        B2[\"\ud83d\udeb6 Queue (FIFO) \u2014 first in, first out\"]\n        B3[\"\ud83d\udd04 Deque \u2014 access from both ends\"]\n        B4[\"\ud83d\udcda Stack (LIFO) \u2014 last in, first out\"]\n    end\n\n    LIST -.-&gt; B1\n    QUEUE -.-&gt; B2\n    DEQUE -.-&gt; B3\n    DEQUE -.-&gt; B4</code></pre> Pattern Add Method Remove Method Description List <code>add(element)</code>, <code>add(index, element)</code> <code>remove(index)</code>, <code>remove(object)</code> Standard list operations Queue (FIFO) <code>offer(element)</code> <code>poll()</code> Add to end, remove from start Deque <code>offerFirst()</code>, <code>offerLast()</code> <code>pollFirst()</code>, <code>pollLast()</code> Access from both ends Stack (LIFO) <code>push(element)</code> <code>pop()</code> Add to start, remove from start","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#4-creating-and-populating-a-linkedlist","title":"4. Creating and Populating a LinkedList","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#declaration","title":"Declaration","text":"<pre><code>// Explicit type on both sides\nLinkedList&lt;String&gt; placesToVisit = new LinkedList&lt;&gt;();\n\n// Using var (must specify type on the right side!)\nvar placesToVisit = new LinkedList&lt;String&gt;();\n</code></pre> <p><code>var</code> with Diamond Operator</p> <p>When using <code>var</code>, you cannot use an empty diamond <code>&lt;&gt;</code> on the right side \u2014 Java won't have enough information to infer the type. You must write <code>new LinkedList&lt;String&gt;()</code> explicitly.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#adding-elements-list-methods","title":"Adding Elements \u2014 List Methods","text":"<pre><code>placesToVisit.add(\"Sydney\");              // Appends to end\nplacesToVisit.add(0, \"Canberra\");         // Inserts at index 0, shifts others\nSystem.out.println(placesToVisit);\n// [Canberra, Sydney]\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#adding-elements-deque-methods","title":"Adding Elements \u2014 Deque Methods","text":"<pre><code>list.addFirst(\"Darwin\");        // Inserts at the HEAD\nlist.addLast(\"Hobart\");         // Appends to the TAIL (same as add)\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#adding-elements-queue-methods","title":"Adding Elements \u2014 Queue Methods","text":"<pre><code>list.offer(\"Melbourne\");        // Adds to end (= offerLast)\nlist.offerFirst(\"Brisbane\");    // Adds to start (= addFirst)\nlist.offerLast(\"Toowoomba\");    // Adds to end (= addLast)\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#adding-elements-stack-method","title":"Adding Elements \u2014 Stack Method","text":"<pre><code>list.push(\"Alice Springs\");     // Pushes to the TOP of the stack (= addFirst)\n</code></pre> <p><code>push</code> adds to the START</p> <p>The top of a stack is the first element in the LinkedList. <code>push</code> inserts at position 0, pushing all existing elements down.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#complete-add-methods-reference","title":"Complete Add Methods Reference","text":"Method Where Same As <code>add(element)</code> End <code>offerLast()</code>, <code>addLast()</code>, <code>offer()</code> <code>add(index, element)</code> At index \u2014 <code>addFirst(element)</code> Start <code>offerFirst()</code>, <code>push()</code> <code>addLast(element)</code> End <code>offer()</code>, <code>offerLast()</code> <code>offer(element)</code> End <code>addLast()</code> <code>offerFirst(element)</code> Start <code>addFirst()</code> <code>offerLast(element)</code> End <code>addLast()</code> <code>push(element)</code> Start <code>addFirst()</code>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#5-removing-elements","title":"5. Removing Elements","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#list-methods-shared-with-arraylist","title":"List Methods (Shared with ArrayList)","text":"<pre><code>list.remove(4);            // Removes by index (5th element)\nlist.remove(\"Brisbane\");   // Removes first occurrence by value\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#linkedlist-specific-methods","title":"LinkedList-Specific Methods","text":"<pre><code>String s1 = list.remove();         // Removes and returns FIRST element\nString s2 = list.removeFirst();    // Same as remove()\nString s3 = list.removeLast();     // Removes and returns LAST element\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#queuedeque-methods","title":"Queue/Deque Methods","text":"<pre><code>String p1 = list.poll();           // Removes and returns first (= pollFirst)\nString p2 = list.pollFirst();      // Same as poll()\nString p3 = list.pollLast();       // Removes and returns last\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#stack-method","title":"Stack Method","text":"<pre><code>String p4 = list.pop();           // Removes and returns first (top of stack)\n</code></pre> <p>Tip</p> <ul> <li> <p>\"<code>remove()</code> vs <code>poll()</code> \u2014 Error Handling Difference\" - <code>remove()</code> / <code>removeFirst()</code> / <code>removeLast()</code> throw <code>NoSuchElementException</code> if the list is empty - <code>poll()</code> / <code>pollFirst()</code> / <code>pollLast()</code> return <code>null</code> if the list is empty</p> </li> <li> <p>Use <code>poll</code> when an empty list is a valid scenario; use <code>remove</code> when it should never happen.</p> </li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#complete-remove-methods-reference","title":"Complete Remove Methods Reference","text":"Method Removes Returns If Empty <code>remove(index)</code> At index Removed element <code>IndexOutOfBoundsException</code> <code>remove(object)</code> First match <code>boolean</code> <code>false</code> <code>remove()</code> First Removed element <code>NoSuchElementException</code> <code>removeFirst()</code> First Removed element <code>NoSuchElementException</code> <code>removeLast()</code> Last Removed element <code>NoSuchElementException</code> <code>poll()</code> First Removed element <code>null</code> <code>pollFirst()</code> First Removed element <code>null</code> <code>pollLast()</code> Last Removed element <code>null</code> <code>pop()</code> First (top) Removed element <code>NoSuchElementException</code>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#6-retrieving-elements-without-removing","title":"6. Retrieving Elements (Without Removing)","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#list-methods","title":"List Methods","text":"<pre><code>list.get(4);              // Element at index 4 \u2014 O(n) for LinkedList!\nlist.getFirst();          // First element (head)\nlist.getLast();           // Last element (tail)\nlist.indexOf(\"Darwin\");   // Position of first match (-1 if not found)\nlist.lastIndexOf(\"Melbourne\");  // Position of last match\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#queue-method","title":"Queue Method","text":"<pre><code>list.element();           // Returns first element (head), throws if empty\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#peek-methods-null-safe","title":"Peek Methods (Null-Safe)","text":"<pre><code>list.peek();              // Returns first element, or null if empty\nlist.peekFirst();         // Same as peek()\nlist.peekLast();          // Returns last element, or null if empty\n</code></pre> <p><code>get()</code> vs <code>peek()</code> vs <code>element()</code></p> <p>All three can retrieve the first element, but they differ in behavior:</p> Method Empty List Analogous To <code>get(0)</code> <code>IndexOutOfBoundsException</code> List API <code>element()</code> <code>NoSuchElementException</code> Queue API <code>peek()</code> / <code>peekFirst()</code> Returns <code>null</code> Queue API (safe) <code>getFirst()</code> <code>NoSuchElementException</code> LinkedList API","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#7-traversing-a-linkedlist","title":"7. Traversing a LinkedList","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#method-1-traditional-for-loop-indexed-inefficient","title":"Method 1: Traditional <code>for</code> Loop (Indexed \u2014 Inefficient!)","text":"<pre><code>public static void printItinerary(LinkedList&lt;String&gt; list) {\n    System.out.println(\"Trip starts at \" + list.getFirst());\n    for (int i = 1; i &lt; list.size(); i++) {\n        System.out.println(\"--&gt; From: \" + list.get(i - 1) + \" To: \" + list.get(i));\n    }\n    System.out.println(\"Trip ends at \" + list.getLast());\n}\n</code></pre> <p>Indexed Access on LinkedList = O(n) per Call</p> <p>Each <code>list.get(i)</code> call inside the loop traverses from the head (or tail). In a loop, this means the total cost is O(n\u00b2) \u2014 very inefficient for large lists.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#method-2-enhanced-for-loop-better","title":"Method 2: Enhanced <code>for</code> Loop (Better)","text":"<pre><code>public static void printItinerary2(LinkedList&lt;String&gt; list) {\n    System.out.println(\"Trip starts at \" + list.getFirst());\n    String previousTown = list.getFirst();\n    for (String town : list) {\n        System.out.println(\"--&gt; From: \" + previousTown + \" To: \" + town);\n        previousTown = town;\n    }\n    System.out.println(\"Trip ends at \" + list.getLast());\n}\n</code></pre> <p>More efficient \u2014 traverses the list once. But prints \"From Alice Springs To Alice Springs\" on the first iteration (both values are the first element).</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#method-3-listiterator-best","title":"Method 3: <code>ListIterator</code> (Best)","text":"<pre><code>public static void printItinerary3(LinkedList&lt;String&gt; list) {\n    System.out.println(\"Trip starts at \" + list.getFirst());\n    String previousTown = list.getFirst();\n    ListIterator&lt;String&gt; iterator = list.listIterator(1);  // Start at index 1\n    while (iterator.hasNext()) {\n        var town = iterator.next();\n        System.out.println(\"--&gt; From: \" + previousTown + \" To: \" + town);\n        previousTown = town;\n    }\n    System.out.println(\"Trip ends at \" + list.getLast());\n}\n</code></pre> <p>Using <code>listIterator(1)</code> starts the cursor after the first element, skipping the duplicate first-entry problem.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#8-iterator-listiterator-deep-dive","title":"8. Iterator &amp; ListIterator \u2014 Deep Dive","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#what-is-an-iterator","title":"What Is an Iterator?","text":"<p>An Iterator is an object that allows traversal over a collection, element by element. Think of it like a database cursor \u2014 it maintains a position and moves through the data.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#iterator-cursor-positions","title":"Iterator Cursor Positions","text":"<p>The cursor sits between elements, not on them:</p> <pre><code>flowchart LR\n    subgraph positions[\"Iterator Cursor Positions\"]\n        direction LR\n        P0[\"cursor 0\"] --&gt; E0[\"Alice Springs\"]\n        E0 --&gt; P1[\"cursor 1\"]\n        P1 --&gt; E1[\"Brisbane\"]\n        E1 --&gt; P2[\"cursor 2\"]\n        P2 --&gt; E2[\"Darwin\"]\n        E2 --&gt; P3[\"cursor 3\"]\n        P3 --&gt; E3[\"Sydney\"]\n        E3 --&gt; P4[\"cursor 4\"]\n    end\n\n    style P0 fill:#FF9800,color:#fff,stroke-width:0\n    style P1 fill:#FF9800,color:#fff,stroke-width:0\n    style P2 fill:#FF9800,color:#fff,stroke-width:0\n    style P3 fill:#FF9800,color:#fff,stroke-width:0\n    style P4 fill:#FF9800,color:#fff,stroke-width:0</code></pre> <ul> <li><code>next()</code> returns the element after the cursor and advances the cursor forward</li> <li><code>previous()</code> returns the element before the cursor and moves the cursor backward</li> <li>When first created, the cursor is at position 0 (before the first element)</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#iterator-vs-listiterator","title":"Iterator vs ListIterator","text":"Feature Iterator ListIterator Direction Forward only Forward and backward Get method <code>next()</code>, <code>hasNext()</code> + <code>previous()</code>, <code>hasPrevious()</code> Mutate <code>remove()</code> only <code>remove()</code>, <code>add()</code>, <code>set()</code> Starting position Before first element Configurable with <code>listIterator(index)</code> Get by <code>list.iterator()</code> <code>list.listIterator()</code> or <code>list.listIterator(index)</code>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#basic-iterator-usage","title":"Basic Iterator Usage","text":"<pre><code>var iterator = list.iterator();\nwhile (iterator.hasNext()) {\n    System.out.println(iterator.next());\n}\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#listiterator-forward-and-backward","title":"ListIterator \u2014 Forward and Backward","text":"<pre><code>var iterator = list.listIterator();\n\n// Forward traversal\nwhile (iterator.hasNext()) {\n    System.out.println(iterator.next());\n}\n\n// Backward traversal (iterator is now at the end)\nwhile (iterator.hasPrevious()) {\n    System.out.println(iterator.previous());\n}\n</code></pre> <p>After the first <code>while</code> loop, <code>hasNext()</code> is <code>false</code> \u2014 the cursor is past the last element. But <code>hasPrevious()</code> is <code>true</code>, so we can reverse without creating a new iterator.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#safe-removal-during-iteration","title":"Safe Removal During Iteration","text":"<pre><code>var iterator = list.listIterator();\nwhile (iterator.hasNext()) {\n    if (iterator.next().equals(\"Brisbane\")) {\n        iterator.remove();      // \u2705 Safe \u2014 removes via iterator\n    }\n}\n</code></pre> <p>Never Modify a List Directly During Iteration</p> <pre><code> // \u274c WRONG \u2014 throws ConcurrentModificationException!\nwhile (iterator.hasNext()) {\n    if (iterator.next().equals(\"Brisbane\")) {\n        list.remove(\"Brisbane\");    // Modifying list directly!\n    }\n}\n</code></pre> <p>You'd get the same error using an enhanced <code>for</code> loop and calling <code>list.remove()</code>. Always use <code>iterator.remove()</code>, <code>iterator.add()</code>, or <code>iterator.set()</code> instead.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#adding-elements-via-listiterator","title":"Adding Elements via ListIterator","text":"<pre><code>var iterator = list.listIterator();\nwhile (iterator.hasNext()) {\n    if (iterator.next().equals(\"Brisbane\")) {\n        iterator.add(\"Lake Wivenhoe\");   // Inserts AFTER Brisbane\n    }\n}\n</code></pre> <p>The new element is inserted immediately after the element that was just returned by <code>next()</code>.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#starting-at-a-specific-position","title":"Starting at a Specific Position","text":"<pre><code>var iterator2 = list.listIterator(3);   // Cursor between index 2 and 3\nSystem.out.println(iterator2.next());     // Returns element at index 3 (Darwin)\nSystem.out.println(iterator2.previous()); // Returns element at index 2 (Lake Wivenhoe)\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#9-linkedlist-challenge-ordered-travel-itinerary","title":"9. LinkedList Challenge: Ordered Travel Itinerary","text":"<p>The challenge builds an interactive program that manages an ordered itinerary using a <code>LinkedList</code> and <code>ListIterator</code>.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#the-place-record","title":"The <code>Place</code> Record","text":"<pre><code>record Place(String name, int distance) {\n    @Override\n    public String toString() {\n        return String.format(\"%s, (%d) km away\", name, distance);\n    }\n}\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#the-addplace-method-ordered-insert-with-duplicate-prevention","title":"The <code>addPlace</code> Method \u2014 Ordered Insert with Duplicate Prevention","text":"<pre><code>private static void addPlace(LinkedList&lt;Place&gt; list, Place place) {\n    // Check 1: Exact duplicate using record's implicit equals()\n    if (list.contains(place)) {\n        System.out.println(\"Place already exists\" + place);\n        return;\n    }\n\n    // Check 2: Case-insensitive name match\n    for (Place p : list) {\n        if (p.name().equalsIgnoreCase(place.name())) {\n            System.out.println(\"Place already exists\" + place);\n            return;\n        }\n    }\n\n    // Insert in distance order (closest first)\n    int matchedIndex = 0;\n    for (var listPlace : list) {\n        if (place.distance() &lt; listPlace.distance()) {\n            list.add(matchedIndex, place);\n            return;\n        }\n        matchedIndex++;\n    }\n    list.add(place);  // Farthest away \u2014 add to end\n}\n</code></pre> <p>Three responsibilities:</p> <ol> <li>Exact duplicate check \u2014 <code>list.contains(place)</code> uses the record's implicit <code>equals()</code> which compares all fields</li> <li>Case-insensitive name check \u2014 \"Adelaide\" and \"adelaide\" are treated as duplicates</li> <li>Ordered insert \u2014 Places are inserted by ascending distance from Sydney</li> </ol> <p>Record's Implicit <code>equals()</code></p> <p>Records automatically implement <code>equals()</code> by comparing all field values.   Two <code>Place</code> records with the same <code>name</code> and <code>distance</code> are considered equal by <code>contains()</code>. But \"Adelaide\" \u2260 \"adelaide\" with the default <code>equals</code>, hence the manual case-insensitive check.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#the-interactive-navigation-loop","title":"The Interactive Navigation Loop","text":"<pre><code>public static void main(String[] args) {\n    LinkedList&lt;Place&gt; placesToVisit = new LinkedList&lt;&gt;();\n\n    addPlace(placesToVisit, new Place(\"Adelaide\", 1374));\n    addPlace(placesToVisit, new Place(\"Brisbane\", 917));\n    addPlace(placesToVisit, new Place(\"Perth\", 3923));\n    addPlace(placesToVisit, new Place(\"Alice Springs\", 2771));\n    addPlace(placesToVisit, new Place(\"Darwin\", 3972));\n    addPlace(placesToVisit, new Place(\"Melbourne\", 877));\n\n    placesToVisit.addFirst(new Place(\"Sydney\", 0));\n    System.out.println(placesToVisit);\n\n    var iterator = placesToVisit.listIterator();\n    Scanner scanner = new Scanner(System.in);\n    boolean quitLoop = false;\n    boolean forward = true;\n\n    printMenu();\n\n    while (!quitLoop) {\n        // Handle boundaries\n        if (!iterator.hasPrevious()) {\n            System.out.println(\"Originating: \" + iterator.next());\n            forward = true;\n        }\n        if (!iterator.hasNext()) {\n            System.out.println(\"Final: \" + iterator.previous());\n            forward = false;\n        }\n\n        System.out.println(\"Enter action: \");\n        String menuItem = scanner.nextLine().toUpperCase().substring(0, 1);\n\n        switch (menuItem) {\n            case \"F\" -&gt; {\n                System.out.println(\"User wants to move forward.\");\n                if (!forward) {          // Was going backward \u2192 reverse\n                    forward = true;\n                    if (iterator.hasNext()) {\n                        iterator.next(); // Adjust cursor by one extra step\n                    }\n                }\n                if (iterator.hasNext()) {\n                    System.out.println(iterator.next());\n                }\n            }\n            case \"B\" -&gt; {\n                System.out.println(\"User wants to move backwards.\");\n                if (forward) {           // Was going forward \u2192 reverse\n                    forward = false;\n                    if (iterator.hasPrevious()) {\n                        iterator.previous(); // Adjust cursor by one extra step\n                    }\n                }\n                if (iterator.hasPrevious()) {\n                    System.out.println(iterator.previous());\n                }\n            }\n            case \"L\" -&gt; {\n                System.out.println(\"Places to visit:\");\n                System.out.println(placesToVisit);\n            }\n            case \"M\" -&gt; printMenu();\n            case \"Q\" -&gt; quitLoop = true;\n        }\n    }\n}\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#why-direction-reversal-needs-an-extra-step","title":"Why Direction Reversal Needs an Extra Step","text":"<pre><code>flowchart LR\n    subgraph problem[\"Direction Reversal Problem\"]\n        direction TB\n        S1[\"After 3 forward calls:&lt;br/&gt;cursor is between Adelaide and Alice Springs\"]\n        S2[\"User presses B (backward)\"]\n        S3[\"previous() returns Adelaide (correct!)\"]\n        S4[\"But WITHOUT adjustment:&lt;br/&gt;previous() would return Alice Springs&lt;br/&gt;(the element we just came from)\"]\n    end\n\n    S1 --&gt; S2 --&gt; S3\n    S2 -.-&gt;|\"Without fix\"| S4\n\n    style S4 fill:#f44336,color:#fff\n    style S3 fill:#4CAF50,color:#fff</code></pre> <p>When changing direction, the cursor sits between two elements. Calling the opposite direction method returns the element you just visited \u2014 not the one before/after it. The fix: call <code>next()</code> or <code>previous()</code> once to skip over the current element before retrieving the desired one.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#menu-display-with-text-block","title":"Menu Display with Text Block","text":"<pre><code>private static void printMenu() {\n    System.out.println(\"\"\"\n            Available actions (select word or letter):\n            (F)orward\n            (B)ackwards\n            (L)ist places\n            (M)enu\n            (Q)uit\n            \"\"\");\n}\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#key-techniques-used","title":"Key Techniques Used","text":"Technique Code Purpose Record type <code>record Place(String name, int distance)</code> Auto-generated constructor, <code>equals()</code>, <code>toString()</code>, accessors Record accessor <code>place.name()</code>, <code>place.distance()</code> Not <code>getName()</code> \u2014 records use the field name directly Case-insensitive compare <code>p.name().equalsIgnoreCase(place.name())</code> Prevent \"Adelaide\" and \"adelaide\" duplicates Ordered insert Track <code>matchedIndex</code> in for-each loop Insert at the first position where distance is less <code>addFirst()</code> <code>placesToVisit.addFirst(new Place(\"Sydney\", 0))</code> Ensure starting point is always first Direction flag <code>boolean forward</code> Track current traversal direction to compensate for cursor behavior Cursor adjustment Extra <code>next()</code> / <code>previous()</code> call Skip duplicate element when reversing direction <code>substring(0,1)</code> <code>scanner.nextLine().toUpperCase().substring(0,1)</code> Accept full words or single letters as input","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#common-pitfalls-summary","title":"Common Pitfalls Summary","text":"Pitfall Example Fix Indexed access in a loop <code>for (i) list.get(i)</code> Use enhanced <code>for</code> or <code>ListIterator</code> Modifying list during enhanced <code>for</code> <code>for (x : list) list.remove(x)</code> Use <code>iterator.remove()</code> instead Calling <code>list.remove()</code> during iteration <code>ConcurrentModificationException</code> Call <code>iterator.remove()</code> Forgetting cursor is between elements <code>next()</code> after <code>previous()</code> returns same element Use direction flag and extra adjustment call <code>var</code> with empty diamond <code>var list = new LinkedList&lt;&gt;()</code> Must specify type: <code>new LinkedList&lt;String&gt;()</code> Using <code>remove()</code> on empty list <code>NoSuchElementException</code> Use <code>poll()</code> (returns <code>null</code>) instead","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>LinkedList is a doubly linked chain \u2014 each node points to the next and previous node. There is no internal array and no indexing.</li> <li>LinkedList excels at adding/removing from the head or tail \u2014 these are O(1) operations, while ArrayList needs to shift elements (O(n)).</li> <li>ArrayList excels at random access \u2014 <code>get(i)</code> is O(1) for ArrayList but O(n) for LinkedList.</li> <li>LinkedList implements List, Queue, Deque interfaces \u2014 giving it methods like <code>offer</code>, <code>poll</code>, <code>push</code>, <code>pop</code>, <code>peek</code> in addition to standard list methods.</li> <li>Use <code>Iterator</code> for forward-only traversal with safe <code>remove()</code>. Use <code>ListIterator</code> for bidirectional traversal with <code>add()</code>, <code>set()</code>, and <code>remove()</code>.</li> <li>Never modify a list directly while iterating \u2014 always use the iterator's own mutation methods to avoid <code>ConcurrentModificationException</code>.</li> <li>When reversing direction with a ListIterator, make an extra <code>next()</code> or <code>previous()</code> call to compensate for the cursor position being between elements.</li> </ol>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#quick-reference","title":"Quick Reference","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#linkedlist-specific-methods-not-on-arraylist","title":"LinkedList-Specific Methods (Not on ArrayList)","text":"Category Method Description Add <code>addFirst(e)</code> / <code>addLast(e)</code> Insert at head / tail Add (Queue) <code>offer(e)</code> / <code>offerFirst(e)</code> / <code>offerLast(e)</code> Queue-style add (returns <code>boolean</code>) Add (Stack) <code>push(e)</code> Push to top (head) Remove <code>remove()</code> / <code>removeFirst()</code> / <code>removeLast()</code> Remove from head / tail (throws if empty) Remove (Queue) <code>poll()</code> / <code>pollFirst()</code> / <code>pollLast()</code> Remove from head / tail (null if empty) Remove (Stack) <code>pop()</code> Pop from top (head, throws if empty) Get <code>getFirst()</code> / <code>getLast()</code> Head / tail element (throws if empty) Get (Queue) <code>element()</code> Head element (throws if empty) Get (Safe) <code>peek()</code> / <code>peekFirst()</code> / <code>peekLast()</code> Head / tail (null if empty)","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#iterator-listiterator-methods","title":"Iterator / ListIterator Methods","text":"Method Iterator ListIterator Description <code>hasNext()</code> \u2705 \u2705 More elements ahead? <code>next()</code> \u2705 \u2705 Get next + advance cursor <code>hasPrevious()</code> \u274c \u2705 More elements behind? <code>previous()</code> \u274c \u2705 Get previous + move cursor back <code>remove()</code> \u2705 \u2705 Remove last returned element <code>add(e)</code> \u274c \u2705 Insert after current position <code>set(e)</code> \u274c \u2705 Replace last returned element","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#related-notes","title":"Related Notes","text":"Part Topic Link 1 Arrays &amp; <code>java.util.Arrays</code> \u2190 Part 1 2 ArrayList \u2014 Java's Resizable Array \u2190 Part 2 3 LinkedList &amp; Iterators You are here 4 Autoboxing, Unboxing &amp; Enums Part 4 \u2192","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part3/#references","title":"References","text":"<ul> <li>Course: Tim Buchalka - Java Programming Masterclass (Section 10, Lectures 7, 9\u201313)</li> <li>API: java.util.LinkedList (Java 17)</li> <li>API: java.util.Iterator (Java 17)</li> <li>API: java.util.ListIterator (Java 17)</li> </ul> <p>Last Updated: 2026-02-11 | Confidence: 9/10</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/","title":"Topic Note: Autoboxing, Unboxing &amp; Enums","text":"<p>Course: Java Programming Masterclass - Tim Buchalka (Udemy)</p> <p>Section: 10 - Mastering Lists, Iterators, and Autoboxing (Part 3: Autoboxing + Enums)</p> <p>Status:  Complete (Part 4 of Topic 3)</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#learning-objectives","title":"Learning Objectives","text":"<ul> <li> Understand why wrapper classes exist and when they are needed</li> <li> Manually box primitives using <code>valueOf()</code> and understand deprecated <code>new Integer()</code> constructors</li> <li> Leverage autoboxing (primitive \u2192 wrapper) and unboxing (wrapper \u2192 primitive) in variable assignments, method parameters, and return types</li> <li> Apply autoboxing/unboxing with arrays, varargs, and ArrayLists</li> <li> Build a simple Banking application using <code>ArrayList&lt;Double&gt;</code> with autoboxing/unboxing</li> <li> Declare and use <code>enum</code> types with predefined constants</li> <li> Use enum methods: <code>name()</code>, <code>ordinal()</code>, <code>values()</code></li> <li> Switch on enum values in enhanced switch statements</li> <li> Add custom methods to an enum type</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#part-a-autoboxing-unboxing","title":"Part A: Autoboxing &amp; Unboxing","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#1-why-wrapper-classes-matter","title":"1. Why Wrapper Classes Matter","text":"<p>Java has 8 primitive types (<code>int</code>, <code>double</code>, <code>char</code>, etc.) that are not objects. This causes a problem:</p> <pre><code>// \u274c WON'T COMPILE \u2014 generics don't accept primitives\nLinkedList&lt;int&gt; numbers = new LinkedList&lt;&gt;();\n\n// \u2705 Must use the wrapper class instead\nLinkedList&lt;Integer&gt; numbers = new LinkedList&lt;&gt;();\n</code></pre> <p>The Core Problem</p> <p>Collections like <code>ArrayList</code>, <code>LinkedList</code>, and all generic types (<code>List&lt;T&gt;</code>, <code>Map&lt;K,V&gt;</code>, etc.) require objects, not primitives. You cannot write <code>ArrayList&lt;int&gt;</code> \u2014 only <code>ArrayList&lt;Integer&gt;</code>.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#primitive-wrapper-class-mapping","title":"Primitive \u2194 Wrapper Class Mapping","text":"Primitive Wrapper Class Size <code>byte</code> <code>Byte</code> 8 bits <code>short</code> <code>Short</code> 16 bits <code>int</code> <code>Integer</code> 32 bits <code>long</code> <code>Long</code> 64 bits <code>float</code> <code>Float</code> 32 bits <code>double</code> <code>Double</code> 64 bits <code>char</code> <code>Character</code> 16 bits <code>boolean</code> <code>Boolean</code> 1 bit <p>Naming Convention</p> <p>Most wrapper classes are simply the capitalized form of the primitive (<code>double</code> \u2192 <code>Double</code>). The exceptions are <code>int</code> \u2192 <code>Integer</code> and <code>char</code> \u2192 <code>Character</code>.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#2-manual-boxing-unboxing","title":"2. Manual Boxing &amp; Unboxing","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#boxing-primitive-wrapper","title":"Boxing: Primitive \u2192 Wrapper","text":"<pre><code>// Method 1: Factory method (preferred manual way)\nInteger boxedInt = Integer.valueOf(15);\n\n// Method 2: Constructor (DEPRECATED since JDK 9 \u2014 do NOT use)\nInteger deprecatedBoxing = new Integer(15);  // \u26a0\ufe0f Marked for removal\n</code></pre> <p>Java's own documentation states:</p> <p>\"It is rarely appropriate to use this constructor. The static factory <code>valueOf(int)</code> is generally a better choice, as it is likely to yield significantly better space and time performance.\"</p> <p>The <code>valueOf()</code> method uses caching internally \u2014 for <code>Integer</code>, values between -128 and 127 are cached and reused, avoiding new object creation.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#unboxing-wrapper-primitive","title":"Unboxing: Wrapper \u2192 Primitive","text":"<pre><code>Integer boxedValue = Integer.valueOf(15);\nint unboxedInt = boxedValue.intValue();       // Manual unboxing\n\nDouble boxedDouble = Double.valueOf(3.14);\ndouble unboxedDouble = boxedDouble.doubleValue(); // Manual unboxing\n</code></pre> <p>Each wrapper class has a corresponding <code>xxxValue()</code> method: <code>intValue()</code>, <code>doubleValue()</code>, <code>charValue()</code>, <code>booleanValue()</code>, etc.</p> <p>You Almost Never Need Manual Boxing/Unboxing</p> <p>IntelliJ will flag both <code>Integer.valueOf()</code> and <code>.intValue()</code> as unnecessary boxing/unboxing. Java handles this automatically \u2014 which brings us to autoboxing.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#3-autoboxing-unboxing-let-java-do-the-work","title":"3. Autoboxing &amp; Unboxing \u2014 Let Java Do the Work","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#autoboxing-primitive-wrapper-automatically","title":"Autoboxing (Primitive \u2192 Wrapper, Automatically)","text":"<pre><code>Integer autoBoxed = 15;           // Java auto-boxes int \u2192 Integer\nDouble autoBoxedDouble = 3.14;    // Java auto-boxes double \u2192 Double\n</code></pre> <p>Underneath, Java is calling <code>Integer.valueOf(15)</code> for you, choosing the most efficient mechanism.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#auto-unboxing-wrapper-primitive-automatically","title":"Auto-Unboxing (Wrapper \u2192 Primitive, Automatically)","text":"<pre><code>Integer autoBoxed = 15;\nint autoUnboxed = autoBoxed;      // Java auto-unboxes Integer \u2192 int\n</code></pre> <pre><code>flowchart LR\n    subgraph autoboxing[\"Autoboxing\"]\n        P1[\"int 15\"] --&gt;|\"auto-boxes\"| W1[\"Integer(15)\"]\n    end\n    subgraph unboxing[\"Unboxing\"]\n        W2[\"Integer(15)\"] --&gt;|\"auto-unboxes\"| P2[\"int 15\"]\n    end\n\n    style autoboxing fill:#2196F3,color:#fff\n    style unboxing fill:#FF9800,color:#fff</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#important-limitation","title":"Important Limitation","text":"<pre><code>Integer autoBoxed = 15;\nSystem.out.println(autoBoxed.getClass().getName());  // \u2705 java.lang.Integer\n\nint autoUnboxed = autoBoxed;\n// System.out.println(autoUnboxed.getClass().getName());  // \u274c COMPILER ERROR!\n</code></pre> <p>You cannot call methods on a primitive variable. <code>getClass()</code> is an inherited method from <code>Object</code>, and primitives are not objects.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#4-autoboxing-in-method-parameters-return-types","title":"4. Autoboxing in Method Parameters &amp; Return Types","text":"<p>Autoboxing works seamlessly across method boundaries:</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#return-type-autoboxing","title":"Return Type Autoboxing","text":"<pre><code>private static Double getDoubleObject() {\n    return Double.valueOf(100.00);    // Returns a wrapper object\n}\n\nprivate static double getLiteralDoublePrimitive() {\n    return 100.0;                     // Returns a primitive\n}\n</code></pre> <pre><code>// Auto-boxes: method returns a primitive, but assigned to wrapper\nDouble resultBoxed = getLiteralDoublePrimitive();\n\n// Auto-unboxes: method returns a wrapper, but assigned to primitive\ndouble resultUnboxed = getDoubleObject();\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#parameter-type-autoboxing","title":"Parameter Type Autoboxing","text":"<pre><code>private static int returnAnInt(Integer i) {\n    return i;    // Unboxes Integer \u2192 int for the return type\n}\n\nprivate static Integer returnAnInteger(int i) {\n    return i;    // Autoboxes int \u2192 Integer for the return type\n}\n</code></pre> <p>The JVM handles all conversions transparently:</p> Scenario What Happens Assign primitive to wrapper variable Autoboxing Assign wrapper to primitive variable Unboxing Pass primitive to method expecting wrapper parameter Autoboxing Pass wrapper to method expecting primitive parameter Unboxing Return primitive from method with wrapper return type Autoboxing Return wrapper from method with primitive return type Unboxing","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#5-autoboxing-with-arrays-varargs-lists","title":"5. Autoboxing with Arrays, Varargs &amp; Lists","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#wrapper-arrays","title":"Wrapper Arrays","text":"<pre><code>// Array of Integer wrappers (not int primitives)\nInteger[] wrapperArray = new Integer[5];\nwrapperArray[0] = 50;                          // Autoboxes int \u2192 Integer\nSystem.out.println(Arrays.toString(wrapperArray));\n// [50, null, null, null, null]\n\nSystem.out.println(wrapperArray[0].getClass().getName());\n// java.lang.Integer\n</code></pre> <p>Default Values Differ</p> <ul> <li> <p><code>int[]</code> elements default to <code>0</code></p> </li> <li> <p><code>Integer[]</code> elements default to <code>null</code> (they are object references)</p> </li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#array-initializer-with-autoboxing","title":"Array Initializer with Autoboxing","text":"<pre><code>Character[] charArray = {'a', 'b', 'c'};       // Autoboxes char \u2192 Character\nSystem.out.println(Arrays.toString(charArray));\n// [a, b, c]\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#varargs-with-autoboxing","title":"Varargs with Autoboxing","text":"<pre><code>private static ArrayList&lt;Integer&gt; getList(int... varargs) {\n    ArrayList&lt;Integer&gt; alist = new ArrayList&lt;&gt;();\n    for (int i : varargs) {\n        alist.add(i);           // Autoboxes each int \u2192 Integer\n    }\n    return alist;\n}\n</code></pre> <p>Calling this method with primitive literals:</p> <pre><code>var ourList = getList(1, 2, 3, 4, 5);\nSystem.out.println(ourList);     // [1, 2, 3, 4, 5]\n</code></pre> <p>The <code>add()</code> method on <code>ArrayList&lt;Integer&gt;</code> expects an <code>Integer</code> parameter, but accepts <code>int</code> primitives through autoboxing.</p> <p>Varargs Type Doesn't Matter</p> <ul> <li> <p>You can change the parameter type from <code>int... varargs</code> to <code>Integer... varargs</code></p> </li> <li> <p>the code still works identically. The JVM auto-boxes the literal <code>int</code> values passed to the method before they're added to the varargs array.</p> </li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#using-listof-with-primitives","title":"Using <code>List.of()</code> with Primitives","text":"<pre><code>var ourList = List.of(1, 2, 3, 4, 5);    // Autoboxes to List&lt;Integer&gt;\n</code></pre> <p>This is the simplest way to create an immutable list of integers. Each literal is auto-boxed to an <code>Integer</code> instance.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#6-banking-challenge-autoboxing-in-practice","title":"6. Banking Challenge \u2014 Autoboxing in Practice","text":"<p>This challenge demonstrates autoboxing and unboxing in a real-world scenario: a simple banking application.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#the-customer-record","title":"The <code>Customer</code> Record","text":"<pre><code>record Customer(String name, ArrayList&lt;Double&gt; transactions) {\n\n    public Customer(String name, double initialDeposit) {\n        this(name.toUpperCase(),\n                new ArrayList&lt;Double&gt;(500));   // Capacity hint: ~500 transactions/year\n        transactions.add(initialDeposit);       // \u2190 AUTOBOXING: double \u2192 Double\n    }\n}\n</code></pre> <p>Key points:</p> <ul> <li>The canonical constructor takes a <code>String</code> and an <code>ArrayList&lt;Double&gt;</code></li> <li>The custom constructor takes a primitive <code>double</code> \u2014 autoboxing occurs when <code>add()</code> is called</li> <li><code>name.toUpperCase()</code> normalizes customer names for case-insensitive matching</li> <li>Initial capacity <code>500</code> prevents incremental reallocations for typical usage</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#the-bank-class","title":"The <code>Bank</code> Class","text":"<pre><code>class Bank {\n    private String name;\n    private ArrayList&lt;Customer&gt; customers = new ArrayList&lt;&gt;(5000);\n\n    public Bank(String name) {\n        this.name = name;\n    }\n</code></pre> <p>Encapsulation Pattern</p> <p>The <code>customers</code> list has no getter. External code cannot access or modify the customer list directly \u2014 all operations go through Bank's public methods. This is a key OOP design principle.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#finding-a-customer","title":"Finding a Customer","text":"<pre><code>private Customer getCustomer(String customerName) {\n    for (var customer : customers) {\n        if (customer.name().equalsIgnoreCase(customerName))\n            return customer;\n    }\n    System.out.printf(\"Customer (%s) wasn't found %n\", customerName);\n    return null;\n}\n</code></pre> <ul> <li><code>private</code> \u2014 only the Bank can look up customers</li> <li>Uses case-insensitive comparison (<code>equalsIgnoreCase</code>)</li> <li>Returns <code>null</code> if no match (simple error handling for this challenge)</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#adding-a-new-customer-with-duplicate-prevention","title":"Adding a New Customer (with Duplicate Prevention)","text":"<pre><code>public void addNewCustomer(String customerName, double initialDeposit) {\n    if (getCustomer(customerName) == null) {\n        Customer customer = new Customer(customerName, initialDeposit);\n        customers.add(customer);\n        System.out.println(\"New Customer added: \" + customer);\n    }\n}\n</code></pre> <p>Note: <code>getCustomer</code> prints \"not found\" when checking for duplicates during <code>addNewCustomer</code>. In production code, you'd separate the \"exists\" check from the \"not found\" message.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#adding-a-transaction-autoboxing","title":"Adding a Transaction (Autoboxing)","text":"<pre><code>public void addTransaction(String name, double transactionAmount) {\n    Customer customer = getCustomer(name);\n    if (customer != null) {\n        customer.transactions().add(transactionAmount);   // \u2190 AUTOBOXING\n    }\n}\n</code></pre> <p><code>transactionAmount</code> is a primitive <code>double</code> \u2192 the <code>add()</code> method on <code>ArrayList&lt;Double&gt;</code> autoboxes it to a <code>Double</code> wrapper object.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#printing-a-statement-unboxing","title":"Printing a Statement (Unboxing)","text":"<pre><code>public void printStatement(String customerName) {\n    Customer customer = getCustomer(customerName);\n    if (customer == null) {\n        return;\n    }\n    System.out.println(\"_\".repeat(30));\n    System.out.println(\"Customer Name: \" + customer.name());\n    System.out.println(\"Transactions: \");\n    for (double d : customer.transactions()) {      // \u2190 UNBOXING\n        System.out.printf(\"$%10.2f (%s)%n\",\n                d, d &lt; 0 ? \"Debit\" : \"Credit\");\n    }\n}\n</code></pre> <p>This is the unboxing part: The for-each loop iterates over <code>ArrayList&lt;Double&gt;</code> (wrapper objects), but the loop variable <code>d</code> is declared as a primitive <code>double</code>. Each <code>Double</code> wrapper object is automatically unboxed to <code>double</code>.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#usage-output","title":"Usage &amp; Output","text":"<pre><code>Bank bank = new Bank(\"Chase\");\nbank.addNewCustomer(\"Jane A\", 1000);\n\nbank.addTransaction(\"Jane A\", -10.25);    // Debit\nbank.addTransaction(\"Jane A\", -75.01);    // Debit\nbank.printStatement(\"Jane A\");\n\nbank.addNewCustomer(\"Bob S\", 25);\nbank.addTransaction(\"Bob S\", 100);        // Credit\nbank.printStatement(\"Bob S\");\n</code></pre> <pre><code>______________________________\nCustomer Name: JANE A\nTransactions:\n$   1000.00 (Credit)\n$    -10.25 (Debit)\n$    -75.01 (Debit)\n______________________________\nCustomer Name: BOB S\nTransactions:\n$     25.00 (Credit)\n$    100.00 (Credit)\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#where-autoboxingunboxing-occurs","title":"Where Autoboxing/Unboxing Occurs","text":"<pre><code>flowchart TD\n    subgraph autoboxing_points[\"Autoboxing Points (double \u2192 Double)\"]\n        AB1[\"Customer constructor:&lt;br/&gt;transactions.add(initialDeposit)\"]\n        AB2[\"Bank.addTransaction:&lt;br/&gt;customer.transactions().add(transactionAmount)\"]\n    end\n\n    subgraph unboxing_points[\"Unboxing Points (Double \u2192 double)\"]\n        UB1[\"Bank.printStatement:&lt;br/&gt;for (double d : customer.transactions())\"]\n    end\n\n    style autoboxing_points fill:#2196F3,color:#fff\n    style unboxing_points fill:#FF9800,color:#fff</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#part-b-enums","title":"Part B: Enums","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#7-what-is-an-enum","title":"7. What Is an Enum?","text":"<p>An enum (short for enumeration) is a special Java type that contains a fixed set of predefined constants.</p> <p>Wikipedia: \"A complete ordered listing of all the items in a collection.\"</p> <p>Java: \"A special data type that contains predefined constants.\"</p> <p>An enum is like an array, except:</p> <ul> <li>Its elements are known at compile time and cannot change</li> <li>Each element is referred to by a named constant, not an index</li> <li>The keyword <code>enum</code> replaces <code>class</code></li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#declaring-an-enum","title":"Declaring an Enum","text":"<pre><code>public enum DayOfTheWeek {\n    SUN, MON, TUE, WED, THU, FRI, SAT\n}\n</code></pre> <p>Conventions:</p> <ul> <li>Enum name: UpperCamelCase (like a class)</li> <li>Constants: ALL_UPPERCASE (like final static fields)</li> <li>No semicolon needed after the last constant (unless you add methods/fields)</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#common-enum-examples","title":"Common Enum Examples","text":"<pre><code>enum Month       { JANUARY, FEBRUARY, MARCH, /* ... */ DECEMBER }\nenum Direction    { NORTH, EAST, SOUTH, WEST }\nenum Size         { EXTRA_SMALL, SMALL, MEDIUM, LARGE, EXTRA_LARGE }\n</code></pre> <p>Enums Are Classes Underneath</p> <p>Each enum constant is actually an instance of the enum class. Enums can have fields, methods, and constructors \u2014 they are much more than simple constant lists.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#8-using-enums-in-code","title":"8. Using Enums in Code","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#declaring-and-assigning","title":"Declaring and Assigning","text":"<pre><code>DayOfTheWeek weekDay = DayOfTheWeek.TUE;\nSystem.out.println(weekDay);      // TUE\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#built-in-enum-methods","title":"Built-in Enum Methods","text":"Method Returns Description <code>name()</code> <code>String</code> The constant's name as declared (e.g., <code>\"TUE\"</code>) <code>ordinal()</code> <code>int</code> Zero-based position in the enum (e.g., <code>TUE</code> \u2192 <code>2</code>) <code>values()</code> <code>EnumType[]</code> Array of all constants in declaration order <pre><code>System.out.printf(\"Name is %s, Ordinal Value = %d%n\",\n        weekDay.name(), weekDay.ordinal());\n// Name is TUE, Ordinal Value = 2\n</code></pre> <p>Ordinal is Zero-Based</p> <p>Like arrays and lists, enum ordinals start at 0. <code>SUN</code> is ordinal <code>0</code>, <code>SAT</code> is ordinal <code>6</code>. If you want 1-based numbering (e.g., \"Day 1\"), add 1: <code>weekDay.ordinal() + 1</code>.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#comparing-enums","title":"Comparing Enums","text":"<pre><code>if (weekDay == DayOfTheWeek.FRI) {\n    System.out.println(\"Found Friday!\");\n}\n</code></pre> <p>Use <code>==</code> (not <code>.equals()</code>) for enum comparison \u2014 enum constants are singletons, so reference equality works perfectly and is preferred.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#iterating-over-all-constants-with-values","title":"Iterating Over All Constants with <code>values()</code>","text":"<pre><code>for (DayOfTheWeek day : DayOfTheWeek.values()) {\n    System.out.println(day.name() + \" (ordinal: \" + day.ordinal() + \")\");\n}\n</code></pre> <p>The <code>values()</code> method returns a new array of all enum constants in declaration order. You can use this array with enhanced <code>for</code>, indexed access, or <code>Random</code>:</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#random-enum-value","title":"Random Enum Value","text":"<pre><code>public static DayOfTheWeek getRandomDay() {\n    int randomInteger = new Random().nextInt(7);   // 0\u20136\n    var allDays = DayOfTheWeek.values();            // Returns DayOfTheWeek[]\n    return allDays[randomInteger];\n}\n</code></pre> <p>Because <code>values()</code> returns a regular Java array, you can index into it with <code>[]</code>.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#9-enums-in-switch-statements","title":"9. Enums in Switch Statements","text":"<p>Enums work as switch expressions \u2014 this is one of their most powerful features:</p> <pre><code>public static void switchDayOfWeek(DayOfTheWeek weekDay) {\n    int weekDayInteger = weekDay.ordinal() + 1;\n\n    switch (weekDay) {\n        case WED -&gt; System.out.println(\"Wednesday is day \" + weekDayInteger);\n        case SAT -&gt; System.out.println(\"Saturday is day \" + weekDayInteger);\n        default -&gt; System.out.println(\n                weekDay.name().charAt(0) +\n                weekDay.name().substring(1).toLowerCase() +\n                \" is day \" + weekDayInteger);\n    }\n}\n</code></pre> <p>Key observations:</p> <ol> <li>The switch expression is the enum variable itself (<code>weekDay</code>)</li> <li>Case labels use the constant name without the enum type prefix \u2014 just <code>WED</code>, not <code>DayOfTheWeek.WED</code></li> <li>The <code>default</code> branch uses String manipulation to convert <code>\"TUE\"</code> \u2192 <code>\"Tue\"</code> \u2192 <code>\"Tuesday is day 3\"</code></li> </ol> <p>Switch Expression Types</p> <p>You can switch on: <code>int</code>, <code>char</code>, <code>byte</code>, <code>short</code>, <code>String</code>, and <code>enum</code>. Enum switches are especially readable because the case labels are human-readable constant names.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#10-adding-custom-methods-to-enums","title":"10. Adding Custom Methods to Enums","text":"<p>Since enums are classes, you can add methods. You must add a semicolon after the last constant before adding any members:</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#the-topping-enum-with-getprice-method","title":"The <code>Topping</code> Enum with <code>getPrice()</code> Method","text":"<pre><code>public enum Topping {\n    MUSTARD,\n    PICKLES,\n    BACON,\n    CHEDDAR,\n    TOMATO;                  // \u2190 SEMICOLON required before methods\n\n    public double getPrice() {\n        return switch (this) {          // Switch on the enum instance itself\n            case MUSTARD, PICKLES -&gt; 0.50;\n            case BACON -&gt; 1.50;\n            case CHEDDAR -&gt; 1.00;\n            case TOMATO -&gt; 0.75;\n        };\n    }\n}\n</code></pre> <p>Key points:</p> <ul> <li>The <code>switch (this)</code> expression refers to the current enum instance calling the method</li> <li>Enhanced switch with <code>-&gt;</code> returns different values per constant</li> <li>Multiple case labels can share a result: <code>case MUSTARD, PICKLES -&gt; 0.50</code></li> <li>No <code>default</code> needed \u2014 enum switch covers all possible values (compiler verifies exhaustiveness)</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#using-the-custom-method","title":"Using the Custom Method","text":"<pre><code>for (Topping topping : Topping.values()) {\n    System.out.println(topping.name() + \" : \" + topping.getPrice());\n}\n</code></pre> <pre><code>MUSTARD : 0.5\nPICKLES : 0.5\nBACON : 1.5\nCHEDDAR : 1.0\nTOMATO : 0.75\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#alternative-enum-with-fields-and-constructors-preview","title":"Alternative: Enum with Fields and Constructors (Preview)","text":"<p>Another approach (covered in depth later in the course) uses a field and constructor:</p> <pre><code>public enum Topping {\n    MUSTARD(0.50),\n    PICKLES(0.50),\n    BACON(1.50),\n    CHEDDAR(1.00),\n    TOMATO(0.75);\n\n    private final double price;\n\n    Topping(double price) {\n        this.price = price;\n    }\n\n    public double getPrice() {\n        return price;\n    }\n}\n</code></pre> <p>This pattern is more scalable when enums have multiple associated values.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#common-pitfalls-summary","title":"Common Pitfalls Summary","text":"Pitfall Example Fix Using primitive in generic type <code>ArrayList&lt;int&gt;</code> Use wrapper: <code>ArrayList&lt;Integer&gt;</code> Using deprecated wrapper constructors <code>new Integer(15)</code> Use <code>Integer.valueOf(15)</code> or just <code>15</code> Calling methods on primitives <code>autoUnboxed.getClass()</code> Use the wrapper variable instead Unboxing <code>null</code> \u2192 <code>NullPointerException</code> <code>Integer x = null; int y = x;</code> Check for <code>null</code> before unboxing Forgetting semicolon in enum Adding methods without <code>;</code> after constants Add <code>;</code> after last constant before methods Using enum type prefix in switch case <code>case DayOfTheWeek.WED:</code> Just use <code>case WED:</code> Assuming ordinal is 1-based <code>weekDay.ordinal()</code> for \"Day 1\" Add 1: <code>weekDay.ordinal() + 1</code> <p>The Most Dangerous Pitfall: Unboxing <code>null</code></p> <pre><code>Integer maybeNull = null;\nint value = maybeNull;         // \ud83d\udca5 NullPointerException at runtime!\n</code></pre> <ul> <li>When a wrapper variable is <code>null</code> and Java tries to unbox it, you get a <code>NullPointerException</code>. This compiles without issues</li> <li>the error only appears at runtime. Always check for <code>null</code> before unboxing, especially with values from collections or method returns.</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#key-takeaways","title":"Key Takeaways","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#autoboxing-unboxing","title":"Autoboxing &amp; Unboxing","text":"<ol> <li>Collections require objects, not primitives \u2014 this is the fundamental reason wrapper classes exist.</li> <li>Autoboxing (<code>int</code> \u2192 <code>Integer</code>) and unboxing (<code>Integer</code> \u2192 <code>int</code>) happen automatically in assignments, method parameters, return types, and enhanced loops.</li> <li>Prefer autoboxing over manual <code>valueOf()</code> or deprecated constructors \u2014 let Java choose the most efficient mechanism.</li> <li>Wrapper arrays default to <code>null</code>, not <code>0</code> \u2014 a common source of <code>NullPointerException</code>.</li> <li>Performance consideration: Excessive boxing/unboxing in tight loops can cause unnecessary object creation. Use primitive arrays when performance matters significantly.</li> </ol>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#enums","title":"Enums","text":"<ol> <li>Enums are fixed, ordered sets of named constants \u2014 use them instead of <code>int</code> or <code>String</code> constants for type safety.</li> <li>Enum constants are singletons \u2014 compare with <code>==</code>, not <code>.equals()</code>.</li> <li><code>values()</code> returns an array \u2014 iterate with enhanced <code>for</code> or index into it for random access.</li> <li>Enums work in switch statements \u2014 case labels use the constant name without type prefix.</li> <li>Enums can have methods, fields, and constructors \u2014 they are full-featured classes with a fixed number of instances.</li> </ol>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#quick-reference","title":"Quick Reference","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#wrapper-class-methods","title":"Wrapper Class Methods","text":"Method Description Example <code>Type.valueOf(primitive)</code> Manual boxing (factory) <code>Integer.valueOf(15)</code> <code>wrapper.typeValue()</code> Manual unboxing <code>myInt.intValue()</code> <code>Type.parseType(string)</code> Parse string to primitive <code>Integer.parseInt(\"42\")</code> <code>Type.toString(primitive)</code> Convert to String <code>Integer.toString(42)</code> <code>Type.MAX_VALUE</code> Maximum value for type <code>Integer.MAX_VALUE</code> <code>Type.MIN_VALUE</code> Minimum value for type <code>Double.MIN_VALUE</code>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#enum-methods","title":"Enum Methods","text":"Method Returns Description <code>name()</code> <code>String</code> Constant name exactly as declared <code>ordinal()</code> <code>int</code> Zero-based position in the enum <code>values()</code> <code>EnumType[]</code> Array of all constants (static) <code>valueOf(String)</code> <code>EnumType</code> Look up constant by name (throws <code>IllegalArgumentException</code>) <code>compareTo(other)</code> <code>int</code> Compare ordinal positions <code>toString()</code> <code>String</code> Same as <code>name()</code> by default, can be overridden","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#related-notes","title":"Related Notes","text":"Part Topic Link 1 Arrays &amp; <code>java.util.Arrays</code> \u2190 Part 1 2 ArrayList \u2014 Java's Resizable Array \u2190 Part 2 3 LinkedList &amp; Iterators \u2190 Part 3 4 Autoboxing, Unboxing &amp; Enums You are here","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note-part4/#references","title":"References","text":"<ul> <li>Course: Tim Buchalka - Java Programming Masterclass (Section 10, Lectures 15\u201318, 20\u201321)</li> <li>API: java.lang.Integer (Java 17)</li> <li>API: java.lang.Enum (Java 17)</li> <li>Guide: Autoboxing and Unboxing (Oracle Tutorial)</li> <li>Guide: Enum Types (Oracle Tutorial)</li> </ul> <p>Last Updated: 2026-02-11 | Confidence: 9/10</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/","title":"Topic Note: Advanced Arrays in Java","text":"<p>Course: Java Programming Masterclass - Tim Buchalka (Udemy).</p> <p>Section: 09 - Advanced Arrays in Java: Single &amp; Multi-Dimensional Techniques</p> <p>Status:  Complete (Part 1 of Topic 3)</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#learning-objectives","title":"Learning Objectives","text":"<ul> <li> Understand what an array is and how Java implements it</li> <li> Master all forms of array declaration and initialization</li> <li> Loop through arrays with traditional <code>for</code> and enhanced <code>for-each</code></li> <li> Use the <code>java.util.Arrays</code> helper class effectively</li> <li> Understand binary search prerequisites and behavior</li> <li> Identify and avoid common array pitfalls</li> <li> Understand arrays as reference types (and what that means for methods)</li> <li> Use variable arguments (varargs) in methods</li> <li> Work with two-dimensional and multi-dimensional arrays</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#1-what-is-an-array","title":"1. What Is an Array?","text":"<p>An array is a data structure that stores a fixed number of values, all of the same type, in a contiguous block of memory.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#why-arrays-exist","title":"Why Arrays Exist","text":"<p>Before arrays, if you needed multiple values of the same type (e.g., 10 toppings for a burger), you had to create individual variables for each one. This leads to:</p> <ul> <li>Repetitive, hard-to-maintain code</li> <li>No way to loop through the values</li> <li>A fixed structure that can't scale</li> </ul> <p>Arrays solve this by grouping values under a single variable name, accessible by index.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#key-facts","title":"Key Facts","text":"Property Detail Type Special class in Java (inherits from <code>java.lang.Object</code>) Size Fixed at creation time \u2014 cannot grow or shrink Indexing Zero-based (first element is at index <code>0</code>) Types Can hold any primitive type or any object type Memory Stored on the heap (the variable holds a reference) <pre><code>flowchart LR\n    subgraph declaration[\" ARRAY IN MEMORY \"]\n        direction LR\n        I0[\"[0]&lt;br/&gt;10\"] --- I1[\"[1]&lt;br/&gt;35\"] --- I2[\"[2]&lt;br/&gt;20\"] --- I3[\"[3]&lt;br/&gt;17\"] --- I4[\"[4]&lt;br/&gt;18\"]\n    end\n\n    REF[\"myArray&lt;br/&gt;(reference)\"] --&gt; declaration</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#2-declaring-initializing-and-accessing-arrays","title":"2. Declaring, Initializing, and Accessing Arrays","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#declaration-styles","title":"Declaration Styles","text":"<pre><code>// Style 1: Brackets after the type (PREFERRED)\nint[] myArray;\n\n// Style 2: Also brackets after the type\nint[] myArray;\n\n// Style 3: Brackets after the variable name (valid but less common)\nint myArray[];\n</code></pre> <p>Convention</p> <p>Always place brackets after the type (<code>int[]</code>), not after the variable name. This is the standard Java convention and makes the type clearer.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#instantiation-with-new","title":"Instantiation with <code>new</code>","text":"<pre><code>int[] myIntArray = new int[10];  // Array of 10 integers\n</code></pre> <p>Under the covers, a Java array is a specialized class, which is why the <code>new</code> keyword is used. Two key differences from regular object creation:</p> <ol> <li>Square brackets are required with a size specified inside</li> <li>No parentheses \u2014 you cannot pass data to an array constructor</li> </ol> <pre><code>flowchart LR\n    subgraph arrayCreation[\" ARRAY CREATION \"]\n        direction TB\n        A[\"int[] myArray\"] --&gt;|\"= new int[10]\"| B[\"Array of 10 ints&lt;br/&gt;on the heap\"]\n    end\n\n    subgraph objectCreation[\" OBJECT CREATION \"]\n        direction TB\n        C[\"Person p\"] --&gt;|\"= new Person()\"| D[\"Person object&lt;br/&gt;on the heap\"]\n    end</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#array-initializers","title":"Array Initializers","text":"<p>If you know the values upfront, use an array initializer:</p> <pre><code>// Explicit array initializer (with new keyword)\nint[] firstTen = new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n// Anonymous array initializer (shorthand \u2014 only in declaration)\nint[] firstTen = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n// String array with anonymous initializer\nString[] names = {\"Andy\", \"Bob\", \"Charlie\", \"Dave\", \"Eve\"};\n</code></pre> <p>Anonymous Initializer Restriction</p> <p>The anonymous initializer (<code>{1, 2, 3}</code>) can only be used in a declaration statement. If you assign on a separate line, you must use the explicit form:</p> <pre><code>int[] newArray;\n// newArray = {5, 4, 3, 2, 1};           // COMPILE ERROR!\nnewArray = new int[]{5, 4, 3, 2, 1};      // OK\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#accessing-elements","title":"Accessing Elements","text":"<pre><code>int[] firstTen = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\nint first = firstTen[0];                        // 1 (first element)\nint last  = firstTen[firstTen.length - 1];      // 10 (last element)\n\n// WRONG \u2014 causes ArrayIndexOutOfBoundsException!\n// int oops = firstTen[firstTen.length];        // Index 10 is out of bounds!\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#the-length-field","title":"The <code>.length</code> Field","text":"<p>Every array has a field (not a method) called <code>length</code>:</p> <pre><code>int arrayLength = firstTen.length;  // 10\n</code></pre> <p>Field vs Method</p> <p><code>.length</code> is a field on arrays (no parentheses). This is different from <code>String.length()</code> which is a method (with parentheses).</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#3-default-values","title":"3. Default Values","text":"<p>When you create an array without an initializer, Java sets every element to the default value for that type:</p> Array Type Default Value <code>int[]</code>, <code>long[]</code>, <code>short[]</code>, <code>byte[]</code> <code>0</code> <code>double[]</code>, <code>float[]</code> <code>0.0</code> <code>boolean[]</code> <code>false</code> <code>char[]</code> <code>'\\u0000'</code> (null character) <code>String[]</code>, <code>Object[]</code>, any class <code>null</code> <pre><code>int[] zeros = new int[5];\n// zeros \u2192 [0, 0, 0, 0, 0]\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#4-looping-through-arrays","title":"4. Looping Through Arrays","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#traditional-for-loop","title":"Traditional <code>for</code> Loop","text":"<p>Use when you need the index \u2014 for setting values, swapping, or accessing by position:</p> <pre><code>int[] newArray = new int[5];\n\n// Populate with computed values (5, 4, 3, 2, 1)\nfor (int i = 0; i &lt; newArray.length; i++) {\n    newArray[i] = newArray.length - i;\n}\n\n// Print each element\nfor (int i = 0; i &lt; newArray.length; i++) {\n    System.out.print(newArray[i] + \" \");\n}\n// Output: 5 4 3 2 1\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#enhanced-for-each-loop","title":"Enhanced <code>for-each</code> Loop","text":"<p>Use when you only need to read elements from start to finish:</p> <pre><code>for (int element : newArray) {\n    System.out.print(element + \" \");\n}\n// Output: 5 4 3 2 1\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#side-by-side-comparison","title":"Side-by-Side Comparison","text":"<pre><code>// Traditional for loop                    // Enhanced for-each loop\nfor (int i = 0; i &lt; arr.length; i++) {     for (int element : arr) {\n    System.out.print(arr[i]);                  System.out.print(element);\n}                                          }\n</code></pre> Aspect Traditional <code>for</code> Enhanced <code>for-each</code> Syntax 3 components, semicolons 2 components, colon Index access Yes (<code>i</code>) No Modify elements Yes No (can't set values) Error-prone More (off-by-one) Less Best for Setting, swapping, sorting Reading, printing <p>Rule of Thumb</p> <p>Use the enhanced for-each loop as your default. Only fall back to the traditional <code>for</code> loop when you need to modify elements or need the index.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#5-printing-arrays","title":"5. Printing Arrays","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#the-println-gotcha","title":"The <code>println</code> Gotcha","text":"<pre><code>int[] myArray = {5, 4, 3, 2, 1};\nSystem.out.println(myArray);\n// Output: [I@6d06d69c   \u2190 NOT the elements!\n</code></pre> <p>Why? Printing an array directly calls <code>Object.toString()</code>, which returns:</p> <ul> <li><code>[I</code> \u2014 indicates a primitive <code>int</code> array</li> <li><code>@6d06d69c</code> \u2014 hexadecimal hash code</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#the-correct-way-arraystostring","title":"The Correct Way: <code>Arrays.toString()</code>","text":"<pre><code>import java.util.Arrays;\n\nSystem.out.println(Arrays.toString(myArray));\n// Output: [5, 4, 3, 2, 1]\n</code></pre> <p>For multi-dimensional arrays, use <code>Arrays.deepToString()</code>:</p> <pre><code>int[][] matrix = {{1, 2}, {3, 4}};\nSystem.out.println(Arrays.deepToString(matrix));\n// Output: [[1, 2], [3, 4]]\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#6-the-javautilarrays-helper-class","title":"6. The <code>java.util.Arrays</code> Helper Class","text":"<p>Java's array type is very basic \u2014 it only has the <code>.length</code> field and inherits from <code>Object</code>. The <code>java.util.Arrays</code> class provides static utility methods for common operations.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#arrayssort-sorting","title":"<code>Arrays.sort()</code> \u2014 Sorting","text":"<p>Sorts elements in ascending (natural) order. Modifies the array in place (void return):</p> <pre><code>int[] firstArray = getRandomArray(10);\nSystem.out.println(Arrays.toString(firstArray));\n// Output: [82, 15, 47, 93, 27, 56, 8, 73, 41, 62]\n\nArrays.sort(firstArray);\nSystem.out.println(Arrays.toString(firstArray));\n// Output: [8, 15, 27, 41, 47, 56, 62, 73, 82, 93]\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#arraysfill-filling","title":"<code>Arrays.fill()</code> \u2014 Filling","text":"<p>Sets all elements to a specified value:</p> <pre><code>int[] secondArray = new int[10];\nSystem.out.println(Arrays.toString(secondArray));\n// Output: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n\nArrays.fill(secondArray, 5);\nSystem.out.println(Arrays.toString(secondArray));\n// Output: [5, 5, 5, 5, 5, 5, 5, 5, 5, 5]\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#arrayscopyof-copying","title":"<code>Arrays.copyOf()</code> \u2014 Copying","text":"<p>Creates a new array (a new object in memory). Three modes:</p> <pre><code>int[] thirdArray = getRandomArray(10);\n\n// 1. Exact copy (same length)\nint[] fourthArray = Arrays.copyOf(thirdArray, thirdArray.length);\n\n// 2. Partial copy (first 5 elements only)\nint[] smallerArray = Arrays.copyOf(thirdArray, 5);\n\n// 3. Expanded copy (original + 5 extra zeros)\nint[] largerArray = Arrays.copyOf(thirdArray, 15);\n</code></pre> <pre><code>flowchart TB\n    ORIG[\"Original: [82, 15, 47, 93, 27, 56, 8, 73, 41, 62]\"]\n\n    ORIG --&gt;|\"copyOf(arr, 10)\"| EXACT[\"[82, 15, 47, 93, 27, 56, 8, 73, 41, 62]\"]\n    ORIG --&gt;|\"copyOf(arr, 5)\"| PARTIAL[\"[82, 15, 47, 93, 27]\"]\n    ORIG --&gt;|\"copyOf(arr, 15)\"| EXPANDED[\"[82, 15, 47, 93, 27, 56, 8, 73, 41, 62, 0, 0, 0, 0, 0]\"]</code></pre> <p>Copy Independence</p> <p>Operations on the copy (like <code>sort</code> or <code>fill</code>) do not affect the original array. For primitives, values are copied. For objects, references are copied (shallow copy).</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#arraysequals-equality-check","title":"<code>Arrays.equals()</code> \u2014 Equality Check","text":"<p>Two arrays are equal if they have the same length and same elements in the same order:</p> <pre><code>int[] s1 = {1, 2, 3, 4, 5};\nint[] s2 = {1, 2, 3, 4, 5};\nSystem.out.println(Arrays.equals(s1, s2));  // true\n\nint[] s3 = {5, 2, 3, 4, 1};  // Same values, different order\nSystem.out.println(Arrays.equals(s1, s3));  // false\n\nint[] s4 = {1, 2, 3, 4, 5, 0};  // Different length\nSystem.out.println(Arrays.equals(s1, s4));  // false\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#complete-helper-class-reference","title":"Complete Helper Class Reference","text":"Method Returns Modifies Original? Description <code>Arrays.toString(arr)</code> <code>String</code> No Formatted string of elements <code>Arrays.deepToString(arr)</code> <code>String</code> No Formatted string for multi-dimensional <code>Arrays.sort(arr)</code> <code>void</code> Yes Sorts in ascending order <code>Arrays.fill(arr, val)</code> <code>void</code> Yes Sets all elements to <code>val</code> <code>Arrays.copyOf(arr, len)</code> New array No Creates a copy with specified length <code>Arrays.binarySearch(arr, key)</code> <code>int</code> No Finds position of <code>key</code> (must be sorted) <code>Arrays.equals(arr1, arr2)</code> <code>boolean</code> No Checks structural equality","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#the-getrandomarray-helper-method","title":"The <code>getRandomArray</code> Helper Method","text":"<p>This utility method is used throughout the course examples:</p> <pre><code>private static int[] getRandomArray(int len) {\n    Random random = new Random();\n    int[] arr = new int[len];\n    for (int i = 0; i &lt; len; i++) {\n        arr[i] = random.nextInt(100);  // 0 to 99 (exclusive upper bound)\n    }\n    return arr;\n}\n</code></pre> <p><code>Random.nextInt(bound)</code></p> <p>The argument is an exclusive upper bound. <code>nextInt(100)</code> returns a random integer from 0 to 99. To include 100, pass <code>101</code>.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#7-binary-search-deep-dive","title":"7. Binary Search Deep Dive","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#how-it-works","title":"How It Works","text":"<p>Binary search is an interval search \u2014 instead of checking every element one by one (linear search), it repeatedly divides the search space in half.</p> <p>Think of finding a word in a dictionary: you don't start on page 1 \u2014 you open to roughly where you think the word is, then narrow down.</p> <pre><code>flowchart TD\n    A[\"Sorted Array: [3, 8, 15, 27, 41, 56, 73, 82, 93]&lt;br/&gt;Looking for: 56\"] --&gt; B[\"Check middle: 41\"]\n    B --&gt;|\"56 &gt; 41 \u2192 search right half\"| C[\"[56, 73, 82, 93]&lt;br/&gt;Check middle: 73\"]\n    C --&gt;|\"56 &lt; 73 \u2192 search left half\"| D[\"[56]&lt;br/&gt;Found at index 5!\"]\n\n    style D fill:#4CAF50,color:#fff</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#prerequisites-and-rules","title":"Prerequisites and Rules","text":"Requirement Why Array MUST be sorted Binary search assumes sorted order to decide which half to check Duplicates are unreliable If duplicates exist, no guarantee which one is returned Elements must be comparable Different types in the same array will cause errors","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#return-values","title":"Return Values","text":"Return Value Meaning <code>&gt;= 0</code> Position of a match (but not necessarily the first match) <code>&lt; 0</code> (negative) Element was not found","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#code-example","title":"Code Example","text":"<pre><code>String[] arr = {\"Able\", \"Jane\", \"Mark\", \"Ralph\", \"David\"};\n\n// MUST sort before binary search!\nArrays.sort(arr);\nSystem.out.println(Arrays.toString(arr));\n// Output: [Able, David, Jane, Mark, Ralph]\n\nif (Arrays.binarySearch(arr, \"David\") &gt;= 0) {\n    System.out.println(\"David is in the array\");\n}\n// Output: David is in the array\n</code></pre> <p>Unsorted Array + Binary Search = Unreliable Results</p> <p>If you forget to sort, <code>binarySearch</code> may return incorrect results or miss elements entirely. Always sort first.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#8-sorting-challenge-descending-order-bubble-sort","title":"8. Sorting Challenge: Descending Order (Bubble Sort)","text":"<p><code>Arrays.sort()</code> only sorts in ascending order. To sort descending, the course implements a manual bubble sort algorithm.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#the-algorithm","title":"The Algorithm","text":"<p>Bubble sort works by repeatedly comparing adjacent elements and swapping them if they're in the wrong order. The process repeats until no more swaps are needed.</p> <pre><code>flowchart TD\n    A[\"Start: [7, 30, 35]\"] --&gt; B[\"Compare 7 &lt; 30? YES \u2192 swap\"]\n    B --&gt; C[\"[30, 7, 35]\"]\n    C --&gt; D[\"Compare 7 &lt; 35? YES \u2192 swap\"]\n    D --&gt; E[\"[30, 35, 7]\"]\n    E --&gt; F[\"Pass complete. Swaps occurred \u2192 repeat\"]\n    F --&gt; G[\"Compare 30 &lt; 35? YES \u2192 swap\"]\n    G --&gt; H[\"[35, 30, 7]\"]\n    H --&gt; I[\"Compare 30 &lt; 7? NO \u2192 skip\"]\n    I --&gt; J[\"Pass complete. Swaps occurred \u2192 repeat\"]\n    J --&gt; K[\"Compare 35 &lt; 30? NO \u2192 skip\"]\n    K --&gt; L[\"Compare 30 &lt; 7? NO \u2192 skip\"]\n    L --&gt; M[\"Pass complete. No swaps \u2192 DONE\"]\n\n    style M fill:#4CAF50,color:#fff</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#full-implementation","title":"Full Implementation","text":"<pre><code>public static int[] sortIntegers(int[] array) {\n    System.out.println(Arrays.toString(array));\n    int[] sortedArray = Arrays.copyOf(array, array.length);\n    boolean flag = true;\n    int temp;\n    while (flag) {\n        flag = false;\n        for (int i = 0; i &lt; sortedArray.length - 1; i++) {\n            if (sortedArray[i] &lt; sortedArray[i + 1]) {\n                temp = sortedArray[i];\n                sortedArray[i] = sortedArray[i + 1];\n                sortedArray[i + 1] = temp;\n                flag = true;\n                System.out.println(\"-----&gt;\" + Arrays.toString(sortedArray));\n            }\n        }\n        System.out.println(\"---&gt;\" + Arrays.toString(sortedArray));\n    }\n    return sortedArray;\n}\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#key-points","title":"Key Points","text":"<ul> <li><code>flag</code> controls the <code>while</code> loop: set to <code>false</code> at the start of each pass, flipped to <code>true</code> on any swap</li> <li><code>length - 1</code> in the <code>for</code> condition: because we compare <code>[i]</code> with <code>[i+1]</code>, we stop one element early to avoid <code>ArrayIndexOutOfBoundsException</code></li> <li><code>temp</code> variable for swapping: you can't directly swap two values without losing one \u2014 store it temporarily first</li> <li>Copy first: <code>Arrays.copyOf()</code> ensures the original array is not mutated</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#9-common-pitfalls-and-best-practices","title":"9. Common Pitfalls and Best Practices","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#pitfall-1-array-index-out-of-bounds","title":"Pitfall 1: Array Index Out of Bounds","text":"<pre><code>int[] myArray = {10, 35, 20, 17, 18};  // 5 elements, index 0-4\n\nmyArray[5] = 55;   // ArrayIndexOutOfBoundsException!\nmyArray[-1] = 10;  // ArrayIndexOutOfBoundsException!\n</code></pre> <p>Remember</p> <p>Valid indices are <code>0</code> to <code>length - 1</code>. Index 5 on a 5-element array does not exist.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#pitfall-2-starting-loop-at-1-instead-of-0","title":"Pitfall 2: Starting Loop at 1 Instead of 0","text":"<pre><code>// BUG: Skips the first element!\nfor (int i = 1; i &lt; myArray.length; i++) {\n    System.out.println(myArray[i]);\n}\n// Output: 35, 20, 17, 18  \u2190 Missing 10!\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#pitfall-3-using-instead-of","title":"Pitfall 3: Using <code>&lt;=</code> Instead of <code>&lt;</code>","text":"<pre><code>// BUG: Causes ArrayIndexOutOfBoundsException on last iteration!\nfor (int i = 0; i &lt;= myArray.length; i++) {\n    System.out.println(myArray[i]);\n}\n// When i == 5: myArray[5] \u2192 CRASH!\n</code></pre> <p>Fix: Always use <code>&lt;</code> with <code>.length</code>:</p> <pre><code>for (int i = 0; i &lt; myArray.length; i++) { ... }\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#best-practices-summary","title":"Best Practices Summary","text":"Practice Reason Use <code>&lt;</code> not <code>&lt;=</code> with <code>.length</code> Avoids off-by-one errors Start loops at <code>i = 0</code> Arrays are zero-indexed Prefer <code>for-each</code> for reading Less error-prone, no index management Use <code>for-each</code> from first to last when not modifying Cleaner, more readable Use traditional <code>for</code> only when setting/swapping Need index access for modifications","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#10-reference-vs-value-types-arrays-in-memory","title":"10. Reference vs Value Types \u2014 Arrays in Memory","text":"<p>This is one of the most important concepts to understand about arrays.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#arrays-are-reference-types","title":"Arrays Are Reference Types","text":"<p>When you assign an array to a variable, the variable holds a reference (address) to the array object in memory, not the array data itself.</p> <pre><code>int[] myIntArray = new int[5];\nint[] anotherArray = myIntArray;  // Copies the REFERENCE, not the array!\n</code></pre> <pre><code>flowchart LR\n    subgraph stack[\" STACK \"]\n        REF1[\"myIntArray&lt;br/&gt;(reference)\"]\n        REF2[\"anotherArray&lt;br/&gt;(reference)\"]\n    end\n\n    subgraph heap[\" HEAP \"]\n        ARR[\"Array Object&lt;br/&gt;[0, 0, 0, 0, 0]\"]\n    end\n\n    REF1 --&gt; ARR\n    REF2 --&gt; ARR</code></pre> <p>Both variables point to the same array in memory. Changes through one reference are visible through the other:</p> <pre><code>int[] myIntArray = new int[5];\nint[] anotherArray = myIntArray;\n\nSystem.out.println(\"myIntArray = \" + Arrays.toString(myIntArray));\n// Output: myIntArray = [0, 0, 0, 0, 0]\n\nanotherArray[0] = 1;\n\nSystem.out.println(\"after change myIntArray = \" + Arrays.toString(myIntArray));\n// Output: after change myIntArray = [1, 0, 0, 0, 0]  \u2190 Changed!\n\nSystem.out.println(\"after change anotherArray = \" + Arrays.toString(anotherArray));\n// Output: after change anotherArray = [1, 0, 0, 0, 0]\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#passing-arrays-to-methods","title":"Passing Arrays to Methods","text":"<p>When you pass an array to a method, Java copies the reference (the address), not the array. This means the method can modify the original array:</p> <pre><code>private static void modifyArray(int[] array) {\n    array[1] = 2;  // Modifies the ORIGINAL array!\n}\n\npublic static void main(String[] args) {\n    int[] myIntArray = new int[5];\n    int[] anotherArray = myIntArray;\n\n    anotherArray[0] = 1;\n    modifyArray(myIntArray);  // Three references now: myIntArray, anotherArray, array (parameter)\n\n    System.out.println(\"after change myIntArray = \" + Arrays.toString(myIntArray));\n    // Output: after change myIntArray = [1, 2, 0, 0, 0]\n    System.out.println(\"after change anotherArray = \" + Arrays.toString(anotherArray));\n    // Output: after change anotherArray = [1, 2, 0, 0, 0]\n}\n</code></pre> <pre><code>flowchart LR\n    subgraph main[\" main() method \"]\n        R1[\"myIntArray\"]\n        R2[\"anotherArray\"]\n    end\n\n    subgraph method[\" modifyArray() \"]\n        R3[\"array (parameter)\"]\n    end\n\n    subgraph heap[\" HEAP \"]\n        ARR[\"Array Object&lt;br/&gt;[1, 2, 0, 0, 0]\"]\n    end\n\n    R1 --&gt; ARR\n    R2 --&gt; ARR\n    R3 --&gt; ARR</code></pre> <p>Word of Caution</p> <p>If you don't want a method to modify your array, pass a copy using <code>Arrays.copyOf()</code>:</p> <pre><code>modifyArray(Arrays.copyOf(myIntArray, myIntArray.length));\n// Original myIntArray remains unchanged\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#the-new-keyword-new-object","title":"The <code>new</code> Keyword = New Object","text":"<p>One way to know if you have a reference type: the <code>new</code> keyword creates a new object in memory.</p> <ul> <li><code>int[] arr = new int[5]</code> \u2192 new array object on the heap</li> <li><code>int[] arr2 = arr</code> \u2192 no <code>new</code>, just copies the reference</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#11-variable-arguments-varargs","title":"11. Variable Arguments (Varargs)","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#what-is-varargs","title":"What Is Varargs?","text":"<p>Varargs lets a method accept zero, one, or many arguments of the same type. Java automatically wraps them into an array.</p> <pre><code>// Array parameter version\nprivate static void printText(String[] textList) { ... }\n\n// Varargs version (replace [] with ...)\nprivate static void printText(String... textList) { ... }\n</code></pre> <p>Inside the method, <code>textList</code> is treated as a <code>String[]</code> \u2014 the code is identical. The difference is in how callers invoke the method:</p> <pre><code>// All of these work with varargs:\nprintText(splitStrings);                     // Pass an array\nprintText(\"hello\");                          // Pass a single string\nprintText(\"hello\", \"world\", \"again\");        // Pass multiple strings\nprintText();                                 // Pass nothing (empty array)\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#varargs-rules","title":"Varargs Rules","text":"Rule Detail Only one varargs parameter per method <code>void foo(int... a, int... b)</code> is illegal Must be the last parameter <code>void foo(int... a, String s)</code> is illegal Can be combined with other params <code>void foo(String delimiter, String... values)</code> is valid","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#stringsplit-and-stringjoin","title":"<code>String.split()</code> and <code>String.join()</code>","text":"<p>The split method breaks a string into a <code>String[]</code> by a delimiter:</p> <pre><code>String[] splitStrings = \"Hello World Again\".split(\" \");\n// splitStrings \u2192 [\"Hello\", \"World\", \"Again\"]\n</code></pre> <p>The join method (which uses varargs) does the opposite:</p> <pre><code>String[] sArray = {\"Tim\", \"Jan\", \"Ken\", \"Amy\", \"Bob\"};\nSystem.out.println(String.join(\",\", sArray));\n// Output: Tim,Jan,Ken,Amy,Bob\n</code></pre> <p>Why Delimiter Is First in <code>String.join()</code></p> <p>Because <code>join</code> uses varargs for the second parameter, and varargs must be the last argument, the delimiter has to come first.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#the-main-method-uses-varargs","title":"The <code>main</code> Method Uses Varargs","text":"<p>The main method signature can use either form\u2014they are equivalent:</p> <pre><code>public static void main(String[] args) { ... }   // Array form\npublic static void main(String... args) { ... }   // Varargs form\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#12-challenges","title":"12. Challenges","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#challenge-1-minimum-element","title":"Challenge 1: Minimum Element","text":"<p>Goal: Read comma-separated integers from the user, find the minimum value.</p> <pre><code>private static int[] readIntegers() {\n    Scanner scanner = new Scanner(System.in);\n    System.out.println(\"Enter a list of integers separated by commas:\");\n    String input = scanner.nextLine();\n\n    String[] splits = input.split(\",\");\n    int[] values = new int[splits.length];\n\n    for (int i = 0; i &lt; splits.length; i++) {\n        values[i] = Integer.parseInt(splits[i].trim());\n    }\n    return values;\n}\n\nprivate static int findMinimum(int[] array) {\n    int min = Integer.MAX_VALUE;\n    for (int i : array) {\n        if (i &lt; min) {\n            min = i;\n        }\n    }\n    return min;\n}\n</code></pre> <p>Key Technique: Initialize <code>min</code> to <code>Integer.MAX_VALUE</code> so the first comparison always sets it to the first element's value. Alternatively, set <code>min = array[0]</code> and loop from index 1.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#challenge-2-reverse-array-in-place-mutating","title":"Challenge 2: Reverse Array In-Place (Mutating)","text":"<p>Goal: Reverse element order by swapping from the outside in.</p> <pre><code>private static void reverse(int[] array) {\n    int maxIndex = array.length - 1;\n    int halfLength = array.length / 2;\n    for (int i = 0; i &lt; halfLength; i++) {\n        int temp = array[i];\n        array[i] = array[maxIndex - i];\n        array[maxIndex - i] = temp;\n    }\n}\n</code></pre> <pre><code>flowchart LR\n    subgraph before[\" BEFORE \"]\n        B0[\"[0]=5\"] --- B1[\"[1]=4\"] --- B2[\"[2]=3\"] --- B3[\"[3]=2\"] --- B4[\"[4]=1\"]\n    end\n\n    subgraph iter1[\" ITER 1: swap [0] \u2194 [4] \"]\n        A0[\"[0]=1\"] --- A1[\"[1]=4\"] --- A2[\"[2]=3\"] --- A3[\"[3]=2\"] --- A4[\"[4]=5\"]\n    end\n\n    subgraph iter2[\" ITER 2: swap [1] \u2194 [3] \"]\n        C0[\"[0]=1\"] --- C1[\"[1]=2\"] --- C2[\"[2]=3\"] --- C3[\"[3]=4\"] --- C4[\"[4]=5\"]\n    end\n\n    before --&gt; iter1 --&gt; iter2</code></pre> <ul> <li>Loop runs only <code>length / 2</code> times (integer division automatically skips the middle on odd-length arrays)</li> <li>This is a mutating method \u2014 it modifies the original array</li> </ul>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#challenge-3-reverse-copy-non-mutating","title":"Challenge 3: Reverse Copy (Non-Mutating)","text":"<p>Goal: Same result, but returns a new array without modifying the original.</p> <pre><code>private static int[] reverseCopy(int[] array) {\n    int[] reversedArray = new int[array.length];\n    int maxIndex = array.length - 1;\n    for (int el : array) {\n        reversedArray[maxIndex--] = el;  // Post-decrement!\n    }\n    return reversedArray;\n}\n</code></pre> <p>Key Technique: The post-decrement (<code>maxIndex--</code>) uses the current value of <code>maxIndex</code> for the assignment, then decrements it. This populates the new array from last index to first.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#13-two-dimensional-arrays","title":"13. Two-Dimensional Arrays","text":"<p>A 2D array is an array of arrays \u2014 think of it as a table with rows and columns.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#declaration-and-initialization","title":"Declaration and Initialization","text":"<pre><code>// Uniform 4\u00d74 matrix (all nested arrays have 4 elements)\nint[][] array2 = new int[4][4];\n\n// Array initializer (2\u00d73 matrix)\nint[][] matrix = {\n    {1, 2, 3},\n    {4, 5, 6}\n};\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#traversing-with-nested-loops","title":"Traversing with Nested Loops","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#traditional-for-loops","title":"Traditional <code>for</code> Loops","text":"<pre><code>for (int i = 0; i &lt; myArray.length; i++) {\n    var innerArrayLength = myArray[i].length;\n    for (int j = 0; j &lt; innerArrayLength; j++) {\n        myArray[i][j] = (i * 10) + (j + 1);\n    }\n}\n</code></pre> <p>This produces:</p> Col 0 Col 1 Col 2 Col 3 Row 0 1 2 3 4 Row 1 11 12 13 14 Row 2 21 22 23 24 Row 3 31 32 33 34","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#enhanced-for-each-loops","title":"Enhanced <code>for-each</code> Loops","text":"<pre><code>for (var outer : myArray) {\n    for (var element : outer) {\n        System.out.print(element + \" \");\n    }\n    System.out.println();\n}\n</code></pre> <p>Use <code>var</code> for Readability</p> <p>In nested for-each loops, <code>var</code> lets Java infer the type (<code>int[]</code> for outer, <code>int</code> for inner), keeping the code clean.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#accessing-2d-elements","title":"Accessing 2D Elements","text":"<pre><code>// One-dimensional: one index\narray[0] = 50;\n\n// Two-dimensional: two indices\narray2[0][0] = 50;   // First element of first array\narray2[1][1] = 10;   // Second element of second array\n</code></pre> <pre><code>flowchart TB\n    subgraph outer[\" array2 (outer) \"]\n        direction TB\n        R0[\"[0] \u2192 int array\"]\n        R1[\"[1] \u2192 int array\"]\n        R2[\"[2] \u2192 int array\"]\n        R3[\"[3] \u2192 int array\"]\n    end\n\n    subgraph inner0[\" array2 at 0 \"]\n        E00[\"[0][0]\"] --- E01[\"[0][1]\"] --- E02[\"[0][2]\"] --- E03[\"[0][3]\"]\n    end\n\n    subgraph inner1[\" array2 at 1 \"]\n        E10[\"[1][0]\"] --- E11[\"[1][1]\"] --- E12[\"[1][2]\"] --- E13[\"[1][3]\"]\n    end\n\n    R0 --&gt; inner0\n    R1 --&gt; inner1</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#printing-with-arraysdeeptostring","title":"Printing with <code>Arrays.deepToString()</code>","text":"<pre><code>System.out.println(Arrays.deepToString(myArray));\n// Output: [[1, 2, 3, 4], [11, 12, 13, 14], [21, 22, 23, 24], [31, 32, 33, 34]]\n</code></pre> <p>Regular <code>Arrays.toString()</code> on a 2D array prints the inner array references (hex), not the actual values. Always use <code>deepToString()</code> for multi-dimensional arrays.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#14-multi-dimensional-and-jagged-arrays","title":"14. Multi-Dimensional and Jagged Arrays","text":"","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#jagged-arrays-different-sized-rows","title":"Jagged Arrays (Different-Sized Rows)","text":"<p>Java does not require nested arrays to be the same size:</p> <pre><code>int[][] jagged = {\n    {1, 2, 3},\n    {4, 5, 6, 7, 8},\n    {9}\n};\n</code></pre> <p>You can also reassign an element of the outer array to a differently-sized array:</p> <pre><code>int[][] array2 = new int[4][4];  // Starts as 4\u00d74\n\n// Replace second element with a 3-element array\narray2[1] = new int[]{10, 20, 30};\n\nSystem.out.println(Arrays.deepToString(array2));\n// Output: [[0, 0, 0, 0], [10, 20, 30], [0, 0, 0, 0], [0, 0, 0, 0]]\n</code></pre> <p>Anonymous Initializer Not Allowed Here</p> <p>You cannot use <code>array2[1] = {10, 20, 30};</code> \u2014 the anonymous initializer only works in declaration statements. You must use <code>new int[]{10, 20, 30}</code>.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#uninitialized-nested-arrays","title":"Uninitialized Nested Arrays","text":"<p>You can declare a 2D array without specifying the inner array sizes:</p> <pre><code>int[][] partial = new int[3][];  // 3 outer elements, each is null\n</code></pre> <p>Each element is <code>null</code> until you assign an <code>int[]</code> to it. This gives you full control over sizes.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#object-arrays-maximum-flexibility","title":"Object Arrays (Maximum Flexibility)","text":"<p>Using <code>Object[]</code>, you can hold any type \u2014 including arrays of different dimensions:</p> <pre><code>Object[] anyArray = new Object[3];\nSystem.out.println(Arrays.toString(anyArray));\n// Output: [null, null, null]\n\n// Element 0: a 1D string array\nanyArray[0] = new String[]{\"a\", \"b\", \"c\"};\n\n// Element 1: a 2D string array (jagged)\nanyArray[1] = new String[][]{\n    {\"1\", \"2\"},\n    {\"3\", \"4\", \"5\"},\n    {\"6\", \"7\", \"8\", \"9\"}\n};\n\n// Element 2: a 3D int array\nanyArray[2] = new int[2][2][2];\n\nSystem.out.println(Arrays.deepToString(anyArray));\n</code></pre>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#iterating-object-arrays","title":"Iterating Object Arrays","text":"<pre><code>for (Object element : anyArray) {\n    System.out.println(\"Element type: \" + element.getClass().getSimpleName());\n    System.out.println(\"Element toString() = \" + element);\n    System.out.println(Arrays.deepToString((Object[]) element));\n}\n</code></pre> <p>Output:</p> <pre><code>Element type: String[]\nElement type: String[][]\nElement type: int[][][]\n</code></pre> <p>Type Safety Warning</p> <p>Using <code>Object[]</code> provides no compile-time type checking. If you accidentally assign a non-array element (like a plain <code>String</code>), the cast to <code>Object[]</code> will throw a <code>ClassCastException</code> at runtime. Prefer strongly-typed arrays whenever possible.</p>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#common-pitfalls-summary","title":"Common Pitfalls Summary","text":"Pitfall Example Fix Off-by-one (access) <code>arr[arr.length]</code> <code>arr[arr.length - 1]</code> Off-by-one (loop) <code>i &lt;= arr.length</code> <code>i &lt; arr.length</code> Starting at 1 <code>for (int i = 1; ...)</code> <code>for (int i = 0; ...)</code> Printing array directly <code>println(arr)</code> <code>println(Arrays.toString(arr))</code> Binary search unsorted Search without <code>sort()</code> Always <code>sort()</code> first Shared reference mutation <code>arr2 = arr1; arr2[0] = 99;</code> <code>arr2 = Arrays.copyOf(arr1, ...)</code> Anonymous init outside declaration <code>arr = {1,2,3};</code> <code>arr = new int[]{1,2,3};</code> <code>toString()</code> on 2D array <code>Arrays.toString(matrix)</code> <code>Arrays.deepToString(matrix)</code>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Arrays are fixed-size \u2014 once created, you cannot add or remove elements. Use <code>ArrayList</code> (next section) if you need resizing.</li> <li>Arrays are objects \u2014 they live on the heap and variables hold references to them. Assigning an array to another variable does not copy it.</li> <li>Zero-indexed \u2014 first element is at <code>[0]</code>, last is at <code>[length - 1]</code>.</li> <li>Use <code>java.util.Arrays</code> \u2014 don't reinvent sorting, copying, or searching. The helper class has optimized, tested implementations.</li> <li>Enhanced for-each for reading, traditional for for writing \u2014 this simple rule prevents most loop-related bugs.</li> <li>Varargs = syntactic sugar for arrays \u2014 methods with <code>Type... args</code> accept arrays, single values, or nothing.</li> <li>2D arrays are arrays of arrays \u2014 each \"row\" can have a different length (jagged arrays).</li> </ol>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#quick-reference","title":"Quick Reference","text":"Concept Syntax Declare <code>int[] arr;</code> Instantiate <code>arr = new int[10];</code> Initialize <code>int[] arr = {1, 2, 3};</code> Access <code>arr[0]</code> Length <code>arr.length</code> Sort <code>Arrays.sort(arr);</code> Print <code>Arrays.toString(arr)</code> Copy <code>Arrays.copyOf(arr, arr.length)</code> Search <code>Arrays.binarySearch(arr, key)</code> Fill <code>Arrays.fill(arr, value)</code> Compare <code>Arrays.equals(arr1, arr2)</code> 2D Declare <code>int[][] matrix = new int[3][4];</code> 2D Print <code>Arrays.deepToString(matrix)</code> Varargs <code>void method(int... nums)</code>","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#related-notes","title":"Related Notes","text":"Part Topic Link 1 Arrays &amp; <code>java.util.Arrays</code> You are here 2 ArrayList \u2014 Java's Resizable Array Part 2 \u2192 3 LinkedList &amp; Iterators Part 3 \u2192 4 Autoboxing, Unboxing &amp; Enums Part 4 \u2192","tags":[]},{"location":"notes/phase-1/topic-3-arrays-lists-generics/topic-note/#references","title":"References","text":"<ul> <li>Course: Tim Buchalka - Java Programming Masterclass (Section 9)</li> <li>API: java.util.Arrays (Java 17)</li> <li>API: java.util.Random (Java 17)</li> </ul> <p>Last Updated: 2026-02-11 | Confidence: 9/10</p>","tags":[]},{"location":"notes/phase-1/topic-4-abstraction-generics/","title":"Topic 4: Abstraction, Interfaces, Generics &amp; Nested Classes","text":"<p>Mastering Java's abstraction mechanisms \u2014 from abstract classes and interfaces to generics, comparators, and nested class types.</p>"},{"location":"notes/phase-1/topic-4-abstraction-generics/#topic-structure","title":"Topic Structure","text":"Document Purpose Status  Topic Note Course notes from Tim Buchalka  To Do  Book Reading Effective Java insights  To Do  Summary Combined final understanding  To Do"},{"location":"notes/phase-1/topic-4-abstraction-generics/#what-youll-master","title":"What You'll Master","text":"<ul> <li>Abstract Classes \u2014 Abstract methods, concrete methods, when to use abstract vs interface</li> <li>Interfaces \u2014 Default methods, static methods, multiple inheritance of type</li> <li>Polymorphism (Advanced) \u2014 Expanding polymorphism with interfaces and hierarchies</li> <li>Java Generics \u2014 Type parameters, bounded types, wildcards (<code>?</code>, <code>? extends T</code>, <code>? super T</code>)</li> <li>Comparators \u2014 <code>Comparable</code> vs <code>Comparator</code>, sorting with custom logic</li> <li>Type Erasure \u2014 How generics work at runtime and its implications</li> <li>Nested Classes \u2014 Static nested classes, inner classes, local classes, anonymous classes</li> </ul>"},{"location":"notes/phase-1/topic-4-abstraction-generics/#resources","title":"Resources","text":""},{"location":"notes/phase-1/topic-4-abstraction-generics/#primary-course","title":"Primary Course","text":"<ul> <li>Tim Buchalka's Java Masterclass \u2014 Sections 11, 12 &amp; 13</li> </ul>"},{"location":"notes/phase-1/topic-4-abstraction-generics/#book-reference","title":"Book Reference","text":"<ul> <li>Effective Java by Joshua Bloch \u2014 Items 26\u201333 (Generics), Items 18\u201325 (Interfaces)</li> </ul>"},{"location":"notes/phase-1/topic-4-abstraction-generics/#course-sections-covered","title":"Course Sections Covered","text":"Section Title Section 11 Mastering Abstraction &amp; Interfaces \u2014 Expand Polymorphism &amp; Java Hierarchies Section 12 Deep Dive into Java Generics \u2014 Bounds, Comparators &amp; Advanced Techniques Section 13 Exploring Nested Classes, Local Types &amp; Anonymous Classes"},{"location":"notes/phase-1/topic-4-abstraction-generics/#key-internals-to-understand","title":"Key Internals to Understand","text":"<ul> <li>Difference between arrays (covariant) and generics (invariant)</li> <li>Type erasure mechanism and its implications</li> <li>Raw types vs parameterized types</li> <li>PECS principle (Producer Extends, Consumer Super)</li> <li>When to use abstract classes vs interfaces</li> <li>Nested class scope and access rules</li> </ul>"},{"location":"notes/phase-1/topic-4-abstraction-generics/#progress-tracker","title":"Progress Tracker","text":"<ul> <li> Complete Tim's course Section 11 (Abstraction &amp; Interfaces)</li> <li> Complete Tim's course Section 12 (Generics)</li> <li> Complete Tim's course Section 13 (Nested Classes)</li> <li> Write topic notes</li> <li> Read Effective Java related items</li> <li> Complete book reading notes</li> <li> Synthesize final summary</li> </ul> <p>Last Updated: 2026-02-11</p>"},{"location":"notes/phase-1/topic-4-abstraction-generics/book-reading/","title":"Book Reading: Abstraction, Interfaces, Generics &amp; Nested Classes","text":"<p>Book: Effective Java by Joshua Bloch Status:  To Do</p> <p>Notes will be added as reading progresses.</p>"},{"location":"notes/phase-1/topic-4-abstraction-generics/summary/","title":"Summary: Abstraction, Interfaces, Generics &amp; Nested Classes","text":"<p>Status:  To Do</p> <p>Summary will be synthesized after completing topic notes and book reading.</p>"},{"location":"notes/phase-1/topic-4-abstraction-generics/topic-note/","title":"Topic Note: Abstraction, Interfaces, Generics &amp; Nested Classes","text":"<p>Course: Java Programming Masterclass - Tim Buchalka (Udemy) Sections: 11, 12 &amp; 13 Status:  To Do</p> <p>Notes will be added as the course sections are completed.</p>"},{"location":"notes/phase-1/topic-5-lambdas-streams/","title":"Topic 4: Lambdas &amp; Streams","text":"<p>Embracing functional programming paradigm in Java with lambda expressions and the powerful Stream API.</p>"},{"location":"notes/phase-1/topic-5-lambdas-streams/#topic-structure","title":"Topic Structure","text":"Document Purpose Status  Topic Note Course notes from Tim Buchalka  In Progress  Book Reading Effective Java insights  In Progress  Summary Combined final understanding  To Do"},{"location":"notes/phase-1/topic-5-lambdas-streams/#what-youll-master","title":"What You'll Master","text":"<ul> <li>Lambda Expressions - Syntax, closures, and capturing variables</li> <li>Functional Interfaces - Predicate, Function, Consumer, Supplier</li> <li>Method References - Static, instance, constructor references</li> <li>Stream API - filter, map, reduce, collect operations</li> <li>Optional Class - Avoiding NullPointerException elegantly</li> <li>Parallel Streams - Leveraging multi-core processors</li> </ul>"},{"location":"notes/phase-1/topic-5-lambdas-streams/#resources","title":"Resources","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/#primary-course","title":"Primary Course","text":"<ul> <li>Tim Buchalka's Java Masterclass (Udemy)</li> </ul>"},{"location":"notes/phase-1/topic-5-lambdas-streams/#book-reference","title":"Book Reference","text":"<ul> <li>Effective Java by Joshua Bloch - Items 42-48 (Lambdas &amp; Streams)</li> <li>Modern Java in Action - Comprehensive coverage of Java 8+</li> </ul>"},{"location":"notes/phase-1/topic-5-lambdas-streams/#key-internals-to-understand","title":"Key Internals to Understand","text":"<ul> <li>How lambdas are compiled (invokedynamic)</li> <li>Stream lazy evaluation mechanism</li> <li>Short-circuit operations in streams</li> <li>Parallel streams and fork-join framework</li> </ul>"},{"location":"notes/phase-1/topic-5-lambdas-streams/#progress-tracker","title":"Progress Tracker","text":"<ul> <li> Complete Tim's course sections on Lambdas &amp; Streams</li> <li> Read Effective Java Items 42-48</li> <li> Write topic notes</li> <li> Complete book reading notes</li> <li> Synthesize final summary</li> <li> Refactor imperative code to functional style</li> </ul> <p>Start Date:  | Target Completion: </p>"},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/","title":"Book Reading: Lambdas &amp; Streams","text":"<p>Book: Effective Java by Joshua Bloch Relevant Items: 42-48 (Lambdas &amp; Streams) Status:  In Progress</p>"},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#reading-goals","title":"Reading Goals","text":"<ul> <li> Understand best practices for lambda usage</li> <li> Learn when streams are appropriate</li> <li> Master stream API design principles</li> <li> Avoid common functional programming pitfalls</li> </ul>"},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#chapter-notes-lambdas-and-streams","title":"Chapter Notes: Lambdas and Streams","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#item-42-prefer-lambdas-to-anonymous-classes","title":"Item 42: Prefer Lambdas to Anonymous Classes","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#key-takeaways","title":"Key Takeaways","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#when-anonymous-classes-are-still-needed","title":"When Anonymous Classes Are Still Needed","text":"<ul> <li>Creating instances of abstract classes</li> <li>Creating interfaces with multiple abstract methods</li> <li>Need access to <code>this</code> (the anonymous class instance)</li> </ul>"},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#item-43-prefer-method-references-to-lambdas","title":"Item 43: Prefer Method References to Lambdas","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#key-takeaways_1","title":"Key Takeaways","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#the-decision","title":"The Decision","text":"Method Reference Lambda <code>String::toLowerCase</code> <code>s -&gt; s.toLowerCase()</code> <code>System.out::println</code> <code>x -&gt; System.out.println(x)</code> <code>Integer::sum</code> <code>(a, b) -&gt; a + b</code>"},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#when-lambda-is-clearer","title":"When Lambda is Clearer","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#item-44-favor-the-use-of-standard-functional-interfaces","title":"Item 44: Favor the Use of Standard Functional Interfaces","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#key-takeaways_2","title":"Key Takeaways","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#the-core-six","title":"The Core Six","text":"Interface Function Signature Example <code>UnaryOperator&lt;T&gt;</code> <code>T apply(T t)</code> <code>String::toLowerCase</code> <code>BinaryOperator&lt;T&gt;</code> <code>T apply(T t1, T t2)</code> <code>BigInteger::add</code> <code>Predicate&lt;T&gt;</code> <code>boolean test(T t)</code> <code>Collection::isEmpty</code> <code>Function&lt;T,R&gt;</code> <code>R apply(T t)</code> <code>Arrays::asList</code> <code>Supplier&lt;T&gt;</code> <code>T get()</code> <code>Instant::now</code> <code>Consumer&lt;T&gt;</code> <code>void accept(T t)</code> <code>System.out::println</code>"},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#when-to-create-custom","title":"When to Create Custom","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#item-45-use-streams-judiciously","title":"Item 45: Use Streams Judiciously","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#key-takeaways_3","title":"Key Takeaways","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#overusing-streams","title":"Overusing Streams","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#ideal-stream-use-cases","title":"Ideal Stream Use Cases","text":"<ol> <li>Transform elements</li> <li>Filter elements</li> <li>Combine elements</li> <li>Collect into a collection</li> <li>Find an element</li> <li>Any/all match conditions</li> </ol>"},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#item-46-prefer-side-effect-free-functions-in-streams","title":"Item 46: Prefer Side-Effect-Free Functions in Streams","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#key-takeaways_4","title":"Key Takeaways","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#anti-pattern","title":"Anti-Pattern","text":"<pre><code>// Bad - mutating external state\nMap&lt;String, Long&gt; freq = new HashMap&lt;&gt;();\nwords.forEach(word -&gt; {\n    freq.merge(word.toLowerCase(), 1L, Long::sum);\n});\n\n// Good - pure function\nMap&lt;String, Long&gt; freq = words.stream()\n    .collect(groupingBy(String::toLowerCase, counting()));\n</code></pre>"},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#item-47-prefer-collection-to-stream-as-a-return-type","title":"Item 47: Prefer Collection to Stream as a Return Type","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#key-takeaways_5","title":"Key Takeaways","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#guidelines","title":"Guidelines","text":"<ul> <li>If client might need to iterate multiple times \u2192 Collection</li> <li>If result is very large or infinite \u2192 Stream</li> <li>If computation is expensive per element \u2192 Stream</li> </ul>"},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#item-48-use-caution-when-making-streams-parallel","title":"Item 48: Use Caution When Making Streams Parallel","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#key-takeaways_6","title":"Key Takeaways","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#good-candidates-for-parallelism","title":"Good Candidates for Parallelism","text":"<ul> <li>Large data sets</li> <li>CPU-intensive operations</li> <li>Splittable sources (ArrayList, arrays)</li> <li>Stateless, associative operations</li> </ul>"},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#bad-candidates","title":"Bad Candidates","text":"<ul> <li>Small data sets</li> <li>I/O-bound operations</li> <li>LinkedList, Stream.iterate()</li> <li>Stateful operations</li> <li>Ordering-dependent operations</li> </ul>"},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#theoretical-framework","title":"Theoretical Framework","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#mental-model-for-functional-programming","title":"Mental Model for Functional Programming","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#stream-pipeline-optimization","title":"Stream Pipeline Optimization","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#reflections-connections","title":"Reflections &amp; Connections","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#connections-to-course-material","title":"Connections to Course Material","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#new-perspectives-gained","title":"New Perspectives Gained","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#summary-points","title":"Summary Points","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/book-reading/#bookmarks-page-references","title":"Bookmarks &amp; Page References","text":"Topic Item Note Lambdas vs Anonymous Item 42 Method References Item 43 Standard Interfaces Item 44 Stream Judiciousness Item 45 Side-Effect-Free Item 46 Parallel Streams Item 48 <p>Last Updated: </p>"},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/","title":"Summary: Lambdas &amp; Streams","text":"<p>Combined Knowledge from: Tim Buchalka's Course + Effective Java Mastery Level: </p>"},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#topic-overview","title":"Topic Overview","text":"<p>Embracing functional programming in Java through lambda expressions, the Stream API, and understanding when and how to apply these powerful features effectively.</p>"},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#core-concepts","title":"Core Concepts","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#1-lambda-expressions","title":"1. Lambda Expressions","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#syntax-variations","title":"Syntax Variations","text":"<pre><code>// Full syntax\n(Type param1, Type param2) -&gt; { return expression; }\n\n// Inferred types\n(param1, param2) -&gt; expression\n\n// Single parameter\nparam -&gt; expression\n\n// No parameters\n() -&gt; expression\n</code></pre>"},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#key-characteristics","title":"Key Characteristics","text":"<ul> <li>Target typing - Lambda type is inferred from context</li> <li>Effectively final - Captured variables must be effectively final</li> <li>No <code>this</code> reference - <code>this</code> refers to enclosing class</li> </ul>"},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#under-the-hood","title":"Under the Hood","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#2-functional-interfaces","title":"2. Functional Interfaces","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#the-standard-six-variants","title":"The Standard Six (+ Variants)","text":"<pre><code>// Predicate - Test a condition\nPredicate&lt;String&gt; isEmpty = String::isEmpty;\n\n// Function - Transform input\nFunction&lt;String, Integer&gt; length = String::length;\n\n// Consumer - Accept input, no return\nConsumer&lt;String&gt; printer = System.out::println;\n\n// Supplier - Supply a value\nSupplier&lt;Double&gt; random = Math::random;\n\n// UnaryOperator - Same input/output type\nUnaryOperator&lt;String&gt; upper = String::toUpperCase;\n\n// BinaryOperator - Combine two values\nBinaryOperator&lt;Integer&gt; sum = Integer::sum;\n</code></pre>"},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#primitive-specializations","title":"Primitive Specializations","text":"<ul> <li><code>IntPredicate</code>, <code>LongFunction&lt;R&gt;</code>, <code>DoubleConsumer</code></li> <li>Avoid autoboxing overhead</li> </ul>"},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#3-method-references","title":"3. Method References","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#types-and-when-to-use","title":"Types and When to Use","text":"Type Example Use When Static <code>Integer::parseInt</code> Calling static method Bound instance <code>myStr::length</code> Calling on specific object Unbound instance <code>String::length</code> First param is receiver Constructor <code>ArrayList::new</code> Creating new instances"},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#decision-lambda-vs-method-reference","title":"Decision: Lambda vs Method Reference","text":"<pre><code>// Method reference is clearer\nlist.forEach(System.out::println);\n\n// Lambda might be clearer for complex logic\nlist.stream()\n    .map(x -&gt; x.getFirstName() + \" \" + x.getLastName())\n</code></pre>"},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#4-stream-api-mastery","title":"4. Stream API Mastery","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#stream-pipeline-structure","title":"Stream Pipeline Structure","text":"<pre><code>Source \u2192 Intermediate Operations (0+) \u2192 Terminal Operation (1)\n</code></pre>"},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#intermediate-operations-lazy","title":"Intermediate Operations (Lazy)","text":"Operation Description Example <code>filter</code> Keep matching elements <code>.filter(x -&gt; x &gt; 0)</code> <code>map</code> Transform elements <code>.map(String::toUpperCase)</code> <code>flatMap</code> One-to-many transform <code>.flatMap(Collection::stream)</code> <code>distinct</code> Remove duplicates <code>.distinct()</code> <code>sorted</code> Sort elements <code>.sorted(Comparator.reverseOrder())</code> <code>limit</code> Take first n <code>.limit(10)</code> <code>skip</code> Skip first n <code>.skip(5)</code> <code>peek</code> Debug/side-effects <code>.peek(System.out::println)</code>"},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#terminal-operations","title":"Terminal Operations","text":"Operation Returns Description <code>collect</code> Collection/other Gather results <code>forEach</code> void Execute action <code>reduce</code> Optional/value Combine all elements <code>count</code> long Count elements <code>anyMatch</code> boolean Any element matches? <code>allMatch</code> boolean All elements match? <code>findFirst</code> Optional First element <code>findAny</code> Optional Any element (parallel)"},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#common-collectors","title":"Common Collectors","text":"<pre><code>Collectors.toList()\nCollectors.toSet()\nCollectors.toMap(keyMapper, valueMapper)\nCollectors.groupingBy(classifier)\nCollectors.partitioningBy(predicate)\nCollectors.joining(delimiter)\nCollectors.counting()\nCollectors.summarizingInt(mapper)\n</code></pre>"},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#5-optional","title":"5. Optional","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#best-practices","title":"Best Practices","text":"<pre><code>// Creating\nOptional&lt;String&gt; opt = Optional.ofNullable(nullable);\n\n// Using safely\nopt.orElse(\"default\")\nopt.orElseGet(() -&gt; computeDefault())\nopt.orElseThrow(() -&gt; new IllegalStateException())\n\n// Transforming\nopt.map(String::toUpperCase)\n   .filter(s -&gt; s.length() &gt; 5)\n   .ifPresent(System.out::println);\n</code></pre>"},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#anti-patterns-to-avoid","title":"Anti-Patterns to Avoid","text":"<ul> <li><code>opt.get()</code> without checking</li> <li>Using Optional for fields</li> <li>Wrapping collections in Optional</li> </ul>"},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#key-internals","title":"Key Internals","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#lazy-evaluation","title":"Lazy Evaluation","text":"<ul> <li>Intermediate operations don't execute until terminal operation</li> <li>Enables short-circuiting (<code>findFirst</code>, <code>anyMatch</code>)</li> <li>Processing happens element-by-element, not operation-by-operation</li> </ul>"},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#parallel-stream-considerations","title":"Parallel Stream Considerations","text":"Good For Bad For Large datasets Small datasets CPU-intensive ops I/O-bound ops ArrayList, arrays LinkedList, iterate() Stateless operations Stateful operations"},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Overusing streams</li> <li> <p>Not every loop should become a stream</p> </li> <li> <p>Side effects in stream operations</p> </li> <li> <p>Keep operations pure</p> </li> <li> <p>Parallel stream misuse</p> </li> <li> <p>Often slower for small data</p> </li> <li> <p>Reusing streams</p> </li> <li> <p>Streams can only be consumed once</p> </li> <li> <p>Ignoring Optional</p> </li> <li>Using null handling instead</li> </ol>"},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#best-practices-checklist","title":"Best Practices Checklist","text":"<ul> <li> Prefer method references when clearer</li> <li> Use standard functional interfaces</li> <li> Keep stream operations side-effect-free</li> <li> Limit stream pipeline length for readability</li> <li> Consider Collection return types for APIs</li> <li> Benchmark before using parallel streams</li> </ul>"},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#related-topics","title":"Related Topics","text":"<ul> <li>OOP &amp; Class Design</li> <li>Arrays, Lists &amp; Generics</li> <li>Collections Framework</li> </ul>"},{"location":"notes/phase-1/topic-5-lambdas-streams/summary/#references","title":"References","text":"<ul> <li>Course: Tim Buchalka - Java Programming Masterclass</li> <li>Book: Effective Java - Joshua Bloch (Items 42-48)</li> <li>Book: Modern Java in Action - Urma, Fusco, Mycroft</li> </ul> <p>Completed:  | Confidence: X/10</p>"},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/","title":"Topic Note: Lambdas &amp; Streams","text":"<p>Course: Java Programming Masterclass - Tim Buchalka (Udemy) Status:  In Progress</p>"},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#learning-objectives","title":"Learning Objectives","text":"<ul> <li> Master lambda expression syntax</li> <li> Understand functional interfaces</li> <li> Apply Stream API for data processing</li> <li> Use Optional to handle null safely</li> </ul>"},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#key-concepts-from-the-course","title":"Key Concepts from the Course","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#lambda-expressions","title":"Lambda Expressions","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#lambda-syntax","title":"Lambda Syntax","text":"<pre><code>// Full syntax\n(parameters) -&gt; { statements; }\n\n// Single expression (no braces needed)\n(parameters) -&gt; expression\n\n// Single parameter (no parentheses needed)\nparameter -&gt; expression\n\n// Examples\n(a, b) -&gt; a + b\nx -&gt; x * x\n() -&gt; System.out.println(\"Hello\")\n(String s) -&gt; s.length()\n</code></pre>"},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#capturing-variables","title":"Capturing Variables","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#comparison-anonymous-class-vs-lambda","title":"Comparison: Anonymous Class vs Lambda","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#functional-interfaces","title":"Functional Interfaces","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#core-functional-interfaces","title":"Core Functional Interfaces","text":"Interface Abstract Method Description <code>Predicate&lt;T&gt;</code> <code>test(T t)</code> \u2192 boolean Test a condition <code>Function&lt;T, R&gt;</code> <code>apply(T t)</code> \u2192 R Transform input to output <code>Consumer&lt;T&gt;</code> <code>accept(T t)</code> \u2192 void Consume input, no return <code>Supplier&lt;T&gt;</code> <code>get()</code> \u2192 T Supply a value <code>UnaryOperator&lt;T&gt;</code> <code>apply(T t)</code> \u2192 T Transform same type <code>BinaryOperator&lt;T&gt;</code> <code>apply(T t1, T t2)</code> \u2192 T Combine two values <code>BiFunction&lt;T, U, R&gt;</code> <code>apply(T t, U u)</code> \u2192 R Two inputs, one output"},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#functionalinterface-annotation","title":"@FunctionalInterface Annotation","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#method-references","title":"Method References","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#types-of-method-references","title":"Types of Method References","text":"Type Syntax Lambda Equivalent Static <code>ClassName::staticMethod</code> <code>x -&gt; ClassName.staticMethod(x)</code> Instance (bound) <code>object::instanceMethod</code> <code>x -&gt; object.instanceMethod(x)</code> Instance (unbound) <code>ClassName::instanceMethod</code> <code>(obj, x) -&gt; obj.instanceMethod(x)</code> Constructor <code>ClassName::new</code> <code>x -&gt; new ClassName(x)</code>"},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#examples","title":"Examples","text":"<pre><code>// Static method reference\nlist.forEach(System.out::println);\n\n// Instance method reference\nString::toLowerCase  // unbound\nmyString::toUpperCase  // bound\n\n// Constructor reference\nArrayList::new\n</code></pre>"},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#stream-api","title":"Stream API","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#creating-streams","title":"Creating Streams","text":"<pre><code>// From collection\ncollection.stream()\n\n// From array\nArrays.stream(array)\n\n// From values\nStream.of(1, 2, 3)\n\n// Generate/iterate\nStream.generate(() -&gt; \"element\")\nStream.iterate(0, n -&gt; n + 1)\n</code></pre>"},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#intermediate-operations-lazy","title":"Intermediate Operations (Lazy)","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#terminal-operations-execute-pipeline","title":"Terminal Operations (Execute Pipeline)","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#stream-pipeline-pattern","title":"Stream Pipeline Pattern","text":"<pre><code>collection.stream()\n    .filter(/* predicate */)\n    .map(/* function */)\n    .sorted(/* comparator */)\n    .collect(Collectors.toList());\n</code></pre>"},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#optional-class","title":"Optional Class","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#creating-optionals","title":"Creating Optionals","text":"<pre><code>Optional.of(value)          // Non-null value\nOptional.ofNullable(value)  // Nullable value\nOptional.empty()            // Empty optional\n</code></pre>"},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#using-optionals","title":"Using Optionals","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#parallel-streams","title":"Parallel Streams","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#when-to-use","title":"When to Use","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#caution-areas","title":"Caution Areas","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#observed-ideas-insights","title":"Observed Ideas &amp; Insights","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#declarative-vs-imperative","title":"Declarative vs Imperative","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#pipeline-thinking","title":"Pipeline Thinking","text":""},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#code-snippets-examples","title":"Code Snippets &amp; Examples","text":"<pre><code>// Example: Transform and filter a list\nList&lt;String&gt; result = names.stream()\n    .filter(name -&gt; name.length() &gt; 3)\n    .map(String::toUpperCase)\n    .sorted()\n    .collect(Collectors.toList());\n</code></pre>"},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#questions-to-explore","title":"Questions to Explore","text":"<ul> <li> How does lazy evaluation work internally?</li> <li> When does parallel stream hurt performance?</li> <li> </li> </ul>"},{"location":"notes/phase-1/topic-5-lambdas-streams/topic-note/#quick-reference","title":"Quick Reference","text":"Concept Key Point Lambda Anonymous function, single abstract method Stream Pipeline of operations on data Intermediate Lazy, returns Stream Terminal Executes pipeline, returns result Optional Container for nullable values <p>Last Updated: </p>"},{"location":"notes/phase-1/topic-6-collections-framework/","title":"Topic 5: Collections Framework","text":"<p>Deep dive into Java's Collections Framework - the backbone of data structure handling in Java applications.</p>"},{"location":"notes/phase-1/topic-6-collections-framework/#topic-structure","title":"Topic Structure","text":"Document Purpose Status  Topic Note Course notes from Tim Buchalka  In Progress  Book Reading Effective Java insights  In Progress  Summary Combined final understanding  To Do"},{"location":"notes/phase-1/topic-6-collections-framework/#what-youll-master","title":"What You'll Master","text":"<ul> <li>List Implementations - ArrayList, LinkedList, Vector</li> <li>Set Implementations - HashSet, LinkedHashSet, TreeSet</li> <li>Map Implementations - HashMap, LinkedHashMap, TreeMap, ConcurrentHashMap</li> <li>Queue &amp; Deque - PriorityQueue, ArrayDeque</li> <li>Collection Algorithms - Sorting, searching, shuffling</li> <li>Internal Implementations - Hash tables, Red-Black trees</li> </ul>"},{"location":"notes/phase-1/topic-6-collections-framework/#resources","title":"Resources","text":""},{"location":"notes/phase-1/topic-6-collections-framework/#primary-course","title":"Primary Course","text":"<ul> <li>Tim Buchalka's Java Masterclass (Udemy)</li> </ul>"},{"location":"notes/phase-1/topic-6-collections-framework/#book-reference","title":"Book Reference","text":"<ul> <li>Effective Java by Joshua Bloch - Items on Collections</li> <li>Core Java Volume I by Cay S. Horstmann - Collections Chapter</li> </ul>"},{"location":"notes/phase-1/topic-6-collections-framework/#key-internals-to-understand","title":"Key Internals to Understand","text":"<ul> <li>HashMap internal implementation (hash function, buckets, collision resolution)</li> <li>ArrayList vs LinkedList performance characteristics</li> <li>How TreeMap maintains sorted order (Red-Black tree)</li> <li>ConcurrentHashMap lock striping technique</li> </ul>"},{"location":"notes/phase-1/topic-6-collections-framework/#progress-tracker","title":"Progress Tracker","text":"<ul> <li> Complete Tim's course sections on Collections</li> <li> Read Effective Java collection items</li> <li> Write topic notes</li> <li> Complete book reading notes</li> <li> Synthesize final summary</li> <li> Implement custom collection use cases</li> </ul> <p>Start Date:  | Target Completion: </p>"},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/","title":"Book Reading: Collections Framework","text":"<p>Book: Effective Java by Joshua Bloch Relevant Items: Items on Collections, plus Core Java Volume I Status:  In Progress</p>"},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#reading-goals","title":"Reading Goals","text":"<ul> <li> Understand collection interface design principles</li> <li> Learn best practices for using collections</li> <li> Master proper equals/hashCode for collection usage</li> <li> Understand concurrent collection patterns</li> </ul>"},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#effective-java-collection-items","title":"Effective Java: Collection Items","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#item-54-return-empty-collections-or-arrays-not-nulls","title":"Item 54: Return Empty Collections or Arrays, Not Nulls","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#key-takeaways","title":"Key Takeaways","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#best-practice","title":"Best Practice","text":"<pre><code>// Bad\npublic List&lt;Cheese&gt; getCheeses() {\n    return cheesesInStock.isEmpty() ? null : new ArrayList&lt;&gt;(cheesesInStock);\n}\n\n// Good\npublic List&lt;Cheese&gt; getCheeses() {\n    return cheesesInStock.isEmpty() \n        ? Collections.emptyList() \n        : new ArrayList&lt;&gt;(cheesesInStock);\n}\n</code></pre>"},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#item-55-return-optionals-judiciously","title":"Item 55: Return Optionals Judiciously","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#key-takeaways_1","title":"Key Takeaways","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#item-52-use-overloading-judiciously","title":"Item 52: Use Overloading Judiciously","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#key-takeaways-collection-context","title":"Key Takeaways (Collection Context)","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#item-58-prefer-for-each-loops-to-traditional-for-loops","title":"Item 58: Prefer For-Each Loops to Traditional For Loops","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#key-takeaways_2","title":"Key Takeaways","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#when-traditional-for-is-needed","title":"When Traditional For is Needed","text":"<ol> <li>Filtering - removing elements</li> <li>Transforming - replacing elements  </li> <li>Parallel iteration - multiple collections</li> </ol>"},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#core-java-volume-i-collections-chapter","title":"Core Java Volume I: Collections Chapter","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#collection-interface-design","title":"Collection Interface Design","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#key-takeaways_3","title":"Key Takeaways","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#list-implementations-deep-dive","title":"List Implementations Deep Dive","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#arraylist-internals","title":"ArrayList Internals","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#linkedlist-internals","title":"LinkedList Internals","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#set-implementations-deep-dive","title":"Set Implementations Deep Dive","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#hashset-internals","title":"HashSet Internals","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#treeset-internals","title":"TreeSet Internals","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#map-implementations-deep-dive","title":"Map Implementations Deep Dive","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#hashmap-deep-dive","title":"HashMap Deep Dive","text":"<p>Key Internal Details: - Initial capacity: 16 - Load factor: 0.75 - Treeification threshold: 8 - Untreeify threshold: 6 - Minimum tree capacity: 64</p> <p>Hash Collision Resolution: 1. Java 7: Linked list only 2. Java 8+: Linked list \u2192 Red-Black tree when bucket size &gt; 8</p>"},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#treemap-internals","title":"TreeMap Internals","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#concurrent-collections","title":"Concurrent Collections","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#concurrenthashmap-design","title":"ConcurrentHashMap Design","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#copyonwritearraylist","title":"CopyOnWriteArrayList","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#theoretical-framework","title":"Theoretical Framework","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#choosing-the-right-collection","title":"Choosing the Right Collection","text":"<pre><code>Need ordering?\n\u251c\u2500\u2500 No \u2192 Need uniqueness?\n\u2502         \u251c\u2500\u2500 Yes \u2192 HashSet\n\u2502         \u2514\u2500\u2500 No \u2192 ArrayList\n\u2514\u2500\u2500 Yes \u2192 What kind of order?\n          \u251c\u2500\u2500 Insertion order \u2192 LinkedHashSet/LinkedHashMap\n          \u251c\u2500\u2500 Sorted order \u2192 TreeSet/TreeMap\n          \u2514\u2500\u2500 Access order \u2192 LinkedHashMap (accessOrder=true)\n</code></pre>"},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#performance-complexity-summary","title":"Performance Complexity Summary","text":"Operation ArrayList LinkedList HashSet TreeSet HashMap TreeMap add O(1)* O(1) O(1) O(log n) O(1) O(log n) remove O(n) O(1)** O(1) O(log n) O(1) O(log n) get/contains O(1)/O(n) O(n) O(1) O(log n) O(1) O(log n) <p>*amortized, **at known position</p>"},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#reflections-connections","title":"Reflections &amp; Connections","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#connections-to-course-material","title":"Connections to Course Material","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#new-perspectives-gained","title":"New Perspectives Gained","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#summary-points","title":"Summary Points","text":""},{"location":"notes/phase-1/topic-6-collections-framework/book-reading/#bookmarks-page-references","title":"Bookmarks &amp; Page References","text":"Topic Reference Note HashMap Internals Core Java Ch. 9 Empty Collections EJ Item 54 For-Each Loops EJ Item 58 Concurrent Collections Core Java Ch. 12 <p>Last Updated: </p>"},{"location":"notes/phase-1/topic-6-collections-framework/summary/","title":"Summary: Collections Framework","text":"<p>Combined Knowledge from: Tim Buchalka's Course + Effective Java + Core Java Mastery Level: </p>"},{"location":"notes/phase-1/topic-6-collections-framework/summary/#topic-overview","title":"Topic Overview","text":"<p>The Java Collections Framework provides a unified architecture for representing and manipulating collections. Understanding its design, implementation details, and performance characteristics is essential for effective Java programming.</p>"},{"location":"notes/phase-1/topic-6-collections-framework/summary/#core-interfaces","title":"Core Interfaces","text":""},{"location":"notes/phase-1/topic-6-collections-framework/summary/#interface-hierarchy","title":"Interface Hierarchy","text":"<pre><code>                     Iterable&lt;E&gt;\n                         \u2502\n                    Collection&lt;E&gt;\n                         \u2502\n        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n        \u2502                \u2502                \u2502\n     List&lt;E&gt;          Set&lt;E&gt;          Queue&lt;E&gt;\n        \u2502                \u2502                \u2502\n        \u2502         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u2502\n        \u2502     SortedSet&lt;E&gt;    \u2502      Deque&lt;E&gt;\n        \u2502         \u2502           \u2502\n        \u2502   NavigableSet&lt;E&gt;   \u2502\n        \u2502                     \u2502\n        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n                    Map&lt;K,V&gt;\n                         \u2502\n                  SortedMap&lt;K,V&gt;\n                         \u2502\n                NavigableMap&lt;K,V&gt;\n</code></pre>"},{"location":"notes/phase-1/topic-6-collections-framework/summary/#list-implementations","title":"List Implementations","text":""},{"location":"notes/phase-1/topic-6-collections-framework/summary/#arraylist","title":"ArrayList","text":"<p>Use When: Random access is frequent, mostly appending</p> <pre><code>ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();\n// Initial capacity: 10\n// Growth: 50% increase (oldCapacity + oldCapacity &gt;&gt; 1)\n</code></pre>"},{"location":"notes/phase-1/topic-6-collections-framework/summary/#linkedlist","title":"LinkedList","text":"<p>Use When: Frequent add/remove at both ends, implementing Queue/Deque</p>"},{"location":"notes/phase-1/topic-6-collections-framework/summary/#vector-legacy","title":"Vector (Legacy)","text":"<p>Use When: Never in new code - use <code>Collections.synchronizedList()</code> instead</p>"},{"location":"notes/phase-1/topic-6-collections-framework/summary/#performance-matrix","title":"Performance Matrix","text":"Operation ArrayList LinkedList get(i) <code>O(1)</code> <code>O(n)</code> add(E) <code>O(1)*</code> <code>O(1)</code> add(i, E) <code>O(n)</code> <code>O(n)</code> remove(i) <code>O(n)</code> <code>O(n)</code> contains <code>O(n)</code> <code>O(n)</code> iterator.remove <code>O(n)</code> <code>O(1)</code> <p>*amortized</p>"},{"location":"notes/phase-1/topic-6-collections-framework/summary/#set-implementations","title":"Set Implementations","text":""},{"location":"notes/phase-1/topic-6-collections-framework/summary/#hashset","title":"HashSet","text":"<p>Use When: Fast lookup, no ordering needed</p> <p>Internal: Backed by HashMap (elements are keys, dummy value)</p>"},{"location":"notes/phase-1/topic-6-collections-framework/summary/#linkedhashset","title":"LinkedHashSet","text":"<p>Use When: Insertion order matters</p> <p>Internal: Backed by LinkedHashMap</p>"},{"location":"notes/phase-1/topic-6-collections-framework/summary/#treeset","title":"TreeSet","text":"<p>Use When: Sorted order needed, range operations</p> <p>Internal: Backed by TreeMap (Red-Black tree)</p>"},{"location":"notes/phase-1/topic-6-collections-framework/summary/#enumset","title":"EnumSet","text":"<p>Use When: Set of enum values</p> <p>Internal: Bit vector - extremely efficient</p>"},{"location":"notes/phase-1/topic-6-collections-framework/summary/#performance-matrix_1","title":"Performance Matrix","text":"Operation HashSet LinkedHashSet TreeSet add <code>O(1)</code> <code>O(1)</code> <code>O(log n)</code> remove <code>O(1)</code> <code>O(1)</code> <code>O(log n)</code> contains <code>O(1)</code> <code>O(1)</code> <code>O(log n)</code> iteration unordered insertion order sorted"},{"location":"notes/phase-1/topic-6-collections-framework/summary/#map-implementations","title":"Map Implementations","text":""},{"location":"notes/phase-1/topic-6-collections-framework/summary/#hashmap","title":"HashMap","text":"<p>Use When: General purpose key-value storage</p> <p>Internals: - Array of buckets - Each bucket: linked list \u2192 Red-Black tree (8+ elements) - Load factor: 0.75 (rehash when 75% full) - Treeification: bucket &gt; 8 AND table &gt; 64</p>"},{"location":"notes/phase-1/topic-6-collections-framework/summary/#linkedhashmap","title":"LinkedHashMap","text":"<p>Use When: Maintain insertion/access order</p> <p>Modes: - Insertion order (default) - Access order (useful for LRU cache)</p>"},{"location":"notes/phase-1/topic-6-collections-framework/summary/#treemap","title":"TreeMap","text":"<p>Use When: Sorted keys, range queries</p> <p>Internal: Red-Black tree ensuring O(log n) operations</p>"},{"location":"notes/phase-1/topic-6-collections-framework/summary/#concurrenthashmap","title":"ConcurrentHashMap","text":"<p>Use When: Thread-safe map access</p> <p>Internal:  - Java 7: Segment-based locking - Java 8+: Bucket-level CAS + synchronized</p>"},{"location":"notes/phase-1/topic-6-collections-framework/summary/#performance-matrix_2","title":"Performance Matrix","text":"Operation HashMap LinkedHashMap TreeMap ConcurrentHashMap get <code>O(1)</code> <code>O(1)</code> <code>O(log n)</code> <code>O(1)</code> put <code>O(1)</code> <code>O(1)</code> <code>O(log n)</code> <code>O(1)</code> containsKey <code>O(1)</code> <code>O(1)</code> <code>O(log n)</code> <code>O(1)</code> Thread-safe"},{"location":"notes/phase-1/topic-6-collections-framework/summary/#queue-deque","title":"Queue &amp; Deque","text":""},{"location":"notes/phase-1/topic-6-collections-framework/summary/#priorityqueue","title":"PriorityQueue","text":"<p>Use When: Priority-based processing</p> <p>Internal: Binary heap</p>"},{"location":"notes/phase-1/topic-6-collections-framework/summary/#arraydeque","title":"ArrayDeque","text":"<p>Use When: Stack or queue operations (faster than Stack and LinkedList)</p> <p>Internal: Resizable circular array</p>"},{"location":"notes/phase-1/topic-6-collections-framework/summary/#key-internals","title":"Key Internals","text":""},{"location":"notes/phase-1/topic-6-collections-framework/summary/#hashmap-collision-resolution","title":"HashMap Collision Resolution","text":"<pre><code>Bucket Structure:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 table[0] \u2192 null                 \u2502\n\u2502 table[1] \u2192 Node \u2192 Node \u2192 Node   \u2502  (linked list for &lt; 8 entries)\n\u2502 table[2] \u2192 TreeNode (root)      \u2502  (tree for &gt;= 8 entries)\n\u2502    ...                          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"notes/phase-1/topic-6-collections-framework/summary/#red-black-tree-properties","title":"Red-Black Tree Properties","text":"<ol> <li>Every node is red or black</li> <li>Root is black</li> <li>Leaves (null) are black</li> <li>Red node's children are black</li> <li>Same black-height on all paths</li> </ol> <p>Guarantees: O(log n) for search, insert, delete</p>"},{"location":"notes/phase-1/topic-6-collections-framework/summary/#choosing-the-right-collection","title":"Choosing the Right Collection","text":""},{"location":"notes/phase-1/topic-6-collections-framework/summary/#decision-tree","title":"Decision Tree","text":"<pre><code>What do you need?\n\u251c\u2500\u2500 Key-Value pairs?\n\u2502   \u2514\u2500\u2500 Map\n\u2502       \u251c\u2500\u2500 Thread-safe? \u2192 ConcurrentHashMap\n\u2502       \u251c\u2500\u2500 Sorted? \u2192 TreeMap\n\u2502       \u251c\u2500\u2500 Insertion order? \u2192 LinkedHashMap\n\u2502       \u2514\u2500\u2500 None of above \u2192 HashMap\n\u251c\u2500\u2500 Unique elements?\n\u2502   \u2514\u2500\u2500 Set\n\u2502       \u251c\u2500\u2500 Sorted? \u2192 TreeSet\n\u2502       \u251c\u2500\u2500 Insertion order? \u2192 LinkedHashSet\n\u2502       \u2514\u2500\u2500 None of above \u2192 HashSet\n\u251c\u2500\u2500 Ordered sequence?\n\u2502   \u2514\u2500\u2500 List\n\u2502       \u251c\u2500\u2500 Frequent random access? \u2192 ArrayList\n\u2502       \u2514\u2500\u2500 Frequent add/remove at ends? \u2192 LinkedList\n\u2514\u2500\u2500 FIFO/Priority processing?\n    \u2514\u2500\u2500 Queue/Deque\n        \u251c\u2500\u2500 Priority? \u2192 PriorityQueue\n        \u2514\u2500\u2500 FIFO/LIFO? \u2192 ArrayDeque\n</code></pre>"},{"location":"notes/phase-1/topic-6-collections-framework/summary/#common-pitfalls","title":"Common Pitfalls","text":"<ol> <li>Modifying collection while iterating</li> <li> <p>Use Iterator.remove() or ConcurrentHashMap</p> </li> <li> <p>Wrong equals/hashCode for keys</p> </li> <li> <p>Always override both consistently</p> </li> <li> <p>Using mutable objects as keys</p> </li> <li> <p>Prefer immutable keys</p> </li> <li> <p>Not sizing collections upfront</p> </li> <li> <p>Use initial capacity when size is known</p> </li> <li> <p>Returning null instead of empty collection</p> </li> <li>Return Collections.emptyList() etc.</li> </ol>"},{"location":"notes/phase-1/topic-6-collections-framework/summary/#best-practices-checklist","title":"Best Practices Checklist","text":"<ul> <li> Choose collection based on access patterns</li> <li> Size collections appropriately when known</li> <li> Use interface types for declarations</li> <li> Prefer immutable collections when possible</li> <li> Return empty collections, not null</li> <li> Override equals/hashCode for custom keys</li> <li> Use ConcurrentHashMap for thread safety</li> </ul>"},{"location":"notes/phase-1/topic-6-collections-framework/summary/#related-topics","title":"Related Topics","text":"<ul> <li>Arrays, Lists &amp; Generics</li> <li>Lambdas &amp; Streams</li> <li>OOP &amp; Class Design</li> </ul>"},{"location":"notes/phase-1/topic-6-collections-framework/summary/#references","title":"References","text":"<ul> <li>Course: Tim Buchalka - Java Programming Masterclass</li> <li>Book: Effective Java - Joshua Bloch (Items 54, 55, 58)</li> <li>Book: Core Java Volume I - Cay S. Horstmann (Chapter 9)</li> <li>Documentation: Oracle Collections Framework</li> </ul> <p>Completed:  | Confidence: X/10</p>"},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/","title":"Topic Note: Collections Framework","text":"<p>Course: Java Programming Masterclass - Tim Buchalka (Udemy) Status:  In Progress</p>"},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#learning-objectives","title":"Learning Objectives","text":"<ul> <li> Master the Collections hierarchy</li> <li> Choose the right collection for each use case</li> <li> Understand internal implementations</li> <li> Apply collections efficiently in real-world scenarios</li> </ul>"},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#key-concepts-from-the-course","title":"Key Concepts from the Course","text":""},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#collections-hierarchy-overview","title":"Collections Hierarchy Overview","text":"<pre><code>                    Iterable\n                       \u2502\n                   Collection\n                       \u2502\n          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n         List         Set         Queue\n          \u2502            \u2502            \u2502\n    \u250c\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2510   \u250c\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2510\nArrayList  \u2502  LinkedList \u2502  \u2502   \u2502     \u2502\n       LinkedList  HashSet \u2502  TreeSet  \u2502\n                         \u2502       PriorityQueue\n                   LinkedHashSet      ArrayDeque\n\n                      Map (separate hierarchy)\n                       \u2502\n          \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n       HashMap    LinkedHashMap   TreeMap\n          \u2502\n    ConcurrentHashMap\n</code></pre>"},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#list-interface","title":"List Interface","text":""},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#arraylist","title":"ArrayList","text":"<p>Characteristics: - Backed by resizable array - O(1) random access - O(n) insertion/deletion in middle - Good default choice for lists</p>"},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#linkedlist","title":"LinkedList","text":"<p>Characteristics: - Doubly-linked list - O(n) random access - O(1) insertion/deletion at known position - Implements both List and Deque</p>"},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#arraylist-vs-linkedlist","title":"ArrayList vs LinkedList","text":"Operation ArrayList LinkedList get(index) O(1) O(n) add(end) O(1)* O(1) add(index) O(n) O(n)** remove(index) O(n) O(n)** Iterator.remove() O(n) O(1) <p>*amortized, **finding position is O(n), operation is O(1)</p>"},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#set-interface","title":"Set Interface","text":""},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#hashset","title":"HashSet","text":""},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#linkedhashset","title":"LinkedHashSet","text":""},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#treeset","title":"TreeSet","text":""},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#choosing-the-right-set","title":"Choosing the Right Set","text":"Set Type Ordering Null Performance HashSet None Yes O(1) LinkedHashSet Insertion Yes O(1) TreeSet Sorted No* O(log n) <p>*TreeSet allows null only if using a Comparator that handles it</p>"},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#map-interface","title":"Map Interface","text":""},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#hashmap","title":"HashMap","text":"<p>Internal Structure: - Array of buckets - Hash function determines bucket - Collision resolution: linked list \u2192 Red-Black tree (Java 8+)</p> <p>Key Operations: - Load factor (default 0.75) - Rehashing when threshold exceeded</p>"},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#linkedhashmap","title":"LinkedHashMap","text":""},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#treemap","title":"TreeMap","text":""},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#concurrenthashmap","title":"ConcurrentHashMap","text":""},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#queue-deque","title":"Queue &amp; Deque","text":""},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#priorityqueue","title":"PriorityQueue","text":""},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#arraydeque","title":"ArrayDeque","text":""},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#special-collections","title":"Special Collections","text":""},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#collections-utility-class","title":"Collections Utility Class","text":"<pre><code>Collections.sort(list);\nCollections.reverse(list);\nCollections.shuffle(list);\nCollections.binarySearch(sortedList, key);\nCollections.unmodifiableList(list);\nCollections.synchronizedList(list);\n</code></pre>"},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#immutable-collections-java-9","title":"Immutable Collections (Java 9+)","text":"<pre><code>List.of(1, 2, 3);\nSet.of(\"a\", \"b\", \"c\");\nMap.of(\"key1\", \"val1\", \"key2\", \"val2\");\n</code></pre>"},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#observed-ideas-insights","title":"Observed Ideas &amp; Insights","text":""},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#performance-patterns","title":"Performance Patterns","text":""},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#memory-considerations","title":"Memory Considerations","text":""},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#code-snippets-examples","title":"Code Snippets &amp; Examples","text":"<pre><code>// Add your practice code snippets here\n</code></pre>"},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#questions-to-explore","title":"Questions to Explore","text":"<ul> <li> How does HashMap handle hash collisions?</li> <li> When does HashMap convert buckets to trees?</li> <li> What's the difference between fail-fast and fail-safe iterators?</li> </ul>"},{"location":"notes/phase-1/topic-6-collections-framework/topic-note/#quick-reference","title":"Quick Reference","text":"Collection Best For ArrayList Random access, iteration LinkedList Frequent insert/delete at ends HashSet Fast uniqueness check TreeSet Sorted unique elements HashMap Key-value storage TreeMap Sorted key-value pairs PriorityQueue Priority-based processing <p>Last Updated: </p>"},{"location":"notes/phase-2/","title":"Phase 2: Advanced Java &amp; Concurrency","text":"<p>Master advanced Java concepts including multithreading, concurrency primitives, and JVM internals.</p> <p>Duration: 2-3 Months</p>"},{"location":"notes/phase-2/#topics","title":"Topics","text":"<ul> <li> <p> Multithreading &amp; Concurrency</p> <p>Threads, synchronization, locks, ExecutorService, CompletableFuture.</p> <p> Learn More</p> </li> <li> <p> JVM Internals &amp; Memory</p> <p>JVM architecture, class loading, runtime data areas.</p> <p> Learn More</p> </li> <li> <p> Garbage Collection</p> <p>GC algorithms, heap structure, tuning parameters.</p> <p> Learn More</p> </li> <li> <p> Performance Optimization</p> <p>Profiling, bottlenecks, optimization techniques.</p> <p> Learn More</p> </li> <li> <p> Advanced Java Features</p> <p>Modules (JPMS), Records, Sealed Classes, Virtual Threads.</p> <p> Learn More</p> </li> </ul>"},{"location":"notes/phase-2/#project-ideas","title":"Project Ideas","text":"<ol> <li>Multi-threaded Web Crawler - Practice concurrency, thread pools</li> <li>Concurrent Chat Server - Use sockets, ExecutorService, synchronization</li> <li>JVM Memory Analyzer Tool - Parse heap dumps, analyze GC logs</li> <li>Performance Benchmarking Framework - Profile different implementations</li> </ol>"},{"location":"notes/phase-2/advanced-features/","title":"Advanced Java Features (Java 9+)","text":""},{"location":"notes/phase-2/advanced-features/#core-topics","title":"Core Topics","text":"<ul> <li>Modules (JPMS): module-info.java, exports, requires</li> <li>var Keyword: Local variable type inference</li> <li>Records: Immutable data carriers</li> <li>Sealed Classes: Restricted inheritance</li> <li>Pattern Matching: instanceof, switch expressions</li> <li>Text Blocks: Multi-line strings</li> <li>Virtual Threads (Java 21): Lightweight concurrency</li> </ul>"},{"location":"notes/phase-2/advanced-features/#key-internals-to-understand","title":"Key Internals to Understand","text":"<ul> <li>How virtual threads differ from platform threads</li> <li>Module resolution at startup</li> <li>Record implementation details</li> </ul>"},{"location":"notes/phase-2/advanced-features/#notes","title":"Notes","text":""},{"location":"notes/phase-2/garbage-collection/","title":"Garbage Collection","text":""},{"location":"notes/phase-2/garbage-collection/#core-topics","title":"Core Topics","text":""},{"location":"notes/phase-2/garbage-collection/#gc-algorithms","title":"GC Algorithms","text":"<ul> <li>Serial GC</li> <li>Parallel GC</li> <li>CMS (Concurrent Mark Sweep)</li> <li>G1 (Garbage-First)</li> <li>ZGC</li> <li>Shenandoah</li> </ul>"},{"location":"notes/phase-2/garbage-collection/#gc-phases","title":"GC Phases","text":"<ul> <li>Mark</li> <li>Sweep</li> <li>Compact</li> </ul>"},{"location":"notes/phase-2/garbage-collection/#generational-hypothesis","title":"Generational Hypothesis","text":"<ul> <li>Young Generation (Eden, Survivor spaces)</li> <li>Old Generation</li> <li>Generational collection benefits</li> </ul>"},{"location":"notes/phase-2/garbage-collection/#gc-tuning-parameters","title":"GC Tuning Parameters","text":"<ul> <li>Heap size configuration</li> <li>GC algorithm selection</li> <li>Pause time goals</li> </ul>"},{"location":"notes/phase-2/garbage-collection/#key-internals-to-understand","title":"Key Internals to Understand","text":"<ul> <li>Generational GC benefits</li> <li>Stop-the-world pauses</li> <li>Memory leaks in Java</li> <li>GC logging and analysis</li> </ul>"},{"location":"notes/phase-2/garbage-collection/#notes","title":"Notes","text":""},{"location":"notes/phase-2/jvm-internals/","title":"JVM Internals &amp; Memory Management","text":""},{"location":"notes/phase-2/jvm-internals/#core-topics","title":"Core Topics","text":""},{"location":"notes/phase-2/jvm-internals/#jvm-architecture","title":"JVM Architecture","text":"<ul> <li>Class Loader Subsystem (Bootstrap, Extension, Application)</li> <li>Runtime Data Areas (Method Area, Heap, Stack, PC Registers, Native Method Stack)</li> <li>Execution Engine (Interpreter, JIT Compiler, Garbage Collector)</li> </ul>"},{"location":"notes/phase-2/jvm-internals/#class-loading-mechanism","title":"Class Loading Mechanism","text":"<ul> <li>Loading \u2192 Linking (Verification, Preparation, Resolution) \u2192 Initialization</li> </ul>"},{"location":"notes/phase-2/jvm-internals/#memory-management","title":"Memory Management","text":"<ul> <li>Heap Structure (Young Generation: Eden, Survivor; Old Generation; Metaspace)</li> <li>Stack memory and stack frames</li> <li>Method Area and Runtime Constant Pool</li> </ul>"},{"location":"notes/phase-2/jvm-internals/#jvm-monitoring-profiling","title":"JVM Monitoring &amp; Profiling","text":"<ul> <li>JVisualVM, JConsole, JProfiler, YourKit</li> <li>Java Flight Recorder (JFR)</li> </ul>"},{"location":"notes/phase-2/jvm-internals/#key-internals-to-understand","title":"Key Internals to Understand","text":"<ul> <li>Bytecode structure and execution</li> <li>JIT compilation strategies (C1, C2 compilers)</li> <li>Escape analysis and scalar replacement</li> <li>How native methods work (JNI)</li> </ul>"},{"location":"notes/phase-2/jvm-internals/#notes","title":"Notes","text":""},{"location":"notes/phase-2/multithreading/","title":"Multithreading &amp; Concurrency","text":""},{"location":"notes/phase-2/multithreading/#core-topics","title":"Core Topics","text":"<ul> <li>Thread Basics: Creating threads (Thread class, Runnable, Callable)</li> <li>Thread Lifecycle: NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED</li> <li>Synchronization: synchronized keyword, intrinsic locks</li> <li>volatile Keyword: Visibility guarantees, happens-before relationship</li> <li>wait(), notify(), notifyAll(): Inter-thread communication</li> <li>Locks: ReentrantLock, ReadWriteLock, StampedLock</li> <li>Thread Pools: ExecutorService, ThreadPoolExecutor, ForkJoinPool</li> <li>Concurrent Collections: ConcurrentHashMap, CopyOnWriteArrayList, BlockingQueue</li> <li>Atomic Variables: AtomicInteger, AtomicReference</li> <li>Future &amp; CompletableFuture: Asynchronous programming</li> </ul>"},{"location":"notes/phase-2/multithreading/#key-internals-to-understand","title":"Key Internals to Understand","text":"<ul> <li>Java Memory Model (JMM) - happens-before relationships</li> <li>Thread scheduling by JVM</li> <li>Lock implementation internals</li> <li>Compare-and-Swap (CAS) operations</li> <li>Thread contention and performance implications</li> <li>Lock striping technique</li> <li>Fork-Join framework architecture</li> </ul>"},{"location":"notes/phase-2/multithreading/#notes","title":"Notes","text":""},{"location":"notes/phase-2/performance/","title":"Java Performance Optimization","text":""},{"location":"notes/phase-2/performance/#core-topics","title":"Core Topics","text":"<ul> <li>Code profiling techniques</li> <li>Identifying bottlenecks</li> <li>Memory leak detection</li> <li>CPU vs I/O bound optimization</li> <li>Efficient collection usage</li> <li>Avoiding premature optimization</li> </ul>"},{"location":"notes/phase-2/performance/#tools-to-learn","title":"Tools to Learn","text":"<ul> <li>JProfiler</li> <li>VisualVM</li> <li>YourKit Profiler</li> <li>Java Mission Control</li> </ul>"},{"location":"notes/phase-2/performance/#key-internals-to-understand","title":"Key Internals to Understand","text":"<ul> <li>JIT compilation hotspots</li> <li>Inlining and dead code elimination</li> <li>String concatenation optimization</li> <li>Primitive vs wrapper performance</li> </ul>"},{"location":"notes/phase-2/performance/#notes","title":"Notes","text":""},{"location":"projects/","title":"Projects","text":"<p>Applied projects demonstrating practical implementation of learned concepts.</p>"},{"location":"projects/#project-categories","title":"Project Categories","text":""},{"location":"projects/#beginner-projects","title":"Beginner Projects","text":"<p>Practice fundamental concepts with these starter projects.</p>"},{"location":"projects/#intermediate-projects","title":"Intermediate Projects","text":"<p>Apply OOP, design patterns, and frameworks.</p>"},{"location":"projects/#advanced-projects","title":"Advanced Projects","text":"<p>Full-stack applications and microservices.</p>"},{"location":"projects/#project-list","title":"Project List","text":"Project Level Technologies Status Coming Soon - -"},{"location":"projects/#adding-a-new-project","title":"Adding a New Project","text":"<p>Use the Project Template to document your projects consistently.</p> <p>Each project should include:</p> <ol> <li>Overview - What the project does</li> <li>Technologies Used - Stack and tools</li> <li>Architecture - System design</li> <li>Key Learnings - What you learned</li> <li>Setup Instructions - How to run it</li> <li>GitHub Link - Source code repository</li> </ol> <p>Project Ideas</p> <ul> <li>Console-based To-Do App (Beginner)</li> <li>REST API with Spring Boot (Intermediate)</li> <li>E-commerce Microservices (Advanced)</li> </ul>"},{"location":"projects/project-template/","title":"Project Template","text":"<p>Use this template when documenting a new project.</p>"},{"location":"projects/project-template/#overview","title":"Overview","text":"<p>Project Name: [Project Name] Level: Beginner / Intermediate / Advanced Status: \ud83d\udfe2 Complete / \ud83d\udfe1 In Progress / \ud83d\udd34 Planned GitHub: Repository Link</p>"},{"location":"projects/project-template/#technologies-used","title":"Technologies Used","text":"Category Technology Language Java 17+ Framework Spring Boot Database PostgreSQL Build Tool Maven Testing JUnit 5, Mockito"},{"location":"projects/project-template/#architecture","title":"Architecture","text":"<pre><code>graph TD\n    A[Client] --&gt; B[API Gateway]\n    B --&gt; C[Service Layer]\n    C --&gt; D[Repository]\n    D --&gt; E[(Database)]</code></pre>"},{"location":"projects/project-template/#key-features","title":"Key Features","text":"<ul> <li> Feature 1</li> <li> Feature 2</li> <li> Feature 3</li> </ul>"},{"location":"projects/project-template/#what-i-learned","title":"What I Learned","text":"<ol> <li>Concept 1 - Description</li> <li>Concept 2 - Description</li> <li>Concept 3 - Description</li> </ol>"},{"location":"projects/project-template/#setup-instructions","title":"Setup Instructions","text":""},{"location":"projects/project-template/#prerequisites","title":"Prerequisites","text":"<ul> <li>Java 17+</li> <li>Maven 3.8+</li> <li>PostgreSQL</li> </ul>"},{"location":"projects/project-template/#running-the-project","title":"Running the Project","text":"<pre><code># Clone the repository\ngit clone https://github.com/username/project.git\ncd project\n\n# Build the project\nmvn clean install\n\n# Run the application\nmvn spring-boot:run\n</code></pre>"},{"location":"projects/project-template/#screenshots","title":"Screenshots","text":""},{"location":"projects/project-template/#resources","title":"Resources","text":"<ul> <li>Link to related documentation</li> <li>Link to tutorial followed</li> </ul>"},{"location":"resources/","title":"Resources","text":"<p>Curated collection of learning materials from the Java Roadmap 2025.</p>"},{"location":"resources/#categories","title":"Categories","text":"<ul> <li> <p> Tutorials</p> <p>Step-by-step guides and interactive platforms.</p> <p> View Tutorials</p> </li> <li> <p> Courses</p> <p>Online courses from Udemy, Coursera, and YouTube.</p> <p> View Courses</p> </li> <li> <p> Documentation</p> <p>Official documentation and reference guides.</p> <p> View Docs</p> </li> <li> <p> Tools</p> <p>Development tools, IDEs, and profilers.</p> <p> View Tools</p> </li> </ul>"},{"location":"resources/#quick-links","title":"Quick Links","text":"Resource Type Description Baeldung Tutorial Excellent Java/Spring tutorials Jenkov.com Tutorial Java tutorials with internals GeeksforGeeks Java Tutorial DSA + Java tutorials Oracle Java Tutorials Official The official Java tutorials Spring.io Guides Official Spring Framework guides"},{"location":"resources/courses/","title":"Courses","text":"<p>Online courses from the Java Roadmap 2025.</p>"},{"location":"resources/courses/#phase-1-java-fundamentals","title":"Phase 1: Java Fundamentals","text":"Course Platform Description Java Programming Fundamentals - IBM Coursera Free audit available Java Programming Masterclass (Java 17) Udemy Tim Buchalka - 130+ hours Master Java Programming GeeksforGeeks 20+ hours basics OOP in Java Specialization Coursera Duke University"},{"location":"resources/courses/#phase-2-advanced-java","title":"Phase 2: Advanced Java","text":"Course Platform Description Java Multithreading &amp; Concurrency Udemy Concurrency deep dive Modern Java Deep Dive YouTube Java 22/23 features (2.5 hours) JVM Internals YouTube JVM architecture"},{"location":"resources/courses/#youtube-channels","title":"YouTube Channels","text":"Channel Focus Java Brains Spring, Microservices freeCodeCamp Full courses Telusko Java basics Amigoscode Spring Boot Inside Java Official Oracle channel"},{"location":"resources/courses/#deep-dives","title":"Deep Dives","text":"Video Topic Virtual Thread Deep Dive - nipafx Project Loom A Deep Dive into JVM Start-up JVM internals Modern Java Deep Dive Java 22/23 features"},{"location":"resources/documentation/","title":"Documentation","text":"<p>Official documentation and reference guides.</p>"},{"location":"resources/documentation/#java-se-documentation","title":"Java SE Documentation","text":"Resource Description Java SE Documentation Official Java docs Java API Docs (Java 21) API reference Java Language Specification JLS Java Language Updates Java 9+ features"},{"location":"resources/documentation/#key-websites","title":"Key Websites","text":"Website Description docs.oracle.com/javase Java SE Documentation baeldung.com Excellent Java/Spring tutorials jenkov.com Java tutorials with internals refactoring.guru Design patterns java-design-patterns.com Pattern implementations"},{"location":"resources/documentation/#jvm-performance","title":"JVM &amp; Performance","text":"Resource Description JVM Internals - James Bloom Comprehensive JVM architecture JVM Architecture - GeeksforGeeks How JVM works Understanding Memory - Oracle Memory management Garbage Collection - IBM Heap memory and GC"},{"location":"resources/documentation/#articles-deep-dives","title":"Articles &amp; Deep Dives","text":"Article Topic JVM Internals - James D Bloom Blog JVM architecture 12 Tips to Optimize Java Code - GeeksforGeeks Performance Java Performance Optimization - Raygun Optimization Mastering Java Concurrency - Dev.to Concurrency"},{"location":"resources/documentation/#community","title":"Community","text":"Resource Description Stack Overflow Q&amp;A Reddit r/java Java community Reddit r/learnjava Learning community Dev.to Developer articles"},{"location":"resources/tools/","title":"Development Tools","text":"<p>Essential tools for Java development from the Java Roadmap 2025.</p>"},{"location":"resources/tools/#ides","title":"IDEs","text":"Tool Description IntelliJ IDEA Most popular Java IDE VS Code Lightweight with Java extensions Eclipse Open-source IDE"},{"location":"resources/tools/#jvm-profiling-monitoring","title":"JVM Profiling &amp; Monitoring","text":"Tool Description JProfiler Java profiler VisualVM JVM monitoring YourKit Java profiler Java Mission Control Oracle profiling tool JConsole JVM monitoring Java Flight Recorder (JFR) Event recording"},{"location":"resources/tools/#code-quality","title":"Code Quality","text":"Tool Description SonarQube Code quality scanner Checkstyle Coding standards SpotBugs Bug finder PMD Source code analyzer JaCoCo Code coverage"},{"location":"resources/tools/#build-tools","title":"Build Tools","text":"Tool Description Maven Dependency management and build Gradle Modern build automation"},{"location":"resources/tools/#testing","title":"Testing","text":"Tool Description JUnit 5 Testing framework Mockito Mocking framework AssertJ Fluent assertions TestContainers Integration testing"},{"location":"resources/tools/#version-control","title":"Version Control","text":"Tool Description Git Version control GitHub Code hosting GitLab DevOps platform"},{"location":"resources/tutorials/","title":"Tutorials","text":"<p>Curated tutorials and interactive platforms from the Java Roadmap 2025.</p>"},{"location":"resources/tutorials/#official-tutorials","title":"Official Tutorials","text":"Tutorial Description Oracle Java Tutorials The official Java tutorials Java Collections Framework Guide Official Collections documentation Java NIO Tutorial Official NIO documentation Java Language Updates Java 9+ feature documentation"},{"location":"resources/tutorials/#community-tutorials","title":"Community Tutorials","text":"Tutorial Description Focus Baeldung Excellent Java/Spring tutorials All levels Jenkov.com Java tutorials with internals Concurrency GeeksforGeeks Java DSA + Java tutorials All levels DigitalOcean Java Practical tutorials Beginner"},{"location":"resources/tutorials/#concurrency-tutorials","title":"Concurrency Tutorials","text":"Tutorial Description Java Concurrency Tutorial - Jenkov Comprehensive concurrency guide Java Concurrency - Baeldung Concurrency tutorials Multithreading - GeeksforGeeks Multithreading basics"},{"location":"resources/tutorials/#java-8-tutorials","title":"Java 8+ Tutorials","text":"Tutorial Description Java Streams - Baeldung Stream API tutorial Java 8 Stream Tutorial - Jenkov Functional programming Functional Programming with Streams Functional interfaces"},{"location":"resources/tutorials/#practice-platforms","title":"Practice Platforms","text":"Platform Description HackerRank Java Track Java challenges LeetCode Algorithm practice Codecademy Java Interactive Java course Exercism Java Track Practice with mentorship"}]}